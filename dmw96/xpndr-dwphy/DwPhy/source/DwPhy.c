//--< DwPhy.c >------------------------------------------------------------------------------------
//=================================================================================================

//
//  DW PHY Interface Functions for the Driver
//  Copyright 2007-2011 DSP Group, Inc. All rights reserved.
//
//  This module is maintained by Barrett Brickner
//
//  Code in this module will be included in the Kona WLAN driver and must not use 'c' floating
//  point calculations or console/file I/O.
//
//=================================================================================================
//-------------------------------------------------------------------------------------------------

#include "DwPhy.h"
#define     DWPHY_VERSION       3
#define     RF_ADDR_OFFSET      256


// ================================================================================================
// DEFAULT REGISTER SETTINGS
// ================================================================================================
//
// Bermai 5 GHz WLAN: Dakota 2/2g/4 + Basie C
//
#if defined(DWPHY_SUPPORT_BERMAI)
    //
    // Dakota2/2g + Basie C (2004-05-14)
    //
    static const dwPhyRegPair_t DefaultReg_Dakota2_BasieC[] = 
    {
        {0x002,0x07}, {0x003,0x03}, {0x004,0x52}, {0x006,0x30}, {0x007,0x00}, {0x008,0xAE}, {0x00C,0x00}, {0x00D,0x00}, 
        {0x00E,0x7F}, {0x00F,0xAA}, {0x010,0x78}, {0x01E,0x43}, {0x01F,0x00}, {0x020,0x11}, {0x021,0x11}, {0x022,0x11}, 
        {0x023,0x11}, {0x024,0x11}, {0x025,0x11}, {0x026,0x11}, {0x027,0x11}, {0x028,0x11}, {0x029,0x11}, {0x02A,0x11}, 
        {0x02B,0x11}, {0x02C,0x11}, {0x02D,0x11}, {0x02E,0x11}, {0x02F,0x11}, {0x030,0x17}, {0x031,0x17}, {0x032,0x17}, 
        {0x033,0x17}, {0x034,0x17}, {0x035,0x17}, {0x036,0x17}, {0x037,0x17}, {0x038,0x17}, {0x039,0x17}, {0x03A,0x17}, 
        {0x03B,0x17}, {0x03C,0x17}, {0x03D,0x17}, {0x03E,0x17}, {0x03F,0x17}, {0x040,0x09}, {0x041,0x1A}, {0x042,0x3C}, 
        {0x043,0x48}, {0x044,0x44}, {0x045,0x0C}, {0x046,0x08}, {0x047,0x0D}, {0x048,0x1F}, {0x049,0x35}, {0x04A,0x3C}, 
        {0x04B,0x06}, {0x04C,0x39}, {0x04D,0x00}, {0x060,0x80}, {0x061,0x0A}, {0x062,0x90}, {0x063,0x04}, {0x064,0x40}, 
        {0x070,0x84}, {0x071,0x11}, {0x072,0x00}, {0x073,0x00}, {0x078,0x84}, {0x079,0x9B}, {0x07A,0x10}, {0x080,0x04}, 
        {0x102,0x28}, {0x105,0x03}, {0x106,0x3F}, {0x109,0x20}, {0x10A,0x20}, {0x10B,0x20}, {0x110,0x0F}, {0x111,0x10}, 
        {0x112,0xFC}, {0x113,0x4C}, {0x116,0x0F}, {0x117,0xFF}, {0x118,0x04}, {0x119,0x00}, {0x11A,0x08}, {0x11B,0x1A}, 
        {0x11C,0x43}, {0x11D,0xF8}, {0x11E,0x38}, {0x11F,0x10}, {0x120,0x8C}, {0x121,0x8C}, {0x122,0x50}, {0x123,0x23}, 
        {0x124,0x20}, {0x125,0x20}, {0x134,0x80}, {0x135,0xA2}, {0x136,0xA2}, {0x137,0xA2}, {0x138,0xA2}, {0x139,0x00}, 
        {0x13A,0x00}, {0x13B,0x00}, {0x13C,0xF0}, {0x13D,0xF0}, {0x13E,0x88}, {0x13F,0x80}, {0x142,0x00}, {0x143,0x00}, 
        {0x144,0x00}, {0x145,0x00}, {0x147,0x00}, {0x160,0x02}, {0x161,0x02}, {0x162,0x88}, {0x163,0x00}, {0x164,0x00}, 
        {0x165,0xA0}, {0x166,0x01}, {0x167,0x86}, {0x168,0x88}, {0x169,0xFF}, {0x16A,0x39}, {0x16B,0xF0}, {0x16C,0x80}, 
        {0x16D,0x08}
    };
    //
    // Bob 4.2: Dakota4 + Basie C (2007-08-08)
    // This version was created to support DW52 bringup using the Bermai PHY.
    // It has reduced radio gain to accomodate an external LNA and used only RXB (no diversity)
    // to reduce LO/CFO errors on TX
    //
    static const dwPhyRegPair_t DefaultReg_Dakota4_BasieC_Bob42[] = 
    {
        {0x002,0x07}, {0x003,0x45}, {0x004,0xD2}, {0x006,0x30}, {0x007,0x00}, {0x008,0xAE}, {0x00C,0x00}, {0x00D,0x00}, 
        {0x00E,0x7F}, {0x00F,0xAA}, {0x010,0x78}, {0x01E,0x43}, {0x01F,0x00}, {0x020,0x11}, {0x021,0x11}, {0x022,0x11}, 
        {0x023,0x11}, {0x024,0x11}, {0x025,0x11}, {0x026,0x11}, {0x027,0x11}, {0x028,0x11}, {0x029,0x11}, {0x02A,0x11}, 
        {0x02B,0x11}, {0x02C,0x11}, {0x02D,0x11}, {0x02E,0x11}, {0x02F,0x11}, {0x030,0x17}, {0x031,0x17}, {0x032,0x17}, 
        {0x033,0x17}, {0x034,0x17}, {0x035,0x17}, {0x036,0x17}, {0x037,0x17}, {0x038,0x17}, {0x039,0x17}, {0x03A,0x17}, 
        {0x03B,0x17}, {0x03C,0x17}, {0x03D,0x17}, {0x03E,0x17}, {0x03F,0x17}, {0x040,0x09}, {0x041,0x16}, {0x042,0x3C}, 
        {0x043,0x48}, {0x044,0x44}, {0x045,0x0C}, {0x046,0x08}, {0x047,0x0D}, {0x048,0x1F}, {0x049,0x35}, {0x04A,0x3C}, 
        {0x04B,0x06}, {0x04C,0x39}, {0x04D,0x00}, {0x060,0x80}, {0x061,0x0A}, {0x062,0x90}, {0x063,0x04}, {0x064,0x40}, 
        {0x070,0x84}, {0x071,0x11}, {0x072,0x00}, {0x073,0x00}, {0x078,0x84}, {0x079,0x9B}, {0x07A,0x10}, {0x080,0x04}, 
        {0x102,0x28}, {0x105,0x02}, {0x106,0x3F}, {0x109,0x20}, {0x10A,0x20}, {0x10B,0x20}, {0x110,0x0F}, {0x111,0x10}, 
        {0x112,0xFC}, {0x113,0x4C}, {0x116,0x0F}, {0x117,0xFF}, {0x118,0x04}, {0x119,0x00}, {0x11A,0x08}, {0x11B,0x1A}, 
        {0x11C,0x43}, {0x11D,0xF8}, {0x11E,0x38}, {0x11F,0x10}, {0x120,0x8C}, {0x121,0x8C}, {0x122,0x50}, {0x123,0x23}, 
        {0x124,0x20}, {0x125,0x20}, {0x134,0x80}, {0x135,0xA2}, {0x136,0xA2}, {0x137,0xA2}, {0x138,0xA2}, {0x139,0x00}, 
        {0x13A,0x00}, {0x13B,0x00}, {0x13C,0xF0}, {0x13D,0xF0}, {0x13E,0x88}, {0x13F,0x80}, {0x142,0x00}, {0x143,0x00}, 
        {0x144,0x00}, {0x145,0x00}, {0x147,0x00}, {0x160,0x02}, {0x161,0x02}, {0x162,0x88}, {0x163,0x00}, {0x164,0x00}, 
        {0x165,0xA0}, {0x166,0x01}, {0x167,0x86}, {0x168,0x88}, {0x169,0xFF}, {0x16A,0x39}, {0x16B,0xF0}, {0x16C,0x80}, 
        {0x16D,0x08}
    };
#endif // DWPHY_SUPPORT_BERMAI
//
// DW52/74
// Mojave Baseband and RF52 Radio on a Sandy/Debby module
//
#if defined(DWPHY_SUPPORT_MOJAVE) || defined(DWPHY_SUPPORT_MOJAVE1B)

    static dwPhyRegPair_t DefaultReg_Mojave_RF52A120[] = 
    {
        {0x003,0x03}, {0x004,0x03}, {0x006,0x23}, {0x007,0x00}, {0x008,0x12}, {0x009,0x00}, {0x00A,0x00}, {0x00B,0x00}, 
        {0x00C,0x00}, {0x00D,0x00}, {0x00E,0x7F}, {0x018,0x61}, {0x019,0x03}, {0x01E,0x43}, {0x01F,0x00}, {0x020,0x0C}, 
        {0x021,0x0C}, {0x022,0x0C}, {0x023,0x0C}, {0x024,0x0C}, {0x025,0x0C}, {0x026,0x0C}, {0x027,0x0C}, {0x028,0x0C}, 
        {0x029,0x0C}, {0x02A,0x0C}, {0x02B,0x0C}, {0x02C,0x0C}, {0x02D,0x0C}, {0x02E,0x0C}, {0x02F,0x0C}, {0x030,0x02}, 
        {0x031,0x02}, {0x032,0x02}, {0x033,0x02}, {0x034,0x02}, {0x035,0x02}, {0x036,0x02}, {0x037,0x02}, {0x038,0x02}, 
        {0x039,0x02}, {0x03A,0x02}, {0x03B,0x02}, {0x03C,0x02}, {0x03D,0x02}, {0x03E,0x02}, {0x03F,0x02}, {0x040,0x3C}, 
        {0x041,0x28}, {0x042,0x00}, {0x043,0x38}, {0x044,0x48}, {0x045,0x44}, {0x046,0x14}, {0x047,0x0C}, {0x048,0x08}, 
        {0x049,0x0D}, {0x04A,0x0B}, {0x04B,0x3F}, {0x04C,0x00}, {0x04D,0x09}, {0x04E,0x14}, {0x04F,0x32}, {0x050,0x02}, 
        {0x051,0x33}, {0x052,0x48}, {0x053,0x1E}, {0x054,0x12}, {0x057,0x3D}, {0x058,0x04}, {0x059,0x96}, {0x05A,0x2A}, 
        {0x05B,0xC3}, {0x05C,0x80}, {0x05D,0x19}, {0x060,0x0C}, {0x061,0x0F}, {0x062,0x90}, {0x063,0x04}, {0x064,0x14}, 
        {0x065,0x5C}, {0x066,0x3C}, {0x067,0xB0}, {0x068,0x14}, {0x069,0x1C}, {0x070,0x84}, {0x071,0x00}, {0x072,0x22}, 
        {0x073,0xA2}, {0x074,0x80}, {0x078,0x84}, {0x079,0x5C}, {0x07A,0x10}, {0x080,0x04}, {0x081,0x00}, {0x082,0x00}, 
        {0x083,0x00}, {0x084,0x15}, {0x085,0x1F}, {0x086,0x15}, {0x087,0x1F}, {0x090,0x82}, {0x091,0x00}, {0x092,0x00}, 
        {0x093,0x00}, {0x094,0x00}, {0x095,0x00}, {0x096,0x00}, {0x097,0x00}, {0x098,0x00}, {0x0A0,0x42}, {0x0A1,0x23}, 
        {0x0A2,0x22}, {0x0A3,0x1A}, {0x0A4,0x16}, {0x0A5,0x32}, {0x0A6,0x20}, {0x0A7,0x25}, {0x0A8,0x28}, {0x0A9,0x0A}, 
        {0x0AA,0x1C}, {0x0AB,0x0A}, {0x0AC,0x3F}, {0x0AD,0x00}, {0x0AE,0x08}, {0x0AF,0x0C}, {0x0B0,0x07}, {0x0B1,0x1F}, 
        {0x0B2,0x5A}, {0x0B3,0x2D}, {0x0B5,0x20}, {0x0B6,0x66}, {0x0B8,0x10}, {0x0B9,0x35}, {0x0BA,0x11}, {0x0BB,0x05}, 
        {0x0BC,0x90}, {0x0C5,0x10}, {0x0C6,0xF0}, {0x0C7,0xFF}, {0x0C8,0xFF}, {0x0C9,0xFF}, {0x0CA,0xFF}, {0x0CB,0xFF}, 
        {0x0CC,0xFF}, {0x0CD,0x1E}, {0x0CE,0x00}, {0x0D0,0x00}, {0x0D1,0xFF}, {0x0D2,0x18}, {0x0D3,0x08}, {0x0D4,0x08}, 
        {0x0D5,0x08}, {0x0D6,0x04}, {0x0D7,0x01}, {0x0D8,0x68}, {0x0D9,0x33}, {0x0DA,0x33}, {0x0DB,0x64}, {0x0DC,0x0F}, 
        {0x0DD,0x18}, {0x0DE,0xF1}, {0x0DF,0x0F}, {0x0E0,0x1E}, {0x0E1,0x0B}, {0x0E2,0x07}, {0x0E3,0x2B}, {0x0E4,0xA5}, 
        {0x0E5,0x3C}, {0x0E6,0x03}, {0x0E7,0x00}, {0x0E8,0x16}, {0x0E9,0x06}, {0x0EA,0x03}, {0x0EB,0x80}, {0x0EC,0x80}, 
        {0x0ED,0x85}, {0x102,0x03}, {0x103,0x00}, {0x104,0x62}, {0x105,0x00}, {0x10A,0x00}, {0x10B,0x00}, {0x10C,0x32}, 
        {0x10D,0x00}, {0x10E,0x00}, {0x10F,0x40}, {0x110,0x4B}, {0x111,0x55}, {0x112,0x07}, {0x113,0x09}, {0x114,0x00}, 
        {0x115,0x00}, {0x116,0x00}, {0x117,0x4D}, {0x118,0x20}, {0x119,0x18}, {0x11A,0x00}, {0x11B,0x00}, {0x11C,0xEF}, 
        {0x11D,0x6F}, {0x11E,0x30}, {0x11F,0x00}, {0x120,0xA9}, {0x121,0x13}, {0x122,0x00}, {0x123,0xD0}, {0x124,0x24}, 
        {0x125,0xCB}, {0x126,0x00}, {0x127,0x00}, {0x128,0x88}, {0x12F,0x00}, {0x130,0x00}, {0x131,0x00}, {0x132,0xFF}, 
        {0x133,0x00}, {0x134,0x1E}, {0x135,0x0A}, {0x136,0x00}, {0x137,0x21}, {0x138,0x00}, {0x139,0x00}, {0x13A,0xF5}, 
        {0x13B,0x40}, {0x13C,0x05}, {0x13D,0xFB}, {0x13E,0x03}, {0x13F,0x00}, {0x140,0x02}, {0x141,0xF0}, {0x142,0x50}, 
        {0x143,0xFF}, {0x144,0x10}, {0x145,0x00}, {0x146,0xC4}, {0x147,0xBC}, {0x148,0xFC}, {0x149,0x7E}, {0x14A,0x04}, 
        {0x14C,0xFF}, {0x14E,0x00}, {0x14F,0x28}, {0x150,0xB4}, {0x151,0x00}, {0x152,0x7F}, {0x153,0x00}, {0x154,0x00}, 
        {0x155,0x88}, {0x156,0x00}, {0x157,0x00}, {0x158,0x10}, {0x159,0x00}, {0x15A,0x3F}, {0x15B,0x00}, {0x15C,0x1B}, 
        {0x15D,0x1B}, {0x15E,0x88}, {0x15F,0x40}, {0x160,0x1B}, {0x161,0x40}, {0x162,0x00}, {0x163,0x90}, {0x164,0x8A}, 
        {0x165,0x00}, {0x166,0x00}, {0x167,0x25}, {0x168,0x78}, {0x169,0x5C}, {0x16A,0xB4}, {0x16B,0x04}, {0x16C,0xB4}, 
        {0x16D,0xA0}, {0x16E,0x24}, {0x16F,0x0C}, {0x170,0x7A}, {0x171,0x05}, {0x172,0x00}, {0x173,0xC0}, {0x174,0x00}, 
        {0x175,0x00}, {0x176,0x60}, {0x177,0x01}, {0x178,0x3C}, {0x179,0x3C}, {0x17A,0x0E}, {0x17B,0x00}, {0x17C,0x10}, 
        {0x17D,0x3C}
    }; // Generated 02-Oct-2007 14:50:21

    // Registers for Nadine:
    //   - Set (0x003) = 0x01 (PathSel = 0x01...receive only on path A)
    //   - Set (0x043) = 0x7F (AbsPwrH = 0x7F...prevent AGC from attempting to adjust radio gain)
    //   - Set (0x067) = 0x80 (disable LgSigDet...not sure about its state without a radio)
    static dwPhyRegPair_t DefaultReg_Mojave_Nadine[] = 
    {
        {0x003,0x01}, {0x004,0x03}, {0x006,0x23}, {0x007,0x00}, {0x008,0x12}, {0x009,0x00}, {0x00A,0x00}, {0x00B,0x00}, 
        {0x00C,0x00}, {0x00D,0x00}, {0x00E,0x7F}, {0x018,0x61}, {0x019,0x03}, {0x01E,0x43}, {0x01F,0x00}, {0x020,0x0C}, 
        {0x021,0x0C}, {0x022,0x0C}, {0x023,0x0C}, {0x024,0x0C}, {0x025,0x0C}, {0x026,0x0C}, {0x027,0x0C}, {0x028,0x0C}, 
        {0x029,0x0C}, {0x02A,0x0C}, {0x02B,0x0C}, {0x02C,0x0C}, {0x02D,0x0C}, {0x02E,0x0C}, {0x02F,0x0C}, {0x030,0x02}, 
        {0x031,0x02}, {0x032,0x02}, {0x033,0x02}, {0x034,0x02}, {0x035,0x02}, {0x036,0x02}, {0x037,0x02}, {0x038,0x02}, 
        {0x039,0x02}, {0x03A,0x02}, {0x03B,0x02}, {0x03C,0x02}, {0x03D,0x02}, {0x03E,0x02}, {0x03F,0x02}, {0x040,0x3C}, 
        {0x041,0x28}, {0x042,0x00}, {0x043,0x7F}, {0x044,0x48}, {0x045,0x44}, {0x046,0x14}, {0x047,0x0C}, {0x048,0x08}, 
        {0x049,0x0D}, {0x04A,0x0E}, {0x04B,0x3F}, {0x04C,0x00}, {0x04D,0x09}, {0x04E,0x14}, {0x04F,0x32}, {0x050,0x02}, 
        {0x051,0x33}, {0x052,0x48}, {0x053,0x1E}, {0x054,0x12}, {0x057,0x3D}, {0x058,0x04}, {0x059,0x96}, {0x05A,0x2A}, 
        {0x05B,0xC3}, {0x05C,0x80}, {0x05D,0x19}, {0x060,0x0C}, {0x061,0x0F}, {0x062,0x90}, {0x063,0x04}, {0x064,0x14}, 
        {0x065,0x5C}, {0x066,0x3C}, {0x067,0x80}, {0x068,0x14}, {0x069,0x1C}, {0x070,0x84}, {0x071,0x00}, {0x072,0x22}, 
        {0x073,0xA2}, {0x074,0x80}, {0x078,0x84}, {0x079,0x5C}, {0x07A,0x10}, {0x080,0x04}, {0x081,0x00}, {0x082,0x00}, 
        {0x083,0x00}, {0x084,0x15}, {0x085,0x1F}, {0x086,0x15}, {0x087,0x1F}, {0x090,0x82}, {0x091,0x00}, {0x092,0x00}, 
        {0x093,0x00}, {0x094,0x00}, {0x095,0x00}, {0x096,0x00}, {0x097,0x00}, {0x098,0x00}, {0x0A0,0x42}, {0x0A1,0x23}, 
        {0x0A2,0x1A}, {0x0A3,0x1A}, {0x0A4,0x16}, {0x0A5,0x32}, {0x0A6,0x20}, {0x0A7,0x25}, {0x0A8,0x28}, {0x0A9,0x0A}, 
        {0x0AA,0x1C}, {0x0AB,0x0E}, {0x0AC,0x3F}, {0x0AD,0x00}, {0x0AE,0x08}, {0x0AF,0x0C}, {0x0B0,0x07}, {0x0B1,0x1F}, 
        {0x0B2,0x5A}, {0x0B3,0x2D}, {0x0B5,0x20}, {0x0B6,0x66}, {0x0B8,0x10}, {0x0B9,0x35}, {0x0BA,0x11}, {0x0BB,0x05}, 
        {0x0BC,0x90}, {0x0C5,0x10}, {0x0C6,0xF0}, {0x0C7,0xFF}, {0x0C8,0xFF}, {0x0C9,0xFF}, {0x0CA,0xFF}, {0x0CB,0xFF}, 
        {0x0CC,0xFF}, {0x0CD,0x1E}, {0x0CE,0x00}, {0x0D0,0x00}, {0x0D1,0xFF}, {0x0D2,0x18}, {0x0D3,0x08}, {0x0D4,0x08}, 
        {0x0D5,0x08}, {0x0D6,0x04}, {0x0D7,0x02}, {0x0D8,0x68}, {0x0D9,0x33}, {0x0DA,0x43}, {0x0DB,0x64}, {0x0DC,0x0F},
        {0x0DD,0x18}, {0x0DE,0xF1}, {0x0DF,0x0F}, {0x0E0,0x1E}, {0x0E1,0x0B}, {0x0E2,0x07}, {0x0E3,0x2B}, {0x0E4,0xA5}, 
        {0x0E5,0x3C}, {0x0E6,0x03}, {0x0E7,0x00}, {0x0E8,0x16}, {0x0E9,0x06}, {0x0EA,0x03}, {0x0EB,0x80}, {0x0EC,0x80}, 
        {0x0ED,0x85}
    };

    static dwPhyRegPair_t DefaultReg_Mojave_RF52A321[] = 
    {
        {0x003,0x03}, {0x004,0x03}, {0x006,0x23}, {0x007,0x00}, {0x008,0x12}, {0x009,0x00}, {0x00A,0x00}, {0x00B,0x00}, 
        {0x00C,0x00}, {0x00D,0x00}, {0x00E,0x7F}, {0x018,0x61}, {0x019,0x03}, {0x01E,0x43}, {0x01F,0x00}, {0x020,0x0C}, 
        {0x021,0x0C}, {0x022,0x0C}, {0x023,0x0C}, {0x024,0x0C}, {0x025,0x0C}, {0x026,0x0C}, {0x027,0x0C}, {0x028,0x0C}, 
        {0x029,0x0C}, {0x02A,0x0C}, {0x02B,0x0C}, {0x02C,0x0C}, {0x02D,0x0C}, {0x02E,0x0C}, {0x02F,0x0C}, {0x030,0x17}, 
        {0x031,0x17}, {0x032,0x17}, {0x033,0x17}, {0x034,0x17}, {0x035,0x17}, {0x036,0x17}, {0x037,0x17}, {0x038,0x17}, 
        {0x039,0x17}, {0x03A,0x17}, {0x03B,0x17}, {0x03C,0x17}, {0x03D,0x17}, {0x03E,0x17}, {0x03F,0x17}, {0x040,0x3C}, 
        {0x041,0x21}, {0x042,0x00}, {0x043,0x38}, {0x044,0x48}, {0x045,0x44}, {0x046,0x14}, {0x047,0x0C}, {0x048,0x08}, 
        {0x049,0x12}, {0x04A,0x14}, {0x04B,0x3F}, {0x04C,0x00}, {0x04D,0x09}, {0x04E,0x14}, {0x04F,0x32}, {0x050,0x02}, 
        {0x051,0x33}, {0x052,0x48}, {0x053,0x1E}, {0x054,0x12}, {0x057,0x3D}, {0x058,0x04}, {0x059,0x96}, {0x05A,0x2A}, 
        {0x05B,0xC3}, {0x05C,0x80}, {0x05D,0x19}, {0x060,0x0C}, {0x061,0x0F}, {0x062,0x90}, {0x063,0x04}, {0x064,0x14}, 
        {0x065,0x5C}, {0x066,0x3C}, {0x067,0xB0}, {0x068,0x14}, {0x069,0x1C}, {0x070,0x84}, {0x071,0x00}, {0x072,0x22}, 
        {0x073,0x82}, {0x074,0x80}, {0x078,0x84}, {0x079,0x5C}, {0x07A,0x10}, {0x080,0x04}, {0x081,0x00}, {0x082,0x00}, 
        {0x083,0x00}, {0x084,0x15}, {0x085,0x1F}, {0x086,0x15}, {0x087,0x1F}, {0x090,0x82}, {0x091,0x00}, {0x092,0x00}, 
        {0x093,0x00}, {0x094,0x00}, {0x095,0x00}, {0x096,0x00}, {0x097,0x00}, {0x098,0x00}, {0x0A0,0x8F}, {0x0A1,0x23}, 
        {0x0A2,0x22}, {0x0A3,0x1A}, {0x0A4,0x16}, {0x0A5,0x32}, {0x0A6,0x20}, {0x0A7,0x25}, {0x0A8,0x28}, {0x0A9,0x0A}, 
        {0x0AA,0x1C}, {0x0AB,0x0A}, {0x0AC,0x3F}, {0x0AD,0x00}, {0x0AE,0x08}, {0x0AF,0x0C}, {0x0B0,0x07}, {0x0B1,0x1F}, 
        {0x0B2,0x5A}, {0x0B3,0x2D}, {0x0B5,0x20}, {0x0B6,0x66}, {0x0B8,0x10}, {0x0B9,0x35}, {0x0BA,0x11}, {0x0BB,0x05}, 
        {0x0BC,0x90}, {0x0C5,0x10}, {0x0C6,0xF0}, {0x0C7,0xFF}, {0x0C8,0xFF}, {0x0C9,0xFF}, {0x0CA,0xFF}, {0x0CB,0xFF}, 
        {0x0CC,0xFF}, {0x0CD,0x1E}, {0x0CE,0x00}, {0x0D0,0x00}, {0x0D1,0xFF}, {0x0D2,0x1C}, {0x0D3,0x0C}, {0x0D4,0x0C}, 
        {0x0D5,0x0C}, {0x0D6,0x07}, {0x0D7,0x07}, {0x0D8,0xBC}, {0x0D9,0x83}, {0x0DA,0x83}, {0x0DB,0x64}, {0x0DC,0x0F}, 
        {0x0DD,0x18}, {0x0DE,0xF1}, {0x0DF,0x0F}, {0x0E0,0x1E}, {0x0E1,0x0B}, {0x0E2,0x07}, {0x0E3,0x2B}, {0x0E4,0xA5}, 
        {0x0E5,0x3C}, {0x0E6,0x03}, {0x0E7,0xC0}, {0x0E8,0x16}, {0x0E9,0x06}, {0x0EA,0x03}, {0x0EB,0x80}, {0x0EC,0x80}, 
        {0x0ED,0x85}, {0x102,0x03}, {0x103,0x00}, {0x104,0x00}, {0x105,0x00}, {0x10A,0x00}, {0x10B,0x00}, {0x10C,0x32}, 
        {0x10D,0x00}, {0x10E,0x00}, {0x10F,0x40}, {0x110,0x4B}, {0x111,0x55}, {0x112,0x07}, {0x113,0x09}, {0x114,0x00}, 
        {0x115,0x00}, {0x116,0x00}, {0x117,0x4D}, {0x118,0x20}, {0x119,0x16}, {0x11A,0x09}, {0x11B,0x00}, {0x11C,0x6F}, 
        {0x11D,0x7F}, {0x11E,0x50}, {0x11F,0x00}, {0x120,0xA9}, {0x121,0x13}, {0x122,0x00}, {0x123,0xD0}, {0x124,0x24}, 
        {0x125,0xCB}, {0x126,0x00}, {0x127,0x1C}, {0x128,0x88}, {0x12F,0x00}, {0x130,0x00}, {0x131,0x00}, {0x132,0xFF}, 
        {0x133,0x00}, {0x134,0x1E}, {0x135,0x0A}, {0x136,0x00}, {0x137,0x24}, {0x138,0x00}, {0x139,0x30}, {0x13A,0x95}, 
        {0x13B,0x40}, {0x13C,0x5F}, {0x13D,0xAB}, {0x13E,0x02}, {0x13F,0x00}, {0x140,0x38}, {0x141,0x40}, {0x142,0xD0}, 
        {0x143,0xFF}, {0x144,0x10}, {0x145,0x00}, {0x146,0xC4}, {0x147,0xBC}, {0x148,0xFC}, {0x149,0x7E}, {0x14A,0x04}, 
        {0x14C,0xFF}, {0x14E,0x00}, {0x14F,0x28}, {0x150,0xB4}, {0x151,0x00}, {0x152,0x7F}, {0x153,0x10}, {0x154,0x00}, 
        {0x155,0x08}, {0x156,0x00}, {0x157,0x00}, {0x158,0x10}, {0x159,0x00}, {0x15A,0x3F}, {0x15B,0x00}, {0x15C,0x1B}, 
        {0x15D,0x1B}, {0x15E,0x88}, {0x15F,0x41}, {0x160,0x1A}, {0x161,0x50}, {0x162,0x00}, {0x163,0x91}, {0x164,0x8A}, 
        {0x165,0x00}, {0x166,0x00}, {0x167,0x25}, {0x168,0x78}, {0x169,0x5C}, {0x16A,0xB4}, {0x16B,0x04}, {0x16C,0xB4}, 
        {0x16D,0xA0}, {0x16E,0x24}, {0x16F,0x0C}, {0x170,0x7A}, {0x171,0x05}, {0x172,0x00}, {0x173,0xC0}, {0x174,0x00}, 
        {0x175,0x00}, {0x176,0x60}, {0x177,0x01}, {0x178,0x3C}, {0x179,0x3C}, {0x17A,0x0E}, {0x17B,0x00}, {0x17C,0x10}, 
        {0x17D,0x3C}
    }; // Generated 26-May-2008 07:02:29

    // Manual edits: Reg0x14C = 0x73 PCOUNTDEF = 115 (was 110) to compensate change in IFOFFSET
    //               Reg0x154 = 0x34 DACOFFSET = 52 (was 42) to provide a more conservative default output power
    static dwPhyRegPair_t DefaultReg_Mojave_RF52B21[] = 
    {
        {0x003,0x03}, {0x004,0x03}, {0x006,0x23}, {0x007,0x00}, {0x008,0x12}, {0x009,0x00}, {0x00A,0x00}, {0x00B,0x00}, 
        {0x00C,0x00}, {0x00D,0x00}, {0x00E,0x7F}, {0x018,0x61}, {0x019,0x03}, {0x01E,0x43}, {0x01F,0x00}, {0x020,0x0C}, 
        {0x021,0x0C}, {0x022,0x0C}, {0x023,0x0C}, {0x024,0x0C}, {0x025,0x0C}, {0x026,0x0C}, {0x027,0x0C}, {0x028,0x0C}, 
        {0x029,0x0C}, {0x02A,0x0C}, {0x02B,0x0C}, {0x02C,0x0C}, {0x02D,0x0C}, {0x02E,0x0C}, {0x02F,0x0C}, {0x030,0x17}, 
        {0x031,0x17}, {0x032,0x17}, {0x033,0x17}, {0x034,0x17}, {0x035,0x17}, {0x036,0x17}, {0x037,0x17}, {0x038,0x17}, 
        {0x039,0x17}, {0x03A,0x17}, {0x03B,0x17}, {0x03C,0x17}, {0x03D,0x17}, {0x03E,0x17}, {0x03F,0x17}, {0x040,0x3C}, 
        {0x041,0x24}, {0x042,0x00}, {0x043,0x38}, {0x044,0x48}, {0x045,0x42}, {0x046,0x14}, {0x047,0x0C}, {0x048,0x08}, 
        {0x049,0x12}, {0x04A,0x0C}, {0x04B,0x3F}, {0x04C,0x00}, {0x04D,0x0A}, {0x04E,0x14}, {0x04F,0x2F}, {0x050,0x02}, 
        {0x051,0x2C}, {0x052,0x68}, {0x053,0x1E}, {0x054,0x12}, {0x057,0x3D}, {0x058,0x04}, {0x059,0x96}, {0x05A,0x2A}, 
        {0x05B,0xC3}, {0x05C,0x80}, {0x05D,0x19}, {0x060,0x10}, {0x061,0x0F}, {0x062,0x90}, {0x063,0x04}, {0x064,0x14}, 
        {0x065,0x5C}, {0x066,0x3C}, {0x067,0xB0}, {0x068,0x14}, {0x069,0x1C}, {0x070,0x84}, {0x071,0x00}, {0x072,0x22}, 
        {0x073,0x82}, {0x074,0x80}, {0x078,0x84}, {0x079,0x5C}, {0x07A,0x10}, {0x080,0x04}, {0x081,0x00}, {0x082,0x00}, 
        {0x083,0x00}, {0x084,0x15}, {0x085,0x1F}, {0x086,0x15}, {0x087,0x1F}, {0x090,0x82}, {0x091,0x00}, {0x092,0x00}, 
        {0x093,0x00}, {0x094,0x00}, {0x095,0x00}, {0x096,0x00}, {0x097,0x00}, {0x098,0x00}, {0x0A0,0x8F}, {0x0A1,0x23}, 
        {0x0A2,0x22}, {0x0A3,0x1A}, {0x0A4,0x16}, {0x0A5,0x32}, {0x0A6,0x20}, {0x0A7,0x25}, {0x0A8,0x28}, {0x0A9,0x0A}, 
        {0x0AA,0x1C}, {0x0AB,0x0A}, {0x0AC,0x3F}, {0x0AD,0x00}, {0x0AE,0x08}, {0x0AF,0x0F}, {0x0B0,0x02}, {0x0B1,0x1F}, 
        {0x0B2,0x5A}, {0x0B3,0x2D}, {0x0B5,0x20}, {0x0B6,0x66}, {0x0B8,0x10}, {0x0B9,0x35}, {0x0BA,0x11}, {0x0BB,0x05}, 
        {0x0BC,0x90}, {0x0C5,0x10}, {0x0C6,0xF0}, {0x0C7,0xFF}, {0x0C8,0xFF}, {0x0C9,0xFF}, {0x0CA,0xFF}, {0x0CB,0xFF}, 
        {0x0CC,0xFF}, {0x0CD,0x1E}, {0x0CE,0xB0}, {0x0D0,0x01}, {0x0D1,0x7C}, {0x0D2,0x50}, {0x0D3,0x0C}, {0x0D4,0x0C}, 
        {0x0D5,0x0C}, {0x0D6,0x07}, {0x0D7,0x07}, {0x0D8,0xBC}, {0x0D9,0x85}, {0x0DA,0x83}, {0x0DB,0x64}, {0x0DC,0x0F}, 
        {0x0DD,0x18}, {0x0DE,0xF1}, {0x0DF,0x0F}, {0x0E0,0x1E}, {0x0E1,0x0B}, {0x0E2,0x07}, {0x0E3,0x2B}, {0x0E4,0xA5}, 
        {0x0E5,0x3C}, {0x0E6,0x03}, {0x0E7,0xC0}, {0x0E8,0x16}, {0x0E9,0x06}, {0x0EA,0x03}, {0x0EB,0x80}, {0x0EC,0x80}, 
        {0x0ED,0x85}, {0x102,0x03}, {0x103,0x00}, {0x104,0x00}, {0x105,0x00}, {0x109,0x00}, {0x10A,0x0C}, {0x10B,0x00}, 
        {0x10C,0x32}, {0x10D,0x00}, {0x10E,0x00}, {0x10F,0x40}, {0x110,0x4B}, {0x111,0x55}, {0x112,0x07}, {0x113,0x09}, 
        {0x114,0x46}, {0x115,0xCC}, {0x116,0x0B}, {0x117,0x4D}, {0x118,0x14}, {0x119,0x16}, {0x11A,0x08}, {0x11B,0x00}, 
        {0x11C,0x6B}, {0x11D,0x7F}, {0x11E,0x50}, {0x11F,0x00}, {0x120,0xA9}, {0x121,0x13}, {0x122,0x00}, {0x123,0xD0}, 
        {0x124,0x74}, {0x125,0xC3}, {0x126,0x32}, {0x127,0x01}, {0x128,0x88}, {0x12F,0x00}, {0x130,0x00}, {0x131,0x00}, 
        {0x132,0xFF}, {0x133,0x00}, {0x134,0x1E}, {0x135,0x8C}, {0x136,0x50}, {0x137,0x00}, {0x138,0x62}, {0x139,0x12}, 
        {0x13A,0x4F}, {0x13B,0x29}, {0x13C,0x29}, {0x13D,0x45}, {0x13E,0xA2}, {0x13F,0x80}, {0x140,0x48}, {0x141,0x40}, 
        {0x142,0x20}, {0x143,0xEA}, {0x144,0x00}, {0x145,0x24}, {0x146,0xC4}, {0x147,0xBC}, {0x148,0x7E}, {0x149,0x3F}, 
        {0x14A,0x01}, {0x14C,0x73}, {0x14E,0x02}, {0x14F,0x30}, {0x150,0xCC}, {0x151,0x50}, {0x152,0x7F}, {0x153,0x1D}, 
        {0x154,0x34}, {0x155,0x60}, {0x156,0x30}, {0x157,0x79}, {0x158,0x3A}, {0x159,0x00}, {0x15A,0x3F}, {0x15B,0x03}, 
        {0x15C,0x52}, {0x15D,0x08}, {0x15E,0x8C}, {0x15F,0xC0}, {0x160,0x12}, {0x161,0x08}, {0x162,0x00}, {0x163,0x90}, 
        {0x164,0xB0}, {0x165,0x00}, {0x166,0x00}, {0x167,0x25}, {0x168,0x78}, {0x169,0x5C}, {0x16A,0xB4}, {0x16B,0x04}, 
        {0x16C,0xB0}, {0x16D,0xB4}, {0x16E,0x24}, {0x16F,0x0C}, {0x170,0xC8}, {0x171,0x1D}, {0x172,0x00}, {0x173,0xC0}, 
        {0x174,0x00}, {0x175,0x40}, {0x176,0x60}, {0x177,0x01}, {0x178,0x3C}, {0x179,0x3C}, {0x17A,0x0E}, {0x17B,0xC0}, 
        {0x17C,0x10}, {0x17D,0x3C}
    }; // Generated 05-Mar-2009 17:38:11

    // Manual edits: Reg0x0EA = 0x02 DAC_IFS   =   2 (was   3) to reduce TX distortion
    //               Reg0x126 = 0x28 REFOSCTUNE=  40 (was  81) to reduce CFO on Sandy D
    //               Reg0x14C = 0x73 PCOUNTDEF = 115 (was 110) for faster ALC convergence at room temperature
    //               Reg0x154 = 0x30 DACOFFSET =  48 (was  42) to provide a more conservative default output power
    //               Reg0x158 = 0x36 IFOFFSET  =  54 (was  50) to compensate reduction in input signal level (DAC_IFS)
    static dwPhyRegPair_t DefaultReg_Mojave_RF52B31[] = 
    {
        {0x003,0x03}, {0x004,0x03}, {0x006,0x23}, {0x007,0x00}, {0x008,0x12}, {0x009,0x00}, {0x00A,0x00}, {0x00B,0x00}, 
        {0x00C,0x00}, {0x00D,0x00}, {0x00E,0x7F}, {0x018,0x61}, {0x019,0x03}, {0x01E,0x43}, {0x01F,0x00}, {0x020,0x0C}, 
        {0x021,0x0C}, {0x022,0x0C}, {0x023,0x0C}, {0x024,0x0C}, {0x025,0x0C}, {0x026,0x0C}, {0x027,0x0C}, {0x028,0x0C}, 
        {0x029,0x0C}, {0x02A,0x0C}, {0x02B,0x0C}, {0x02C,0x0C}, {0x02D,0x0C}, {0x02E,0x0C}, {0x02F,0x0C}, {0x030,0x17}, 
        {0x031,0x17}, {0x032,0x17}, {0x033,0x17}, {0x034,0x17}, {0x035,0x17}, {0x036,0x17}, {0x037,0x17}, {0x038,0x17}, 
        {0x039,0x17}, {0x03A,0x17}, {0x03B,0x17}, {0x03C,0x17}, {0x03D,0x17}, {0x03E,0x17}, {0x03F,0x17}, {0x040,0x3C}, 
        {0x041,0x24}, {0x042,0x00}, {0x043,0x38}, {0x044,0x48}, {0x045,0x42}, {0x046,0x14}, {0x047,0x0C}, {0x048,0x08}, 
        {0x049,0x12}, {0x04A,0x0C}, {0x04B,0x3F}, {0x04C,0x00}, {0x04D,0x0A}, {0x04E,0x14}, {0x04F,0x2F}, {0x050,0x02}, 
        {0x051,0x2C}, {0x052,0x68}, {0x053,0x1E}, {0x054,0x12}, {0x057,0x3D}, {0x058,0x04}, {0x059,0x96}, {0x05A,0x2A}, 
        {0x05B,0xC3}, {0x05C,0x80}, {0x05D,0x19}, {0x060,0x10}, {0x061,0x0F}, {0x062,0x90}, {0x063,0x04}, {0x064,0x14}, 
        {0x065,0x5C}, {0x066,0x3C}, {0x067,0xB0}, {0x068,0x14}, {0x069,0x1C}, {0x070,0x84}, {0x071,0x00}, {0x072,0x22}, 
        {0x073,0x82}, {0x074,0x80}, {0x078,0x84}, {0x079,0x5C}, {0x07A,0x10}, {0x080,0x04}, {0x081,0x00}, {0x082,0x00}, 
        {0x083,0x00}, {0x084,0x15}, {0x085,0x1F}, {0x086,0x15}, {0x087,0x1F}, {0x090,0x82}, {0x091,0x00}, {0x092,0x00}, 
        {0x093,0x00}, {0x094,0x00}, {0x095,0x00}, {0x096,0x00}, {0x097,0x00}, {0x098,0x00}, {0x0A0,0x8F}, {0x0A1,0x23}, 
        {0x0A2,0x22}, {0x0A3,0x1A}, {0x0A4,0x16}, {0x0A5,0x32}, {0x0A6,0x20}, {0x0A7,0x25}, {0x0A8,0x28}, {0x0A9,0x0A}, 
        {0x0AA,0x1C}, {0x0AB,0x0A}, {0x0AC,0x3F}, {0x0AD,0x00}, {0x0AE,0x08}, {0x0AF,0x0F}, {0x0B0,0x02}, {0x0B1,0x1F}, 
        {0x0B2,0x5A}, {0x0B3,0x2D}, {0x0B5,0x20}, {0x0B6,0x66}, {0x0B8,0x10}, {0x0B9,0x35}, {0x0BA,0x11}, {0x0BB,0x05}, 
        {0x0BC,0x90}, {0x0C5,0x10}, {0x0C6,0xF0}, {0x0C7,0xFF}, {0x0C8,0xFF}, {0x0C9,0xFF}, {0x0CA,0xFF}, {0x0CB,0xFF}, 
        {0x0CC,0xFF}, {0x0CD,0x1E}, {0x0CE,0xB0}, {0x0D0,0x01}, {0x0D1,0x7C}, {0x0D2,0x50}, {0x0D3,0x0C}, {0x0D4,0x0C}, 
        {0x0D5,0x0C}, {0x0D6,0x07}, {0x0D7,0x07}, {0x0D8,0xBC}, {0x0D9,0x80}, {0x0DA,0x83}, {0x0DB,0x64}, {0x0DC,0x0F}, 
        {0x0DD,0x18}, {0x0DE,0xF1}, {0x0DF,0x0F}, {0x0E0,0x1E}, {0x0E1,0x0B}, {0x0E2,0x07}, {0x0E3,0x2B}, {0x0E4,0xA5}, 
        {0x0E5,0x3C}, {0x0E6,0x03}, {0x0E7,0xC0}, {0x0E8,0x16}, {0x0E9,0x06}, {0x0EA,0x02}, {0x0EB,0x80}, {0x0EC,0x80}, 
        {0x0ED,0x85}, {0x102,0x03}, {0x103,0x00}, {0x104,0x00}, {0x105,0x00}, {0x109,0x00}, {0x10A,0x0C}, {0x10B,0x00}, 
        {0x10C,0x38}, {0x10D,0x00}, {0x10E,0x00}, {0x10F,0x40}, {0x110,0x4B}, {0x111,0x55}, {0x112,0x07}, {0x113,0x09}, 
        {0x114,0x88}, {0x115,0x88}, {0x116,0x3B}, {0x117,0x4D}, {0x118,0x14}, {0x119,0x1A}, {0x11A,0x08}, {0x11B,0x00}, 
        {0x11C,0x5A}, {0x11D,0x5F}, {0x11E,0x60}, {0x11F,0x01}, {0x120,0xA9}, {0x121,0x13}, {0x122,0x00}, {0x123,0xD0}, 
        {0x124,0x74}, {0x125,0x63}, {0x126,0x28}, {0x127,0x00}, {0x128,0x88}, {0x12F,0x00}, {0x130,0x00}, {0x131,0x00}, 
        {0x132,0xFF}, {0x133,0x00}, {0x134,0x3E}, {0x135,0x8C}, {0x136,0x50}, {0x137,0x00}, {0x138,0x62}, {0x139,0x14}, 
        {0x13A,0x4F}, {0x13B,0x29}, {0x13C,0x29}, {0x13D,0x45}, {0x13E,0xA2}, {0x13F,0xAB}, {0x140,0x36}, {0x141,0x40}, 
        {0x142,0x50}, {0x143,0xEA}, {0x144,0x00}, {0x145,0x24}, {0x146,0xC4}, {0x147,0xBC}, {0x148,0xFE}, {0x149,0x3F}, 
        {0x14A,0x01}, {0x14C,0x73}, {0x14E,0x3C}, {0x14F,0x14}, {0x150,0xCC}, {0x151,0x50}, {0x152,0x7F}, {0x153,0xFD}, 
        {0x154,0x30}, {0x155,0x60}, {0x156,0x30}, {0x157,0x79}, {0x158,0x36}, {0x159,0x00}, {0x15A,0x3F}, {0x15B,0x03}, 
        {0x15C,0x52}, {0x15D,0x06}, {0x15E,0x8C}, {0x15F,0xC0}, {0x160,0x12}, {0x161,0x08}, {0x162,0x00}, {0x163,0x90}, 
        {0x164,0xB0}, {0x165,0x00}, {0x166,0x00}, {0x167,0x25}, {0x168,0x78}, {0x169,0x5C}, {0x16A,0xB4}, {0x16B,0x04}, 
        {0x16C,0xB0}, {0x16D,0xB4}, {0x16E,0x24}, {0x16F,0x0C}, {0x170,0xC8}, {0x171,0x1D}, {0x172,0x00}, {0x173,0xC0}, 
        {0x174,0x00}, {0x175,0x40}, {0x176,0x60}, {0x177,0x01}, {0x178,0x3C}, {0x179,0x3C}, {0x17A,0x0E}, {0x17B,0xC0}, 
        {0x17C,0x10}, {0x17D,0x3C}
    }; // Generated 10-Apr-2009 13:43:41

    // Manual edits: Reg0x0003 = 0x02 PathSel = 2 (was  3)
    //               Reg0x0041 = 0x23 InitAGain = 35 (was 36)
    //               Reg0x00E3 = 0x07 ADCBOPM = 7 (was 43)
    //               Reg0x00E4 = 0xF0 (was A5)
    //               Reg0x0113 = 0x00 LCKDETRST/LCKDETDIS = 0 (was  3)
    //               Reg0x805B = 0x14 MAPD_MAX_PWR = 20 (was  50)
    //         Note: Power-control registers are edited to have nominal values.              
    static dwPhyRegPair_t DefaultReg_Mojave_RF22A02[] = 
    {
        {0x0003,0x02}, {0x0004,0x03}, {0x0006,0x23}, {0x0007,0x00}, {0x0008,0x12}, {0x0009,0x00}, {0x000A,0x00}, {0x000B,0x00}, 
        {0x000C,0x00}, {0x000D,0x00}, {0x000E,0x7F}, {0x0018,0x61}, {0x0019,0x03}, {0x001E,0x43}, {0x001F,0x00}, {0x0020,0x0C}, 
        {0x0021,0x0C}, {0x0022,0x0C}, {0x0023,0x0C}, {0x0024,0x0C}, {0x0025,0x0C}, {0x0026,0x0C}, {0x0027,0x0C}, {0x0028,0x0C}, 
        {0x0029,0x0C}, {0x002A,0x0C}, {0x002B,0x0C}, {0x002C,0x0C}, {0x002D,0x0C}, {0x002E,0x0C}, {0x002F,0x0C}, {0x0030,0x17}, 
        {0x0031,0x17}, {0x0032,0x17}, {0x0033,0x17}, {0x0034,0x17}, {0x0035,0x17}, {0x0036,0x17}, {0x0037,0x17}, {0x0038,0x17}, 
        {0x0039,0x17}, {0x003A,0x17}, {0x003B,0x17}, {0x003C,0x17}, {0x003D,0x17}, {0x003E,0x17}, {0x003F,0x17}, {0x0040,0x3C}, 
        {0x0041,0x23}, {0x0042,0x00}, {0x0043,0x38}, {0x0044,0x48}, {0x0045,0x42}, {0x0046,0x14}, {0x0047,0x0C}, {0x0048,0x08}, 
        {0x0049,0x12}, {0x004A,0x0C}, {0x004B,0x3F}, {0x004C,0x00}, {0x004D,0x0A}, {0x004E,0x14}, {0x004F,0x2F}, {0x0050,0x02}, 
        {0x0051,0x2C}, {0x0052,0x68}, {0x0053,0x1E}, {0x0054,0x12}, {0x0057,0x3D}, {0x0058,0x04}, {0x0059,0x96}, {0x005A,0x2A}, 
        {0x005B,0xC3}, {0x005C,0x80}, {0x005D,0x19}, {0x0060,0x10}, {0x0061,0x0F}, {0x0062,0x90}, {0x0063,0x04}, {0x0064,0x14}, 
        {0x0065,0x5C}, {0x0066,0x3C}, {0x0067,0xB0}, {0x0068,0x14}, {0x0069,0x1C}, {0x0070,0x84}, {0x0071,0x00}, {0x0072,0x22}, 
        {0x0073,0x82}, {0x0074,0x80}, {0x0078,0x84}, {0x0079,0x5C}, {0x007A,0x10}, {0x0080,0x04}, {0x0081,0x00}, {0x0082,0x00}, 
        {0x0083,0x00}, {0x0084,0x15}, {0x0085,0x1F}, {0x0086,0x15}, {0x0087,0x1F}, {0x0090,0x82}, {0x0091,0x00}, {0x0092,0x00}, 
        {0x0093,0x00}, {0x0094,0x00}, {0x0095,0x00}, {0x0096,0x00}, {0x0097,0x00}, {0x0098,0x00}, {0x00A0,0x8F}, {0x00A1,0x23}, 
        {0x00A2,0x22}, {0x00A3,0x1A}, {0x00A4,0x16}, {0x00A5,0x32}, {0x00A6,0x20}, {0x00A7,0x25}, {0x00A8,0x28}, {0x00A9,0x0A}, 
        {0x00AA,0x1C}, {0x00AB,0x0A}, {0x00AC,0x3F}, {0x00AD,0x00}, {0x00AE,0x08}, {0x00AF,0x0F}, {0x00B0,0x02}, {0x00B1,0x1F}, 
        {0x00B2,0x5A}, {0x00B3,0x2D}, {0x00B5,0x20}, {0x00B6,0x66}, {0x00B8,0x10}, {0x00B9,0x35}, {0x00BA,0x11}, {0x00BB,0x05}, 
        {0x00BC,0x90}, {0x00C5,0x10}, {0x00C6,0xF0}, {0x00C7,0xFF}, {0x00C8,0xFF}, {0x00C9,0xFF}, {0x00CA,0xFF}, {0x00CB,0xFF}, 
        {0x00CC,0xFF}, {0x00CD,0x1E}, {0x00CE,0xB0}, {0x00D0,0x01}, {0x00D1,0x7C}, {0x00D2,0x50}, {0x00D3,0x0C}, {0x00D4,0x0C}, 
        {0x00D5,0x0C}, {0x00D6,0x07}, {0x00D7,0x07}, {0x00D8,0xBC}, {0x00D9,0x80}, {0x00DA,0x83}, {0x00DB,0x64}, {0x00DC,0x0F}, 
        {0x00DD,0x18}, {0x00DE,0xF1}, {0x00DF,0x0F}, {0x00E0,0x1E}, {0x00E1,0x0B}, {0x00E2,0x07}, {0x00E3,0x07}, {0x00E4,0xF0}, 
        {0x00E5,0x3C}, {0x00E6,0x03}, {0x00E7,0xC0}, {0x00E8,0x16}, {0x00E9,0x06}, {0x00EA,0x03}, {0x00EB,0x80}, {0x00EC,0x80}, 
        {0x00ED,0x85}, {0x0102,0x00}, {0x0103,0x00}, {0x0104,0x00}, {0x0105,0x02}, {0x010C,0x01}, {0x010D,0x00}, {0x010E,0x00}, 
        {0x010F,0x5A}, {0x0110,0x95}, {0x0111,0x00}, {0x0112,0x00}, {0x0113,0x00}, {0x0114,0x88}, {0x0115,0x80}, {0x0116,0x00}, 
        {0x0117,0x18}, {0x0118,0x23}, {0x0119,0x02}, {0x011A,0x03}, {0x011B,0x0F}, {0x011C,0x13}, {0x011D,0x00}, {0x011E,0x00}, 
        {0x011F,0x89}, {0x0120,0x07}, {0x0129,0x3F}, {0x012A,0x3F}, {0x012B,0x0D}, {0x012D,0x00}, {0x012E,0x00}, {0x012F,0x00}, 
        {0x0130,0x00}, {0x0131,0x00}, {0x0132,0x00}, {0x013C,0x00}, {0x013D,0xC0}, {0x013E,0x00}, {0x013F,0x00}, {0x0140,0x70}, 
        {0x0141,0x00}, {0x0142,0xF0}, {0x0143,0x00}, {0x0146,0x0C}, {0x0147,0x00}, {0x0148,0x00}, {0x0149,0x46}, {0x014A,0x44}, 
        {0x014B,0x00}, {0x014C,0x71}, {0x0150,0x00}, {0x0151,0x1F}, {0x0152,0x1F}, {0x0153,0x99}, {0x0154,0x11}, {0x0155,0x02}, 
        {0x0156,0x40}, {0x0159,0x00}, {0x015A,0x00}, {0x015B,0x0C}, {0x015C,0x00}, {0x015D,0x00}, {0x015E,0x0A}, {0x015F,0x00}, 
        {0x0160,0x90}, {0x0161,0x00}, {0x0164,0x00}, {0x0165,0x00}, {0x0166,0x00}, {0x0167,0x03}, {0x0168,0x24}, {0x0169,0xB2}, 
        {0x016A,0x00}, {0x016B,0x20}, {0x016C,0x13}, {0x016E,0x04}, {0x016F,0x01}, {0x0170,0x37}, {0x0171,0x1C}, {0x0172,0x0F}, 
        {0x0173,0xC0}, {0x0174,0x00}, {0x0175,0x80}, {0x0176,0x30}, {0x0177,0x01}, {0x0178,0x78}, {0x0179,0x3C}, {0x017A,0x00}, 
        {0x017B,0x64}, {0x017C,0x3C}, {0x017D,0x3F}, {0x8000,0x00}, {0x8001,0xFA}, {0x8002,0x00}, {0x8004,0x27}, {0x8005,0x27}, 
        {0x8006,0x00}, {0x8007,0x00}, {0x8008,0x00}, {0x8009,0x00}, {0x800F,0x28}, {0x8010,0x28}, {0x8011,0x14}, {0x8012,0x28}, 
        {0x8013,0x3B}, {0x8014,0x67}, {0x8015,0x00}, {0x8018,0x0A}, {0x8019,0x00}, {0x801A,0x44}, {0x801B,0x0C}, {0x801C,0x8E}, 
        {0x801D,0xA6}, {0x801E,0x09}, {0x801F,0x93}, {0x8020,0x61}, {0x8021,0x10}, {0x8022,0xC8}, {0x8023,0xC8}, {0x8024,0x50}, 
        {0x8025,0xC8}, {0x8026,0x32}, {0x8027,0x32}, {0x8028,0x32}, {0x8029,0x32}, {0x802C,0x00}, {0x802D,0x00}, {0x802E,0x22}, 
        {0x802F,0x80}, {0x8030,0x80}, {0x8031,0x66}, {0x8032,0x33}, {0x8033,0x36}, {0x8034,0x82}, {0x8035,0x30}, {0x8037,0x00}, 
        {0x8038,0x00}, {0x8039,0xD2}, {0x803A,0x4B}, {0x803B,0x06}, {0x803D,0x00}, {0x803E,0x30}, {0x803F,0x81}, {0x8040,0xA9}, 
        {0x8041,0x0B}, {0x8042,0x00}, {0x8043,0x01}, {0x8044,0x08}, {0x8045,0x14}, {0x8046,0x21}, {0x8047,0x26}, {0x8048,0x2E}, 
        {0x8049,0x44}, {0x804A,0x01}, {0x804B,0x52}, {0x804C,0x10}, {0x804D,0x24}, {0x804E,0x46}, {0x804F,0x41}, {0x8050,0x6B}, 
        {0x8051,0x89}, {0x8052,0xAB}, {0x8053,0x49}, {0x8054,0x97}, {0x8055,0x8D}, {0x8056,0xDC}, {0x8057,0xFF}, {0x8058,0xFF}, 
        {0x8059,0x0C}, {0x805A,0x00}, {0x805B,0x14}, {0x805C,0x9E}, {0x805D,0x00}, {0x805F,0x34}, {0x8060,0x00}, {0x8061,0x87},         
        {0x8062,0x6C}, {0x8063,0x2A}, {0x8064,0x00}, {0x8065,0x00}, {0x8066,0x00}, {0x8067,0x00}, {0x8068,0x00}, {0x8069,0x00}, 
        {0x806C,0xC3}, {0x806D,0x00}, {0x806E,0x00}, {0x806F,0x00}, {0x8070,0x3C}, {0x8073,0x3F}, {0x8074,0x0B}, {0x8075,0x40}, 
        {0x8076,0x0F}, {0x8077,0x40}, {0x8078,0x40}, {0x8079,0x04}, {0x807A,0x00}, {0x807B,0x1E}
    }; // Generated 02-Dec-2010 10:28:37

    // Manual edits: Reg0x0003 = 0x02 PathSel             =  2 (was   3)
    //               Reg0x0041 = 0x21 InitAGain           = 33 (was  36)
    //               Reg0x00E3 = 0x07 ADCBOPM             =  7 (was  43)
    //               Reg0x00E4 = 0x0F RFSW1                    (was xA5) to use ANT 2 for default RX/TX
    //               Reg0x00EA = 0x02 DAC_IFS             =  2 (was   3) to reduce TX distortion
    //               Reg0x0113 = 0x00 LCKDETRST/LCKDETDIS =  0 (was   1)
    //               Reg0x0115 = 0x41 REFOSCTUNE          = 65 (was  81)
    //               Reg0x016A = 0x81 TX_DCOC_EN          =  1 (was   0) to squelch pre-packet LO feed-through
    //               Reg0x0172 = 0x0F PGAGAINNOM/DCOC     =  3 (was   2) to increase PGA gain for better CCK-ACR
    //               Reg0x8038 = 0x04 DET_DIV_VOVR        =  1 (was   0)
    //               Reg0x805B = 0x20 MAPD_MAX_PWR        = 32 (was  46)
    //         Note: Power-control registers are edited to have nominal values.              
    static dwPhyRegPair_t DefaultReg_Mojave_RF22A12[] = 
    {
        {0x0003,0x02}, {0x0004,0x03}, {0x0006,0x23}, {0x0007,0x00}, {0x0008,0x12}, {0x0009,0x00}, {0x000A,0x00}, {0x000B,0x00}, 
        {0x000C,0x00}, {0x000D,0x00}, {0x000E,0x7F}, {0x0018,0x61}, {0x0019,0x03}, {0x001E,0x43}, {0x001F,0x00}, {0x0020,0x0C}, 
        {0x0021,0x0C}, {0x0022,0x0C}, {0x0023,0x0C}, {0x0024,0x0C}, {0x0025,0x0C}, {0x0026,0x0C}, {0x0027,0x0C}, {0x0028,0x0C}, 
        {0x0029,0x0C}, {0x002A,0x0C}, {0x002B,0x0C}, {0x002C,0x0C}, {0x002D,0x0C}, {0x002E,0x0C}, {0x002F,0x0C}, {0x0030,0x17}, 
        {0x0031,0x17}, {0x0032,0x17}, {0x0033,0x17}, {0x0034,0x17}, {0x0035,0x17}, {0x0036,0x17}, {0x0037,0x17}, {0x0038,0x17}, 
        {0x0039,0x17}, {0x003A,0x17}, {0x003B,0x17}, {0x003C,0x17}, {0x003D,0x17}, {0x003E,0x17}, {0x003F,0x17}, {0x0040,0x3C}, 
        {0x0041,0x21}, {0x0042,0x00}, {0x0043,0x38}, {0x0044,0x48}, {0x0045,0x42}, {0x0046,0x14}, {0x0047,0x0C}, {0x0048,0x08}, 
        {0x0049,0x12}, {0x004A,0x0C}, {0x004B,0x3F}, {0x004C,0x00}, {0x004D,0x0A}, {0x004E,0x14}, {0x004F,0x2F}, {0x0050,0x02}, 
        {0x0051,0x2C}, {0x0052,0x68}, {0x0053,0x1E}, {0x0054,0x12}, {0x0057,0x3D}, {0x0058,0x04}, {0x0059,0x96}, {0x005A,0x2A}, 
        {0x005B,0xC3}, {0x005C,0x80}, {0x005D,0x19}, {0x0060,0x10}, {0x0061,0x0F}, {0x0062,0x90}, {0x0063,0x04}, {0x0064,0x14}, 
        {0x0065,0x5C}, {0x0066,0x3C}, {0x0067,0xB0}, {0x0068,0x14}, {0x0069,0x1C}, {0x0070,0x84}, {0x0071,0x00}, {0x0072,0x22}, 
        {0x0073,0x82}, {0x0074,0x80}, {0x0078,0x84}, {0x0079,0x5C}, {0x007A,0x10}, {0x0080,0x04}, {0x0081,0x00}, {0x0082,0x00}, 
        {0x0083,0x00}, {0x0084,0x15}, {0x0085,0x1F}, {0x0086,0x15}, {0x0087,0x1F}, {0x0090,0x82}, {0x0091,0x00}, {0x0092,0x00}, 
        {0x0093,0x00}, {0x0094,0x00}, {0x0095,0x00}, {0x0096,0x00}, {0x0097,0x00}, {0x0098,0x00}, {0x00A0,0x8F}, {0x00A1,0x23}, 
        {0x00A2,0x22}, {0x00A3,0x1A}, {0x00A4,0x16}, {0x00A5,0x32}, {0x00A6,0x20}, {0x00A7,0x25}, {0x00A8,0x28}, {0x00A9,0x0A}, 
        {0x00AA,0x1C}, {0x00AB,0x0A}, {0x00AC,0x3F}, {0x00AD,0x00}, {0x00AE,0x08}, {0x00AF,0x0F}, {0x00B0,0x02}, {0x00B1,0x1F}, 
        {0x00B2,0x5A}, {0x00B3,0x2D}, {0x00B5,0x20}, {0x00B6,0x66}, {0x00B8,0x10}, {0x00B9,0x35}, {0x00BA,0x11}, {0x00BB,0x05}, 
        {0x00BC,0x90}, {0x00C5,0x10}, {0x00C6,0xF0}, {0x00C7,0xFF}, {0x00C8,0xFF}, {0x00C9,0xFF}, {0x00CA,0xFF}, {0x00CB,0xFF}, 
        {0x00CC,0xFF}, {0x00CD,0x1E}, {0x00CE,0xB0}, {0x00D0,0x01}, {0x00D1,0x7C}, {0x00D2,0x50}, {0x00D3,0x0C}, {0x00D4,0x0C}, 
        {0x00D5,0x0C}, {0x00D6,0x07}, {0x00D7,0x07}, {0x00D8,0xBC}, {0x00D9,0x80}, {0x00DA,0x83}, {0x00DB,0x64}, {0x00DC,0x0F}, 
        {0x00DD,0x18}, {0x00DE,0xF1}, {0x00DF,0x0F}, {0x00E0,0x1E}, {0x00E1,0x0B}, {0x00E2,0x07}, {0x00E3,0x07}, {0x00E4,0x0F}, 
        {0x00E5,0x3C}, {0x00E6,0x03}, {0x00E7,0xC0}, {0x00E8,0x16}, {0x00E9,0x06}, {0x00EA,0x02}, {0x00EB,0x80}, {0x00EC,0x80}, 
        {0x00ED,0x85}, {0x0102,0x00}, {0x0103,0x00}, {0x0104,0x00}, {0x0105,0x02}, {0x0106,0x00}, {0x0107,0x00}, {0x0108,0x40}, 
        {0x0109,0x00}, {0x010A,0x00}, {0x010B,0x00}, {0x010C,0x07}, {0x010D,0x00}, {0x010E,0x00}, {0x010F,0x5A}, {0x0110,0x95}, 
        {0x0111,0x00}, {0x0112,0x00}, {0x0113,0x00}, {0x0114,0x88}, {0x0115,0x41}, {0x0116,0x00}, {0x0117,0x18}, {0x0118,0x23}, 
        {0x0119,0x00}, {0x011A,0x03}, {0x011B,0x00}, {0x011C,0x13}, {0x011D,0x00}, {0x011E,0x00}, {0x011F,0xA1}, {0x0120,0x07}, 
        {0x0121,0xD9}, {0x0122,0x00}, {0x0123,0x00}, {0x0124,0x00}, {0x0125,0x00}, {0x0126,0x00}, {0x0127,0x00}, {0x0128,0x07}, 
        {0x0129,0x3F}, {0x012A,0x3F}, {0x012B,0x0D}, {0x012C,0x00}, {0x012D,0x00}, {0x012E,0x00}, {0x012F,0x03}, {0x0130,0x00}, 
        {0x0131,0x00}, {0x0132,0x03}, {0x0133,0x00}, {0x0134,0x00}, {0x0135,0x00}, {0x0136,0x00}, {0x0137,0x00}, {0x0138,0x00}, 
        {0x0139,0x00}, {0x013A,0x00}, {0x013B,0x00}, {0x013C,0x00}, {0x013D,0xC0}, {0x013E,0x00}, {0x013F,0x00}, {0x0140,0x70}, 
        {0x0141,0x00}, {0x0142,0xF0}, {0x0143,0x00}, {0x0144,0x00}, {0x0145,0x00}, {0x0146,0x0C}, {0x0147,0x00}, {0x0148,0x00}, 
        {0x0149,0x46}, {0x014A,0x44}, {0x014B,0x00}, {0x014C,0x71}, {0x014D,0x00}, {0x014E,0x00}, {0x014F,0x00}, {0x0150,0x00}, 
        {0x0151,0x1B}, {0x0152,0x11}, {0x0153,0x9D}, {0x0154,0x13}, {0x0155,0x02}, {0x0156,0x40}, {0x0157,0x00}, {0x0158,0x00}, 
        {0x0159,0x00}, {0x015A,0x00}, {0x015B,0x0C}, {0x015C,0x00}, {0x015D,0x00}, {0x015E,0x08}, {0x015F,0x00}, {0x0160,0x90}, 
        {0x0161,0x00}, {0x0162,0x00}, {0x0163,0x00}, {0x0164,0x00}, {0x0165,0x00}, {0x0166,0x00}, {0x0167,0x03}, {0x0168,0x24}, 
        {0x0169,0xB2}, {0x016A,0x81}, {0x016B,0x20}, {0x016C,0x13}, {0x016D,0x79}, {0x016E,0x04}, {0x016F,0x01}, {0x0170,0x37}, 
        {0x0171,0x1C}, {0x0172,0x0F}, {0x0173,0xC0}, {0x0174,0x00}, {0x0175,0x80}, {0x0176,0x30}, {0x0177,0x01}, {0x0178,0x78}, 
        {0x0179,0x3C}, {0x017A,0x00}, {0x017B,0x64}, {0x017C,0x3C}, {0x017D,0x3F}, {0x017E,0x6F}, {0x017F,0x29}, {0x8000,0x00}, 
        {0x8001,0xFA}, {0x8002,0x00}, {0x8003,0x3F}, {0x8004,0x27}, {0x8005,0x27}, {0x8006,0x00}, {0x8007,0x00}, {0x8008,0x00}, 
        {0x8009,0x00}, {0x800A,0x10}, {0x800B,0x13}, {0x800C,0x11}, {0x800D,0x11}, {0x800E,0x0F}, {0x800F,0x28}, {0x8010,0x28}, 
        {0x8011,0x14}, {0x8012,0x28}, {0x8013,0x3B}, {0x8014,0x67}, {0x8015,0x00}, {0x8016,0x06}, {0x8017,0x28}, {0x8018,0x0A}, 
        {0x8019,0x00}, {0x801A,0x82}, {0x801B,0x0A}, {0x801C,0x8E}, {0x801D,0xA6}, {0x801E,0x09}, {0x801F,0x93}, {0x8020,0x61}, 
        {0x8021,0x10}, {0x8022,0xC8}, {0x8023,0xC8}, {0x8024,0x50}, {0x8025,0xC8}, {0x8026,0x32}, {0x8027,0x32}, {0x8028,0x32}, 
        {0x8029,0x32}, {0x802A,0x01}, {0x802B,0x00}, {0x802C,0x00}, {0x802D,0x00}, {0x802E,0x22}, {0x802F,0x80}, {0x8030,0x80}, 
        {0x8031,0x66}, {0x8032,0x33}, {0x8033,0x36}, {0x8034,0x82}, {0x8035,0x30}, {0x8036,0x00}, {0x8037,0x00}, {0x8038,0x04}, 
        {0x8039,0xD2}, {0x803A,0x6E}, {0x803B,0x06}, {0x803C,0x00}, {0x803D,0x00}, {0x803E,0x1F}, {0x803F,0x51}, {0x8040,0x76}, 
        {0x8041,0x0B}, {0x8042,0x00}, {0x8043,0x01}, {0x8044,0x03}, {0x8045,0x0F}, {0x8046,0x1A}, {0x8047,0x28}, {0x8048,0x31}, 
        {0x8049,0x82}, {0x804A,0x01}, {0x804B,0xA2}, {0x804C,0x10}, {0x804D,0x2F}, {0x804E,0x5A}, {0x804F,0x50}, {0x8050,0x85}, 
        {0x8051,0xC4}, {0x8052,0xFF}, {0x8053,0x31}, {0x8054,0x65}, {0x8055,0x5F}, {0x8056,0xA5}, {0x8057,0xEC}, {0x8058,0xF7}, 
        {0x8059,0x0C}, {0x805A,0x00}, {0x805B,0x20}, {0x805C,0xC5}, {0x805D,0x00}, {0x805E,0x82}, {0x805F,0x14}, {0x8060,0x03}, 
        {0x8061,0x07}, {0x8062,0x6C}, {0x8063,0x2A}, {0x8064,0x00}, {0x8065,0x00}, {0x8066,0x00}, {0x8067,0x00}, {0x8068,0x00}, 
        {0x8069,0x00}, {0x806A,0x8F}, {0x806B,0x00}, {0x806C,0xCF}, {0x806D,0x00}, {0x806E,0x23}, {0x806F,0x29}, {0x8070,0x00}, 
        {0x8071,0x83}, {0x8072,0x09}, {0x8073,0x3F}, {0x8074,0x0B}, {0x8075,0x40}, {0x8076,0x0F}, {0x8077,0x40}, {0x8078,0x40}, 
        {0x8079,0x04}, {0x807A,0x00}, {0x807B,0x1E}, {0x807C,0xBE}, {0x807D,0xBC}
    }; // Generated 17-Mar-2011 10:54:54

#endif // DWPHY_SUPPORT_MOJAVE
//
// DMW96
// Nevada Baseband (FPGA Prototype Version) and RF52B31
//
#if defined(DWPHY_SUPPORT_NEVADA_FPGA)

    // Manual edits: Reg0x004 = 0x05 RXMode    =   5 (was   7) to disable DSSS/CCK receiver (FPGA problem)
    //               Reg0x0D9 = 0x80 DelayPA   =   0 (was   5) to match RF52B31 settings above
    //               Reg0x0CE = 0xC8 Abort/Restart   (was xB8) to enable step-up/down at all times
    //               Reg0x0EA = 0x02 DAC_IFS   =   2 (was   3) to reduce TX distortion
    //               Reg0x126 = 0x28 REFOSCTUNE=  40 (was  81) to reduce CFO on Sandy D
    //               Reg0x14C = 0x73 PCOUNTDEF = 115 (was 110) for faster ALC convergence at room temperature
    //               Reg0x154 = 0x30 DACOFFSET =  48 (was  42) to provide a more conservative default output power
    //               Reg0x158 = 0x36 IFOFFSET  =  54 (was  50) to compensate reduction in input signal level (DAC_IFS)
    static dwPhyRegPair_t DefaultReg_NevadaFPGA_RF52B31[] = 
    {
        {0x001,0x07}, {0x003,0x03}, {0x004,0x05}, {0x005,0x00}, {0x006,0x23}, {0x007,0x00}, {0x008,0x12}, {0x009,0x12}, 
        {0x00A,0x00}, {0x00C,0x00}, {0x00D,0x00}, {0x00E,0x7F}, {0x018,0xFF}, {0x019,0x0D}, {0x01A,0xFF}, {0x01B,0xFF}, 
        {0x01C,0x26}, {0x01D,0xF8}, {0x01E,0x43}, {0x01F,0x00}, {0x020,0x0C}, {0x021,0x17}, {0x022,0x00}, {0x023,0x00}, 
        {0x024,0x00}, {0x025,0x00}, {0x026,0x00}, {0x027,0x00}, {0x028,0x00}, {0x029,0x00}, {0x02A,0x00}, {0x02B,0x00}, 
        {0x02C,0x00}, {0x02D,0x00}, {0x02E,0x00}, {0x030,0x06}, {0x031,0x79}, {0x032,0x04}, {0x033,0xB4}, {0x034,0x50}, 
        {0x035,0x18}, {0x036,0x00}, {0x037,0x00}, {0x03B,0x1C}, {0x03C,0xEA}, {0x03D,0x28}, {0x03E,0x1E}, {0x03F,0x0F}, 
        {0x040,0x3C}, {0x041,0x24}, {0x042,0x00}, {0x043,0x38}, {0x044,0x48}, {0x045,0x42}, {0x046,0x14}, {0x047,0x0C}, 
        {0x048,0x08}, {0x049,0x12}, {0x04A,0x0C}, {0x04B,0x3F}, {0x04C,0x00}, {0x04D,0x09}, {0x04E,0x0A}, {0x050,0x72}, 
        {0x051,0x2C}, {0x052,0x68}, {0x053,0x1E}, {0x054,0x12}, {0x055,0x17}, {0x057,0x3D}, {0x058,0x04}, {0x059,0x06}, 
        {0x05A,0x2A}, {0x05B,0xC3}, {0x05C,0x80}, {0x05D,0x19}, {0x060,0x10}, {0x061,0x0F}, {0x062,0x90}, {0x063,0x04}, 
        {0x064,0x14}, {0x065,0x5C}, {0x066,0x3C}, {0x067,0xF0}, {0x068,0x14}, {0x069,0x1C}, {0x06A,0xAC}, {0x06B,0x00}, 
        {0x070,0x04}, {0x071,0x00}, {0x072,0x24}, {0x073,0x82}, {0x074,0x80}, {0x078,0x84}, {0x079,0x5C}, {0x07A,0x10}, 
        {0x080,0x04}, {0x082,0xA3}, {0x084,0x15}, {0x085,0x1F}, {0x086,0x15}, {0x087,0x1F}, {0x088,0x02}, {0x08C,0x02}, 
        {0x08D,0x00}, {0x08E,0x02}, {0x08F,0x00}, {0x090,0x81}, {0x091,0x00}, {0x092,0x00}, {0x093,0x00}, {0x094,0x00}, 
        {0x095,0x00}, {0x096,0x00}, {0x097,0x00}, {0x098,0x00}, {0x0A0,0x8F}, {0x0A1,0x23}, {0x0A2,0x1E}, {0x0A3,0x1A}, 
        {0x0A4,0x16}, {0x0A5,0x32}, {0x0A6,0x20}, {0x0A7,0x25}, {0x0A8,0x28}, {0x0A9,0x0A}, {0x0AA,0x1C}, {0x0AB,0x0C}, 
        {0x0AC,0x3F}, {0x0AD,0x00}, {0x0AE,0x08}, {0x0AF,0x0C}, {0x0B0,0x07}, {0x0B1,0x1F}, {0x0B2,0x5A}, {0x0B3,0x2D}, 
        {0x0B5,0x20}, {0x0B6,0x66}, {0x0B7,0x21}, {0x0B8,0x10}, {0x0B9,0x35}, {0x0BA,0x11}, {0x0BB,0x05}, {0x0BC,0x90}, 
        {0x0C5,0x18}, {0x0C6,0xF0}, {0x0C7,0xFF}, {0x0C8,0xFF}, {0x0C9,0xFF}, {0x0CA,0xFF}, {0x0CB,0xFF}, {0x0CC,0xFF}, 
        {0x0CD,0x1E}, {0x0CE,0xC8}, {0x0CF,0x30}, {0x0D0,0x00}, {0x0D1,0xFF}, {0x0D2,0x1C}, {0x0D3,0x0C}, {0x0D4,0x0C}, 
        {0x0D5,0x0C}, {0x0D6,0x08}, {0x0D7,0x07}, {0x0D8,0xBC}, {0x0D9,0x80}, {0x0DA,0x83}, {0x0DB,0x64}, {0x0DC,0x0F}, 
        {0x0DD,0x18}, {0x0DE,0xF1}, {0x0E0,0x1E}, {0x0E1,0x0B}, {0x0E2,0x07}, {0x0E3,0x2B}, {0x0E4,0xA5}, {0x0E5,0x0F}, 
        {0x0E6,0x00}, {0x0E7,0x03}, {0x0E8,0x16}, {0x0E9,0x86}, {0x0EA,0x02}, {0x0EB,0x80}, {0x0EC,0x80}, {0x0ED,0xC5}, 
        {0x0EE,0x50}, {0x0EF,0x00}, {0x0F0,0x7F}, {0x0F1,0x0F}, {0x0F2,0x30}, {0x0F3,0x28}, {0x0F4,0x20}, {0x0F5,0x18}, 
        {0x0F6,0xC5}, {0x0F7,0xC5}, {0x0F8,0xA5}, {0x102,0x03}, {0x103,0x00}, {0x104,0x00}, {0x105,0x00}, {0x109,0x00}, 
        {0x10A,0x0C}, {0x10B,0x00}, {0x10C,0x38}, {0x10D,0x00}, {0x10E,0x00}, {0x10F,0x40}, {0x110,0x4B}, {0x111,0x55}, 
        {0x112,0x07}, {0x113,0x09}, {0x114,0x88}, {0x115,0x88}, {0x116,0x3B}, {0x117,0x4D}, {0x118,0x14}, {0x119,0x1A}, 
        {0x11A,0x08}, {0x11B,0x00}, {0x11C,0x5A}, {0x11D,0x5F}, {0x11E,0x60}, {0x11F,0x01}, {0x120,0xA9}, {0x121,0x13}, 
        {0x122,0x00}, {0x123,0xD0}, {0x124,0x74}, {0x125,0x63}, {0x126,0x28}, {0x127,0x00}, {0x128,0x88}, {0x12F,0x00}, 
        {0x130,0x00}, {0x131,0x00}, {0x132,0xFF}, {0x133,0x00}, {0x134,0x3E}, {0x135,0x8C}, {0x136,0x50}, {0x137,0x00}, 
        {0x138,0x62}, {0x139,0x14}, {0x13A,0x4F}, {0x13B,0x29}, {0x13C,0x29}, {0x13D,0x45}, {0x13E,0xA2}, {0x13F,0xAB}, 
        {0x140,0x36}, {0x141,0x40}, {0x142,0x50}, {0x143,0xEA}, {0x144,0x00}, {0x145,0x24}, {0x146,0xC4}, {0x147,0xBC}, 
        {0x148,0xFE}, {0x149,0x3F}, {0x14A,0x01}, {0x14C,0x73}, {0x14E,0x3C}, {0x14F,0x14}, {0x150,0xCC}, {0x151,0x50}, 
        {0x152,0x7F}, {0x153,0xFD}, {0x154,0x30}, {0x155,0x60}, {0x156,0x30}, {0x157,0x79}, {0x158,0x36}, {0x159,0x00}, 
        {0x15A,0x3F}, {0x15B,0x03}, {0x15C,0x52}, {0x15D,0x06}, {0x15E,0x8C}, {0x15F,0xC0}, {0x160,0x12}, {0x161,0x08}, 
        {0x162,0x00}, {0x163,0x90}, {0x164,0xB0}, {0x165,0x00}, {0x166,0x00}, {0x167,0x25}, {0x168,0x78}, {0x169,0x5C}, 
        {0x16A,0xB4}, {0x16B,0x04}, {0x16C,0xB0}, {0x16D,0xB4}, {0x16E,0x24}, {0x16F,0x0C}, {0x170,0xC8}, {0x171,0x1D}, 
        {0x172,0x00}, {0x173,0xC0}, {0x174,0x00}, {0x175,0x40}, {0x176,0x60}, {0x177,0x01}, {0x178,0x3C}, {0x179,0x3C}, 
        {0x17A,0x0E}, {0x17B,0xC0}, {0x17C,0x10}, {0x17D,0x3C}
    }; // Generated 11-Mar-2010 18:12:42

    // Manual edits: Reg0x0003 = 0x02 PathSel         =  2 (was   1) to match RF22 Yarden modules
    //               Reg0x0004 = 0x05 RXMode          =  5 (was   7) to disable DSSS/CCK receiver (FPGA problem)
    //               Reg0x0041 = 0x21 InitAGain       = 33 (was  36)
    //               Reg0x00CE = 0xC8 Abort/Restart        (was xB8) to enable step-up/down at all times
    //               Reg0x00D9 = 0x80 DelayPA         =  0 (was   5) to match settings above
    //               Reg0x00DA = 0x83 DelayState51    =  3 (was   0) to match settings above
    //               Reg0x00E3 = 0x07 ADCBOPM         =  7 (was x2B)
    //               Reg0x00E4 = 0xC3                      (was xA5) to use ANT 2 for default RX/TX and enable ANT Diversity  
    //               Reg0x00EA = 0x02 DAC_IFS         =  2 (was   3) to reduce TX distortion
    //               Reg0x0113 = 0x00 LCKDETRST/DIS   =  0 (was   1)
    //               Reg0x0115 = 0x41 REFOSCTUNE      = 65 (was  81)
    //               Reg0x016A = 0x81 TX_DCOC_EN      =  1 (was   0) to squelch pre-packet LO feed-through
    //               Reg0x0172 = 0x0F PGAGAINNOM/DCOC =  3 (was   2) to increase PGA gain for better CCK-ACR
    //               Reg0x8038 = 0x04 DET_DIV_VOVR    =  1 (was   0)
    //               Reg0x805B = 0x20 MAPD_MAX_PWR    = 32 (was  46)
    //         Note: Power-control registers are edited to have nominal values.              
    static dwPhyRegPair_t DefaultReg_NevadaFPGA_RF22A12[] = 
    {
        {0x0001,0x07}, {0x0003,0x02}, {0x0004,0x05}, {0x0005,0x00}, {0x0006,0x23}, {0x0007,0x00}, {0x0008,0x12}, {0x0009,0x12}, 
        {0x000A,0x00}, {0x000C,0x00}, {0x000D,0x00}, {0x000E,0x7F}, {0x0018,0xFF}, {0x0019,0x0D}, {0x001A,0xFF}, {0x001B,0xFF}, 
        {0x001C,0x26}, {0x001D,0xF8}, {0x001E,0x43}, {0x001F,0x00}, {0x0020,0x0C}, {0x0021,0x17}, {0x0022,0x00}, {0x0023,0x00}, 
        {0x0024,0x00}, {0x0025,0x00}, {0x0026,0x00}, {0x0027,0x00}, {0x0028,0x00}, {0x0029,0x00}, {0x002A,0x00}, {0x002B,0x00}, 
        {0x002C,0x00}, {0x002D,0x00}, {0x002E,0x00}, {0x0030,0x06}, {0x0031,0x79}, {0x0032,0x04}, {0x0033,0xB4}, {0x0034,0x50}, 
        {0x0035,0x18}, {0x0036,0x00}, {0x0037,0x00}, {0x003B,0x1C}, {0x003C,0xEA}, {0x003D,0x28}, {0x003E,0x1E}, {0x003F,0x0F}, 
        {0x0040,0x3C}, {0x0041,0x21}, {0x0042,0x00}, {0x0043,0x38}, {0x0044,0x48}, {0x0045,0x42}, {0x0046,0x14}, {0x0047,0x0C}, 
        {0x0048,0x08}, {0x0049,0x12}, {0x004A,0x0C}, {0x004B,0x3F}, {0x004C,0x00}, {0x004D,0x09}, {0x004E,0x0A}, {0x0050,0x72}, 
        {0x0051,0x2C}, {0x0052,0x68}, {0x0053,0x1E}, {0x0054,0x12}, {0x0055,0x17}, {0x0057,0x3D}, {0x0058,0x04}, {0x0059,0x06}, 
        {0x005A,0x2A}, {0x005B,0xC3}, {0x005C,0x80}, {0x005D,0x19}, {0x0060,0x10}, {0x0061,0x0F}, {0x0062,0x90}, {0x0063,0x04}, 
        {0x0064,0x14}, {0x0065,0x5C}, {0x0066,0x3C}, {0x0067,0xF0}, {0x0068,0x14}, {0x0069,0x1C}, {0x006A,0xAC}, {0x006B,0x00}, 
        {0x0070,0x04}, {0x0071,0x00}, {0x0072,0x24}, {0x0073,0x82}, {0x0074,0x80}, {0x0078,0x84}, {0x0079,0x5C}, {0x007A,0x10}, 
        {0x0080,0x04}, {0x0082,0xA3}, {0x0084,0x15}, {0x0085,0x1F}, {0x0086,0x15}, {0x0087,0x1F}, {0x0088,0x02}, {0x008C,0x02}, 
        {0x008D,0x00}, {0x008E,0x02}, {0x008F,0x00}, {0x0090,0x81}, {0x0091,0x00}, {0x0092,0x00}, {0x0093,0x00}, {0x0094,0x00}, 
        {0x0095,0x00}, {0x0096,0x00}, {0x0097,0x00}, {0x0098,0x00}, {0x00A0,0x8F}, {0x00A1,0x23}, {0x00A2,0x1E}, {0x00A3,0x1A}, 
        {0x00A4,0x16}, {0x00A5,0x32}, {0x00A6,0x20}, {0x00A7,0x25}, {0x00A8,0x28}, {0x00A9,0x0A}, {0x00AA,0x1C}, {0x00AB,0x0C}, 
        {0x00AC,0x3F}, {0x00AD,0x00}, {0x00AE,0x08}, {0x00AF,0x0C}, {0x00B0,0x07}, {0x00B1,0x1F}, {0x00B2,0x5A}, {0x00B3,0x2D}, 
        {0x00B5,0x20}, {0x00B6,0x66}, {0x00B7,0x21}, {0x00B8,0x10}, {0x00B9,0x35}, {0x00BA,0x11}, {0x00BB,0x05}, {0x00BC,0x90}, 
        {0x00C5,0x18}, {0x00C6,0xF0}, {0x00C7,0xFF}, {0x00C8,0xFF}, {0x00C9,0xFF}, {0x00CA,0xFF}, {0x00CB,0xFF}, {0x00CC,0xFF}, 
        {0x00CD,0x1E}, {0x00CE,0xC8}, {0x00CF,0x30}, {0x00D0,0x00}, {0x00D1,0xFF}, {0x00D2,0x1C}, {0x00D3,0x0C}, {0x00D4,0x0C}, 
        {0x00D5,0x0C}, {0x00D6,0x08}, {0x00D7,0x07}, {0x00D8,0xBC}, {0x00D9,0x80}, {0x00DA,0x83}, {0x00DB,0x64}, {0x00DC,0x0F}, 
        {0x00DD,0x18}, {0x00DE,0xF1}, {0x00E0,0x1E}, {0x00E1,0x0B}, {0x00E2,0x07}, {0x00E3,0x07}, {0x00E4,0xC3}, {0x00E5,0x0F}, 
        {0x00E6,0x00}, {0x00E7,0x03}, {0x00E8,0x16}, {0x00E9,0x86}, {0x00EA,0x02}, {0x00EB,0x80}, {0x00EC,0x80}, {0x00ED,0xC5}, 
        {0x00EE,0x50}, {0x00EF,0x00}, {0x00F0,0x7F}, {0x00F1,0x0F}, {0x00F2,0x30}, {0x00F3,0x28}, {0x00F4,0x20}, {0x00F5,0x18}, 
        {0x00F6,0xC5}, {0x00F7,0xC5}, {0x00F8,0xA5}, {0x0102,0x00}, {0x0103,0x00}, {0x0104,0x00}, {0x0105,0x02}, {0x0106,0x00}, 
        {0x0107,0x00}, {0x0108,0x40}, {0x0109,0x00}, {0x010A,0x00}, {0x010B,0x00}, {0x010C,0x07}, {0x010D,0x00}, {0x010E,0x00}, 
        {0x010F,0x5A}, {0x0110,0x95}, {0x0111,0x00}, {0x0112,0x00}, {0x0113,0x00}, {0x0114,0x88}, {0x0115,0x41}, {0x0116,0x00}, 
        {0x0117,0x18}, {0x0118,0x23}, {0x0119,0x00}, {0x011A,0x03}, {0x011B,0x00}, {0x011C,0x13}, {0x011D,0x00}, {0x011E,0x00}, 
        {0x011F,0xA1}, {0x0120,0x07}, {0x0121,0xD9}, {0x0122,0x00}, {0x0123,0x00}, {0x0124,0x00}, {0x0125,0x00}, {0x0126,0x00}, 
        {0x0127,0x00}, {0x0128,0x07}, {0x0129,0x3F}, {0x012A,0x3F}, {0x012B,0x0D}, {0x012C,0x00}, {0x012D,0x00}, {0x012E,0x00}, 
        {0x012F,0x03}, {0x0130,0x00}, {0x0131,0x00}, {0x0132,0x03}, {0x0133,0x00}, {0x0134,0x00}, {0x0135,0x00}, {0x0136,0x00}, 
        {0x0137,0x00}, {0x0138,0x00}, {0x0139,0x00}, {0x013A,0x00}, {0x013B,0x00}, {0x013C,0x00}, {0x013D,0xC0}, {0x013E,0x00}, 
        {0x013F,0x00}, {0x0140,0x70}, {0x0141,0x00}, {0x0142,0xF0}, {0x0143,0x00}, {0x0144,0x00}, {0x0145,0x00}, {0x0146,0x0C}, 
        {0x0147,0x00}, {0x0148,0x00}, {0x0149,0x46}, {0x014A,0x44}, {0x014B,0x00}, {0x014C,0x71}, {0x014D,0x00}, {0x014E,0x00}, 
        {0x014F,0x00}, {0x0150,0x00}, {0x0151,0x1B}, {0x0152,0x11}, {0x0153,0x9D}, {0x0154,0x13}, {0x0155,0x02}, {0x0156,0x40}, 
        {0x0157,0x00}, {0x0158,0x00}, {0x0159,0x00}, {0x015A,0x00}, {0x015B,0x0C}, {0x015C,0x00}, {0x015D,0x00}, {0x015E,0x08}, 
        {0x015F,0x00}, {0x0160,0x90}, {0x0161,0x00}, {0x0162,0x00}, {0x0163,0x00}, {0x0164,0x00}, {0x0165,0x00}, {0x0166,0x00}, 
        {0x0167,0x03}, {0x0168,0x24}, {0x0169,0xB2}, {0x016A,0x81}, {0x016B,0x20}, {0x016C,0x13}, {0x016D,0x79}, {0x016E,0x04}, 
        {0x016F,0x01}, {0x0170,0x37}, {0x0171,0x1C}, {0x0172,0x0F}, {0x0173,0xC0}, {0x0174,0x00}, {0x0175,0x80}, {0x0176,0x30}, 
        {0x0177,0x01}, {0x0178,0x78}, {0x0179,0x3C}, {0x017A,0x00}, {0x017B,0x64}, {0x017C,0x3C}, {0x017D,0x3F}, {0x017E,0x6F}, 
        {0x017F,0x29}, {0x8000,0x00}, {0x8001,0xFA}, {0x8002,0x00}, {0x8003,0x3F}, {0x8004,0x27}, {0x8005,0x27}, {0x8006,0x00}, 
        {0x8007,0x00}, {0x8008,0x00}, {0x8009,0x00}, {0x800A,0x10}, {0x800B,0x13}, {0x800C,0x11}, {0x800D,0x11}, {0x800E,0x0F}, 
        {0x800F,0x28}, {0x8010,0x28}, {0x8011,0x14}, {0x8012,0x28}, {0x8013,0x3B}, {0x8014,0x67}, {0x8015,0x00}, {0x8016,0x06}, 
        {0x8017,0x28}, {0x8018,0x0A}, {0x8019,0x00}, {0x801A,0x82}, {0x801B,0x0A}, {0x801C,0x8E}, {0x801D,0xA6}, {0x801E,0x09}, 
        {0x801F,0x93}, {0x8020,0x61}, {0x8021,0x10}, {0x8022,0xC8}, {0x8023,0xC8}, {0x8024,0x50}, {0x8025,0xC8}, {0x8026,0x32}, 
        {0x8027,0x32}, {0x8028,0x32}, {0x8029,0x32}, {0x802A,0x01}, {0x802B,0x00}, {0x802C,0x00}, {0x802D,0x00}, {0x802E,0x22}, 
        {0x802F,0x80}, {0x8030,0x80}, {0x8031,0x66}, {0x8032,0x33}, {0x8033,0x36}, {0x8034,0x82}, {0x8035,0x30}, {0x8036,0x00}, 
        {0x8037,0x00}, {0x8038,0x04}, {0x8039,0xD2}, {0x803A,0x6E}, {0x803B,0x06}, {0x803C,0x00}, {0x803D,0x00}, {0x803E,0x1F}, 
        {0x803F,0x51}, {0x8040,0x76}, {0x8041,0x0B}, {0x8042,0x00}, {0x8043,0x01}, {0x8044,0x03}, {0x8045,0x0F}, {0x8046,0x1A}, 
        {0x8047,0x28}, {0x8048,0x31}, {0x8049,0x82}, {0x804A,0x01}, {0x804B,0xA2}, {0x804C,0x10}, {0x804D,0x2F}, {0x804E,0x5A}, 
        {0x804F,0x50}, {0x8050,0x85}, {0x8051,0xC4}, {0x8052,0xFF}, {0x8053,0x31}, {0x8054,0x65}, {0x8055,0x5F}, {0x8056,0xA5}, 
        {0x8057,0xEC}, {0x8058,0xF7}, {0x8059,0x0C}, {0x805A,0x00}, {0x805B,0x20}, {0x805C,0xC5}, {0x805D,0x00}, {0x805E,0x82}, 
        {0x805F,0x14}, {0x8060,0x03}, {0x8061,0x07}, {0x8062,0x6C}, {0x8063,0x2A}, {0x8064,0x00}, {0x8065,0x00}, {0x8066,0x00}, 
        {0x8067,0x00}, {0x8068,0x00}, {0x8069,0x00}, {0x806A,0x8F}, {0x806B,0x00}, {0x806C,0xCF}, {0x806D,0x00}, {0x806E,0x23}, 
        {0x806F,0x29}, {0x8070,0x00}, {0x8071,0x83}, {0x8072,0x09}, {0x8073,0x3F}, {0x8074,0x0B}, {0x8075,0x40}, {0x8076,0x0F}, 
        {0x8077,0x40}, {0x8078,0x40}, {0x8079,0x04}, {0x807A,0x00}, {0x807B,0x1E}, {0x807C,0xBE}, {0x807D,0xBC}
    }; // Generated 17-Mar-2011 10:56:30

#endif // DWPHY_SUPPORT_NEVADA_FPGA
//
// DMW96 ASIC
// Nevada Baseband and RF52B31, RF22xxx
//
#if defined(DWPHY_SUPPORT_NEVADA)

    // Manual edits: Reg0x0041 = 0x23 InitAGain = 35 (was 36)
    static dwPhyRegPair_t DefaultReg_Nevada_RF52B31[] = 
    {
        {0x003,0x01}, {0x004,0x07}, {0x005,0x00}, {0x006,0x03}, {0x007,0x00}, {0x008,0x12}, {0x00A,0x00}, {0x00C,0x00}, 
        {0x00D,0x00}, {0x00E,0x7F}, {0x018,0xFF}, {0x019,0x0D}, {0x01A,0xFF}, {0x01B,0xFF}, {0x01C,0x26}, {0x01D,0xF8}, 
        {0x01E,0x43}, {0x01F,0x00}, {0x020,0x0C}, {0x021,0x17}, {0x024,0x00}, {0x025,0x00}, {0x026,0x00}, {0x027,0x00}, 
        {0x028,0x00}, {0x029,0x00}, {0x02A,0x00}, {0x02B,0x00}, {0x02C,0x00}, {0x02D,0x00}, {0x02E,0x00}, {0x030,0x06}, 
        {0x031,0x79}, {0x032,0x04}, {0x033,0xB4}, {0x034,0x50}, {0x035,0x18}, {0x036,0x00}, {0x037,0x00}, {0x03B,0x1C}, 
        {0x03C,0xEA}, {0x03D,0x28}, {0x03E,0x1E}, {0x03F,0x0F}, {0x040,0x3C}, {0x041,0x23}, {0x042,0x00}, {0x043,0x38}, 
        {0x044,0x48}, {0x045,0x42}, {0x046,0x14}, {0x047,0x0C}, {0x048,0x08}, {0x049,0x12}, {0x04A,0x0C}, {0x04B,0x3F}, 
        {0x04C,0x00}, {0x04D,0x09}, {0x04E,0x0A}, {0x050,0x72}, {0x051,0x2C}, {0x052,0x68}, {0x053,0x1E}, {0x054,0x12}, 
        {0x055,0x17}, {0x057,0x3D}, {0x058,0x04}, {0x059,0x06}, {0x05A,0x2A}, {0x05B,0xC3}, {0x05C,0x80}, {0x05D,0x19}, 
        {0x060,0x10}, {0x061,0x0F}, {0x062,0x90}, {0x063,0x04}, {0x064,0x14}, {0x065,0x1C}, {0x066,0x3C}, {0x067,0xF0}, 
        {0x068,0x14}, {0x069,0x1C}, {0x06A,0xAC}, {0x06B,0x00}, {0x06C,0x25}, {0x070,0x04}, {0x071,0x00}, {0x072,0x24}, 
        {0x073,0x82}, {0x074,0x80}, {0x078,0x84}, {0x079,0x5C}, {0x07A,0x10}, {0x080,0x04}, {0x082,0xA3}, {0x084,0x15}, 
        {0x085,0x1F}, {0x086,0x15}, {0x087,0x1F}, {0x088,0x02}, {0x08C,0x00}, {0x08D,0x00}, {0x08E,0x00}, {0x08F,0x00}, 
        {0x090,0x82}, {0x091,0x00}, {0x092,0x00}, {0x093,0x00}, {0x094,0x00}, {0x095,0x00}, {0x096,0x00}, {0x097,0x00}, 
        {0x098,0x00}, {0x0A0,0x8F}, {0x0A1,0x23}, {0x0A2,0x1E}, {0x0A3,0x1A}, {0x0A4,0x16}, {0x0A5,0x32}, {0x0A6,0x20}, 
        {0x0A7,0x25}, {0x0A8,0x28}, {0x0A9,0x0A}, {0x0AA,0x1C}, {0x0AB,0x0C}, {0x0AC,0x3F}, {0x0AD,0x00}, {0x0AE,0x08}, 
        {0x0AF,0x0C}, {0x0B0,0x07}, {0x0B1,0x1F}, {0x0B2,0x5A}, {0x0B3,0x2D}, {0x0B5,0x20}, {0x0B6,0x66}, {0x0B7,0x21}, 
        {0x0B8,0x10}, {0x0B9,0x35}, {0x0BA,0x11}, {0x0BB,0x05}, {0x0BC,0x90}, {0x0C5,0x1C}, {0x0C6,0xF0}, {0x0C7,0xFF}, 
        {0x0C8,0xFF}, {0x0C9,0xFF}, {0x0CA,0xFF}, {0x0CB,0xFF}, {0x0CC,0xFF}, {0x0CD,0x1E}, {0x0CE,0xCB}, {0x0CF,0x30}, 
        {0x0D0,0x01}, {0x0D1,0x7C}, {0x0D2,0x50}, {0x0D3,0x0D}, {0x0D4,0x0D}, {0x0D5,0x0C}, {0x0D6,0x08}, {0x0D7,0x07}, 
        {0x0D8,0xBC}, {0x0D9,0x80}, {0x0DA,0xB3}, {0x0DB,0x64}, {0x0DC,0x0F}, {0x0DD,0x18}, {0x0DE,0xF1}, {0x0E0,0x1E}, 
        {0x0E1,0x0B}, {0x0E2,0x07}, {0x0E3,0x07}, {0x0E4,0xA5}, {0x0E5,0x3C}, {0x0E6,0x00}, {0x0E7,0x03}, {0x0E8,0x96}, 
        {0x0E9,0x84}, {0x0EA,0x02}, {0x0EB,0x80}, {0x0EC,0x80}, {0x0ED,0xC5}, {0x0EE,0x50}, {0x0EF,0x00}, {0x0F0,0x7F}, 
        {0x0F1,0x0F}, {0x0F2,0x30}, {0x0F3,0x28}, {0x0F4,0x20}, {0x0F5,0x18}, {0x0F6,0xC5}, {0x0F7,0xC5}, {0x0F8,0xA5}, 
        {0x102,0x03}, {0x103,0x00}, {0x104,0x00}, {0x105,0x00}, {0x109,0x00}, {0x10A,0x0C}, {0x10B,0x00}, {0x10C,0x38}, 
        {0x10D,0x00}, {0x10E,0x00}, {0x10F,0x40}, {0x110,0x4B}, {0x111,0x55}, {0x112,0x07}, {0x113,0x09}, {0x114,0x88}, 
        {0x115,0x88}, {0x116,0x3B}, {0x117,0x4D}, {0x118,0x14}, {0x119,0x1A}, {0x11A,0x08}, {0x11B,0x00}, {0x11C,0x5A}, 
        {0x11D,0x5F}, {0x11E,0x60}, {0x11F,0x01}, {0x120,0xA9}, {0x121,0x13}, {0x122,0x00}, {0x123,0xD0}, {0x124,0x74}, 
        {0x125,0x63}, {0x126,0x28}, {0x127,0x00}, {0x128,0x88}, {0x12F,0x00}, {0x130,0x00}, {0x131,0x00}, {0x132,0xFF}, 
        {0x133,0x00}, {0x134,0x3E}, {0x135,0x8C}, {0x136,0x50}, {0x137,0x00}, {0x138,0x62}, {0x139,0x14}, {0x13A,0x4F}, 
        {0x13B,0x29}, {0x13C,0x29}, {0x13D,0x45}, {0x13E,0xA2}, {0x13F,0xAB}, {0x140,0x36}, {0x141,0x40}, {0x142,0x50}, 
        {0x143,0xEA}, {0x144,0x00}, {0x145,0x24}, {0x146,0xC4}, {0x147,0xBC}, {0x148,0xFE}, {0x149,0x3F}, {0x14A,0x01}, 
        {0x14C,0x73}, {0x14E,0x3C}, {0x14F,0x14}, {0x150,0xCC}, {0x151,0x50}, {0x152,0x7F}, {0x153,0xFD}, {0x154,0x30}, 
        {0x155,0x60}, {0x156,0x30}, {0x157,0x79}, {0x158,0x36}, {0x159,0x00}, {0x15A,0x3F}, {0x15B,0x03}, {0x15C,0x52}, 
        {0x15D,0x06}, {0x15E,0x8C}, {0x15F,0xC0}, {0x160,0x12}, {0x161,0x08}, {0x162,0x00}, {0x163,0x90}, {0x164,0xB0}, 
        {0x165,0x00}, {0x166,0x00}, {0x167,0x25}, {0x168,0x78}, {0x169,0x5C}, {0x16A,0xB4}, {0x16B,0x04}, {0x16C,0xB0}, 
        {0x16D,0xB4}, {0x16E,0x24}, {0x16F,0x0C}, {0x170,0xC8}, {0x171,0x1D}, {0x172,0x00}, {0x173,0xC0}, {0x174,0x00}, 
        {0x175,0x40}, {0x176,0x60}, {0x177,0x01}, {0x178,0x3C}, {0x179,0x3C}, {0x17A,0x0E}, {0x17B,0xC0}, {0x17C,0x10}, 
        {0x17D,0x3C}
    }; // Generated 03-Aug-2011 16:52:29

    // Manual edits: Reg0x0003 = 0x02 PathSel         =  2 (was   1) to match RF22 Yarden modules
    //               Reg0x006C = 0x20 OFDMSwDThLow    = 32 (was  37) 
    //               Reg0x0041 = 0x20 InitAGain       = 32 (was  36)
    //               Reg0x00E4 = 0xC3                      (was xA5) to use ANT 2 for default RX/TX and enable ANT Diversity  

    static dwPhyRegPair_t DefaultReg_Nevada_RF22A12[] = 
    {
        {0x0003,0x02}, {0x0004,0x07}, {0x0005,0x00}, {0x0006,0x03}, {0x0007,0x00}, {0x0008,0x12}, {0x000A,0x00}, {0x000C,0x00}, 
        {0x000D,0x00}, {0x000E,0x7F}, {0x0018,0xFF}, {0x0019,0x0D}, {0x001A,0xFF}, {0x001B,0xFF}, {0x001C,0x26}, {0x001D,0xF8}, 
        {0x001E,0x43}, {0x001F,0x00}, {0x0020,0x0C}, {0x0021,0x17}, {0x0024,0x00}, {0x0025,0x00}, {0x0026,0x00}, {0x0027,0x00}, 
        {0x0028,0x00}, {0x0029,0x00}, {0x002A,0x00}, {0x002B,0x00}, {0x002C,0x00}, {0x002D,0x00}, {0x002E,0x00}, {0x0030,0x06}, 
        {0x0031,0x79}, {0x0032,0x04}, {0x0033,0xB4}, {0x0034,0x50}, {0x0035,0x18}, {0x0036,0x00}, {0x0037,0x00}, {0x003B,0x1C}, 
        {0x003C,0xEA}, {0x003D,0x28}, {0x003E,0x1E}, {0x003F,0x0F}, {0x0040,0x3C}, {0x0041,0x20}, {0x0042,0x00}, {0x0043,0x38}, 
        {0x0044,0x48}, {0x0045,0x42}, {0x0046,0x14}, {0x0047,0x0C}, {0x0048,0x08}, {0x0049,0x12}, {0x004A,0x0C}, {0x004B,0x3F}, 
        {0x004C,0x00}, {0x004D,0x09}, {0x004E,0x0A}, {0x0050,0x72}, {0x0051,0x2C}, {0x0052,0x68}, {0x0053,0x1E}, {0x0054,0x12}, 
        {0x0055,0x17}, {0x0057,0x3D}, {0x0058,0x04}, {0x0059,0x06}, {0x005A,0x2A}, {0x005B,0xC3}, {0x005C,0x80}, {0x005D,0x19}, 
        {0x0060,0x10}, {0x0061,0x0F}, {0x0062,0x90}, {0x0063,0x04}, {0x0064,0x14}, {0x0065,0x1C}, {0x0066,0x3C}, {0x0067,0xF0}, 
        {0x0068,0x14}, {0x0069,0x1C}, {0x006A,0xAC}, {0x006B,0x00}, {0x006C,0x20}, {0x0070,0x04}, {0x0071,0x00}, {0x0072,0x24}, 
        {0x0073,0x82}, {0x0074,0x80}, {0x0078,0x84}, {0x0079,0x5C}, {0x007A,0x10}, {0x0080,0x04}, {0x0082,0xA3}, {0x0084,0x15}, 
        {0x0085,0x1F}, {0x0086,0x15}, {0x0087,0x1F}, {0x0088,0x02}, {0x008C,0x00}, {0x008D,0x00}, {0x008E,0x00}, {0x008F,0x00}, 
        {0x0090,0x82}, {0x0091,0x00}, {0x0092,0x00}, {0x0093,0x00}, {0x0094,0x00}, {0x0095,0x00}, {0x0096,0x00}, {0x0097,0x00}, 
        {0x0098,0x00}, {0x00A0,0x8F}, {0x00A1,0x23}, {0x00A2,0x1E}, {0x00A3,0x1A}, {0x00A4,0x16}, {0x00A5,0x32}, {0x00A6,0x20}, 
        {0x00A7,0x25}, {0x00A8,0x28}, {0x00A9,0x0A}, {0x00AA,0x1C}, {0x00AB,0x0C}, {0x00AC,0x3F}, {0x00AD,0x00}, {0x00AE,0x08}, 
        {0x00AF,0x0C}, {0x00B0,0x07}, {0x00B1,0x1F}, {0x00B2,0x5A}, {0x00B3,0x2D}, {0x00B5,0x20}, {0x00B6,0x66}, {0x00B7,0x21}, 
        {0x00B8,0x10}, {0x00B9,0x35}, {0x00BA,0x11}, {0x00BB,0x05}, {0x00BC,0x90}, {0x00C5,0x1C}, {0x00C6,0xF0}, {0x00C7,0xFF}, 
        {0x00C8,0xFF}, {0x00C9,0xFF}, {0x00CA,0xFF}, {0x00CB,0xFF}, {0x00CC,0xFF}, {0x00CD,0x1E}, {0x00CE,0xCB}, {0x00CF,0x30}, 
        {0x00D0,0x01}, {0x00D1,0x7C}, {0x00D2,0x50}, {0x00D3,0x0D}, {0x00D4,0x0D}, {0x00D5,0x0C}, {0x00D6,0x08}, {0x00D7,0x07}, 
        {0x00D8,0xBC}, {0x00D9,0x80}, {0x00DA,0xB3}, {0x00DB,0x64}, {0x00DC,0x0F}, {0x00DD,0x18}, {0x00DE,0xF1}, {0x00E0,0x1E}, 
        {0x00E1,0x0B}, {0x00E2,0x07}, {0x00E3,0x07}, {0x00E4,0xC3}, {0x00E5,0x3C}, {0x00E6,0x00}, {0x00E7,0x03}, {0x00E8,0x96}, 
        {0x00E9,0x84}, {0x00EA,0x02}, {0x00EB,0x80}, {0x00EC,0x80}, {0x00ED,0xC5}, {0x00EE,0x50}, {0x00EF,0x00}, {0x00F0,0x7F}, 
        {0x00F1,0x0F}, {0x00F2,0x30}, {0x00F3,0x28}, {0x00F4,0x20}, {0x00F5,0x18}, {0x00F6,0xC5}, {0x00F7,0xC5}, {0x00F8,0xA5}, 
        {0x0102,0x00}, {0x0103,0x00}, {0x0104,0x00}, {0x0105,0x02}, {0x0106,0x00}, {0x0107,0x00}, {0x0108,0x40}, {0x0109,0x00}, 
        {0x010A,0x00}, {0x010B,0x00}, {0x010C,0x07}, {0x010D,0x00}, {0x010E,0x00}, {0x010F,0x5A}, {0x0110,0x95}, {0x0111,0x00}, 
        {0x0112,0x00}, {0x0113,0x00}, {0x0114,0x88}, {0x0115,0x41}, {0x0116,0x00}, {0x0117,0x18}, {0x0118,0x23}, {0x0119,0x00},  
        {0x011A,0x03}, {0x011B,0x00}, {0x011C,0x13}, {0x011D,0x00}, {0x011E,0x00}, {0x011F,0xA1}, {0x0120,0x07}, {0x0121,0xD9}, 
        {0x0122,0x00}, {0x0123,0x00}, {0x0124,0x00}, {0x0125,0x00}, {0x0126,0x00}, {0x0127,0x00}, {0x0128,0x07}, {0x0129,0x3F}, 
        {0x012A,0x3F}, {0x012B,0x0D}, {0x012C,0x00}, {0x012D,0x00}, {0x012E,0x00}, {0x012F,0x03}, {0x0130,0x00}, {0x0131,0x00}, 
        {0x0132,0x03}, {0x0133,0x00}, {0x0134,0x00}, {0x0135,0x00}, {0x0136,0x00}, {0x0137,0x00}, {0x0138,0x00}, {0x0139,0x00}, 
        {0x013A,0x00}, {0x013B,0x00}, {0x013C,0x00}, {0x013D,0xC0}, {0x013E,0x00}, {0x013F,0x00}, {0x0140,0x70}, {0x0141,0x00}, 
        {0x0142,0xF0}, {0x0143,0x00}, {0x0144,0x00}, {0x0145,0x00}, {0x0146,0x0C}, {0x0147,0x00}, {0x0148,0x00}, {0x0149,0x46}, 
        {0x014A,0x44}, {0x014B,0x00}, {0x014C,0x71}, {0x014D,0x00}, {0x014E,0x00}, {0x014F,0x00}, {0x0150,0x00}, {0x0151,0x1B}, 
        {0x0152,0x11}, {0x0153,0x9D}, {0x0154,0x13}, {0x0155,0x02}, {0x0156,0x40}, {0x0157,0x00}, {0x0158,0x00}, {0x0159,0x00}, 
        {0x015A,0x00}, {0x015B,0x0C}, {0x015C,0x00}, {0x015D,0x00}, {0x015E,0x08}, {0x015F,0x00}, {0x0160,0x90}, {0x0161,0x00}, 
        {0x0162,0x00}, {0x0163,0x00}, {0x0164,0x00}, {0x0165,0x00}, {0x0166,0x00}, {0x0167,0x03}, {0x0168,0x24}, {0x0169,0xB2}, 
        {0x016A,0x81}, {0x016B,0x20}, {0x016C,0x13}, {0x016D,0x79}, {0x016E,0x04}, {0x016F,0x01}, {0x0170,0x37}, {0x0171,0x1C}, 
        {0x0172,0x0F}, {0x0173,0xC0}, {0x0174,0x00}, {0x0175,0x80}, {0x0176,0x30}, {0x0177,0x01}, {0x0178,0x78}, {0x0179,0x3C}, 
        {0x017A,0x00}, {0x017B,0x64}, {0x017C,0x3C}, {0x017D,0x3F}, {0x017E,0x6F}, {0x017F,0x29}, {0x8000,0x00}, {0x8001,0xFA}, 
        {0x8002,0x00}, {0x8003,0x3F}, {0x8004,0x27}, {0x8005,0x27}, {0x8006,0x00}, {0x8007,0x00}, {0x8008,0x00}, {0x8009,0x00}, 
        {0x800A,0x10}, {0x800B,0x13}, {0x800C,0x11}, {0x800D,0x11}, {0x800E,0x0F}, {0x800F,0x28}, {0x8010,0x28}, {0x8011,0x14}, 
        {0x8012,0x28}, {0x8013,0x3B}, {0x8014,0x67}, {0x8015,0x00}, {0x8016,0x06}, {0x8017,0x28}, {0x8018,0x0A}, {0x8019,0x00}, 
        {0x801A,0x82}, {0x801B,0x0A}, {0x801C,0x8E}, {0x801D,0xA6}, {0x801E,0x09}, {0x801F,0x93}, {0x8020,0x61}, {0x8021,0x10}, 
        {0x8022,0xC8}, {0x8023,0xC8}, {0x8024,0x50}, {0x8025,0xC8}, {0x8026,0x32}, {0x8027,0x32}, {0x8028,0x32}, {0x8029,0x32}, 
        {0x802A,0x01}, {0x802B,0x00}, {0x802C,0x00}, {0x802D,0x00}, {0x802E,0x22}, {0x802F,0x80}, {0x8030,0x80}, {0x8031,0x66}, 
        {0x8032,0x33}, {0x8033,0x36}, {0x8034,0x82}, {0x8035,0x30}, {0x8036,0x00}, {0x8037,0x00}, {0x8038,0x04}, {0x8039,0xD2}, 
        {0x803A,0x6E}, {0x803B,0x06}, {0x803C,0x00}, {0x803D,0x00}, {0x803E,0x1F}, {0x803F,0x51}, {0x8040,0x76}, {0x8041,0x0B}, 
        {0x8042,0x00}, {0x8043,0x01}, {0x8044,0x03}, {0x8045,0x0F}, {0x8046,0x1A}, {0x8047,0x28}, {0x8048,0x31}, {0x8049,0x82}, 
        {0x804A,0x01}, {0x804B,0xA2}, {0x804C,0x10}, {0x804D,0x2F}, {0x804E,0x5A}, {0x804F,0x50}, {0x8050,0x85}, {0x8051,0xC4}, 
        {0x8052,0xFF}, {0x8053,0x31}, {0x8054,0x65}, {0x8055,0x5F}, {0x8056,0xA5}, {0x8057,0xEC}, {0x8058,0xF7}, {0x8059,0x0C}, 
        {0x805A,0x00}, {0x805B,0x20}, {0x805C,0xC5}, {0x805D,0x00}, {0x805E,0x82}, {0x805F,0x14}, {0x8060,0x03}, {0x8061,0x07}, 
        {0x8062,0x6C}, {0x8063,0x2A}, {0x8064,0x00}, {0x8065,0x00}, {0x8066,0x00}, {0x8067,0x00}, {0x8068,0x00}, {0x8069,0x00}, 
        {0x806A,0x8F}, {0x806B,0x00}, {0x806C,0xCF}, {0x806D,0x00}, {0x806E,0x23}, {0x806F,0x29}, {0x8070,0x00}, {0x8071,0x83}, 
        {0x8072,0x09}, {0x8073,0x3F}, {0x8074,0x0B}, {0x8075,0x40}, {0x8076,0x0F}, {0x8077,0x40}, {0x8078,0x40}, {0x8079,0x04}, 
        {0x807A,0x00}, {0x807B,0x1E}, {0x807C,0xBE}, {0x807D,0xBC}
    }; // Generated 03-Aug-2011 16:53:32

    // Manual edits: Reg0x0115 = 0x46 REFOSCTUNE = 70 (was  91) after manual calibration of clock 
    //               Reg0x8039 = 0xff          
    //               Reg0x0151 = 0x1F PA1CURTRIM_MASK (was 0x11)  
    //               Reg0x0152 = 0x1F PA2CURTRIM_MASK (was 0x1B)         
    //               Reg0x0153 = 0xD2 VG22_MASK, VG12_MASK (was 0x9D)
    //               Reg0x014E = 0x1F PA1CURTRIM_EVM (was 0x1B)
    //               Reg0x014F = 0x12 PA2CURTRIM_EVM (was 0x11)
    //               Reg0x0157 = 0xFF VG22_EVM, VG12_EVM (was 0x9D)
    //               Reg0x8036 = 0x00 OPEN_LP_CORR_EN (was 0x80)
    //               Reg0x8038 = 0x04 (was 0x00) det_div_vovr (VAL) = 1    use middle curve
    //               Reg0x8059 = 0x04 (was 0x06) normal_state_atten = 4      
    //               Reg0x803F = 0x21 (was 0x51) VGA_STATE3 = 2 
    //               Reg0x8040 = 0x73 (was 0x76) VGA_STATE4 = 3 
    //               Reg0x803E = 0x12 (was 0x1f) ATTN_LOW_LIMIT = 18 
    //               Reg0x0175 = 0x80 (was 0x00) FORCEHIPOLE = 1 
    //               Reg0x0163 = 0x00 (was 0x01) ACC_HIPOLE_EN = 0 , disable Hi-Pole jump on RX filter 
    //               Reg0x013D = 0xC0 (was 0x40) TXMXOUTTRIMGN = 3 
    //               Reg0x0154 = 0xFD (was 0x13) DR2SYM = 3
    //                                           DR2CURTRIM = 3
    //                                           DR1SYM = 3
    //                                           DR1CURTRIM = 1
    //               Reg0x012D = 0x42 (was 0x40) IF_REG_TRIM = 2
    //               Reg0x012E = 0x03 (was 0x00) FE_REG_TRIM = 2
    //               Reg0x014E = 0x16 (was 0x1F) PA1CURTRIM_EVM = 22
    //               Reg0x014F = 0x16 (was 0x12) PA2CURTRIM_EVM = 22
    //               Reg0x0157 = 0x7F (was 0xFF) VG12_EVM = 15
    //                                           VG22_EVM = 7
    //               Reg0x0153 = 0x0F (was 0xD2) VG12_MASK = 15
    //                                           VG22_MASK = 0
    //--------------- DWPHY_VERSION control --------------------------------------------------------
    //               Reg0x0142 = DWPHY_VERSION  (was 0x1F) use register 66 for version control
    //---------------Cancel  Gain shifting mechanism (ACR vs Sensitivity) due to toggeling on PA_50 duaring frame  ----- 
    //               Reg0x0169 = 0x12 (was 0x92)   disable  filter calibration in ane transitions (driver performs  this calibration by DwPhy_CalibrateRxLPF)
    //--------------- Set Maximal output power -----------------------------------------------------
    //               Reg0x805B = 0x29 (was 0x2E) rgf_pwr_mapd_max_pwr = 41   
    //------------------------------------------------------
    /*    
         Reg80 2 0 0     Same 
         Reg21 80 0 0    {0x0115,0x46}->{0x0115,0x50}
         Reg184 0 0 0    {0x8038,0x04}->{0x8038,0x00}
         Reg186 75 0 0   {0x803A,0x6E}->{0x803A,0x4B}
         Reg205 24 0 0   Same
         Reg206 47 0 0   {0x804E,0x30}->{0x804E,0x2F}
         Reg207 41 0 0   {0x804F,0x2C}->{0x804F,0x29}  
         Reg208 71 0 0   {0x8050,0x4E}->{0x8050,0x47} 
         Reg209 135 0 0  {0x8051,0x8E}->{0x8051,0x87}
         Reg210 205 0 0  {0x8052,0xD6}->{0x8052,0xCD}
         Reg211 48 0 0   {0x8053,0x34}->{0x8053,0x30}
         Reg212 98 0 0   {0x8054,0x72}->{0x8054,0x62}
         Reg213 95 0 0   {0x8055,0x68}->{0x8055,0x5F}
         Reg214 158 0 0  {0x8056,0xB7}->{0x8056,0x9E}
         Reg215 230 0 0  {0x8057,0xF9}->{0x8057,0xE6}
         Reg216 255 0 0  Same
         Reg196 22 0 0   {0x8044,0x03}->{0x8044,0x16} 
         Reg197 28 0 0   {0x8045,0x0E}->{0x8045,0x1C}
         Reg198 40 0 0   {0x8046,0x17}->{0x8046,0x28}
         Reg199 45 0 0   {0x8047,0x22}->{0x8047,0x2D}
         Reg200 47 0 0   {0x8048,0x2D}->{0x8048,0x2F}
         Reg219 39 0 0   {0x805B,0x29}->{0x805B,0x27}
         Reg220 216 0 0  {0x805C,0x8D}->{0x805C,0xD8} 
    */
    //------------------------------------------------------------------------------------------------------------
    static dwPhyRegPair_t DefaultReg_Nevada_RF22B0[] = 
    {
        {0x0003,0x02}, {0x0004,0x07}, {0x0005,0x00}, {0x0006,0x03}, {0x0007,0x00}, {0x0008,0x12}, {0x000A,0x00}, {0x000C,0x00}, 
        {0x000D,0x00}, {0x000E,0x7F}, {0x0018,0xFF}, {0x0019,0x0D}, {0x001A,0xFF}, {0x001B,0xFF}, {0x001C,0x26}, {0x001D,0xF8}, 
        {0x001E,0x43}, {0x001F,0x00}, {0x0020,0x0C}, {0x0021,0x17}, {0x0024,0x00}, {0x0025,0x00}, {0x0026,0x00}, {0x0027,0x00}, 
        {0x0028,0x00}, {0x0029,0x00}, {0x002A,0x00}, {0x002B,0x00}, {0x002C,0x00}, {0x002D,0x00}, {0x002E,0x00}, {0x0030,0x06}, 
        {0x0031,0x79}, {0x0032,0x04}, {0x0033,0xB4}, {0x0034,0x50}, {0x0035,0x18}, {0x0036,0x00}, {0x0037,0x00}, {0x003B,0x1C}, 
        {0x003C,0xEA}, {0x003D,0x28}, {0x003E,0x1E}, {0x003F,0x0F}, {0x0040,0x3C}, {0x0041,0x21}, {0x0042,0x00}, {0x0043,0x38}, 
        {0x0044,0x48}, {0x0045,0x42}, {0x0046,0x14}, {0x0047,0x0C}, {0x0048,0x08}, {0x0049,0x12}, {0x004A,0x0C}, {0x004B,0x3F}, 
        {0x004C,0x00}, {0x004D,0x09}, {0x004E,0x0A}, {0x0050,0x72}, {0x0051,0x2C}, {0x0052,0x68}, {0x0053,0x1E}, {0x0054,0x12}, 
        {0x0055,0x17}, {0x0057,0x3D}, {0x0058,0x04}, {0x0059,0x06}, {0x005A,0x2A}, {0x005B,0xC3}, {0x005C,0x80}, {0x005D,0x19}, 
        {0x0060,0x10}, {0x0061,0x0F}, {0x0062,0x90}, {0x0063,0x04}, {0x0064,0x14}, {0x0065,0x1C}, {0x0066,0x3C}, {0x0067,0xF0}, 
        {0x0068,0x14}, {0x0069,0x1C}, {0x006A,0xAC}, {0x006B,0x00}, {0x006C,0x20}, {0x0070,0x04}, {0x0071,0x00}, {0x0072,0x24},
        {0x0073,0x82}, {0x0074,0x80}, {0x0078,0x84}, {0x0079,0x5C}, {0x007A,0x10}, {0x0080,0x04}, {0x0082,0xA3}, {0x0084,0x15}, 
        {0x0085,0x1F}, {0x0086,0x15}, {0x0087,0x1F}, {0x0088,0x02}, {0x008C,0x00}, {0x008D,0x00}, {0x008E,0x00}, {0x008F,0x00}, 
        {0x0090,0x82}, {0x0091,0x00}, {0x0092,0x00}, {0x0093,0x00}, {0x0094,0x00}, {0x0095,0x00}, {0x0096,0x00}, {0x0097,0x00}, 
        {0x0098,0x00}, {0x00A0,0x8F}, {0x00A1,0x23}, {0x00A2,0x1E}, {0x00A3,0x1A}, {0x00A4,0x16}, {0x00A5,0x32}, {0x00A6,0x20}, 
        {0x00A7,0x25}, {0x00A8,0x28}, {0x00A9,0x0A}, {0x00AA,0x1C}, {0x00AB,0x0C}, {0x00AC,0x3F}, {0x00AD,0x00}, {0x00AE,0x08}, 
        {0x00AF,0x0C}, {0x00B0,0x07}, {0x00B1,0x1F}, {0x00B2,0x5A}, {0x00B3,0x2D}, {0x00B5,0x20}, {0x00B6,0x66}, {0x00B7,0x21}, 
        {0x00B8,0x10}, {0x00B9,0x35}, {0x00BA,0x11}, {0x00BB,0x05}, {0x00BC,0x90}, {0x00C5,0x1C}, {0x00C6,0xF0}, {0x00C7,0xFF}, 
        {0x00C8,0xFF}, {0x00C9,0xFF}, {0x00CA,0xFF}, {0x00CB,0xFF}, {0x00CC,0xFF}, {0x00CD,0x1E}, {0x00CE,0xCB}, {0x00CF,0x30}, 
        {0x00D0,0x01}, {0x00D1,0x7C}, {0x00D2,0x50}, {0x00D3,0x0D}, {0x00D4,0x0D}, {0x00D5,0x0C}, {0x00D6,0x08}, {0x00D7,0x07}, 
        {0x00D8,0xBC}, {0x00D9,0x80}, {0x00DA,0xB3}, {0x00DB,0x64}, {0x00DC,0x0F}, {0x00DD,0x18}, {0x00DE,0xF1}, {0x00E0,0x1E}, 
        {0x00E1,0x0B}, {0x00E2,0x07}, {0x00E3,0x07}, {0x00E4,0xC3}, {0x00E5,0x3C}, {0x00E6,0x00}, {0x00E7,0x03}, {0x00E8,0x96}, 
        {0x00E9,0x84}, {0x00EA,0x02}, {0x00EB,0x80}, {0x00EC,0x80}, {0x00ED,0xC5}, {0x00EE,0x50}, {0x00EF,0x00}, {0x00F0,0x7F}, 
        {0x00F1,0x0F}, {0x00F2,0x30}, {0x00F3,0x28}, {0x00F4,0x20}, {0x00F5,0x18}, {0x00F6,0xC5}, {0x00F7,0xC5}, {0x00F8,0xA5}, 
        {0x0102,0x00}, {0x0103,0x00}, {0x0104,0xC0}, {0x0105,0x02}, {0x0106,0xA6}, {0x0107,0x07}, {0x0108,0x40}, {0x0109,0x00},
        {0x010A,0x00}, {0x010B,0x00}, {0x010C,0x07}, {0x010D,0x00}, {0x010E,0x00}, {0x010F,0x5A}, {0x0110,0x95}, {0x0111,0x00},
        {0x0112,0x00}, {0x0113,0x00}, {0x0114,0x88}, {0x0115,0x50}, {0x0116,0x00}, {0x0117,0x18}, {0x0118,0x23}, {0x0119,0x00},
        {0x011A,0x03}, {0x011B,0x00}, {0x011C,0x13}, {0x011D,0x00}, {0x011E,0x00}, {0x011F,0xA1}, {0x0120,0x07}, {0x0121,0x1A},
        {0x0122,0x00}, {0x0123,0x00}, {0x0124,0x00}, {0x0125,0x00}, {0x0126,0x00}, {0x0127,0x00}, {0x0128,0x45}, {0x0129,0x3F},
        {0x012A,0x3F}, {0x012B,0x0D}, {0x012C,0x00}, {0x012D,0x42}, {0x012E,0x03}, {0x012F,0x43}, {0x0130,0x00}, {0x0131,0x40},
        {0x0132,0xC3}, {0x0133,0x1E}, {0x0134,0x1E}, {0x0135,0x28}, {0x0136,0x1E}, {0x0137,0x00}, {0x0138,0x00}, {0x0139,0x00},
        {0x013A,0x00}, {0x013B,0x00}, {0x013C,0x78}, {0x013D,0xC0}, {0x013E,0x00}, {0x013F,0x00}, {0x0140,0x70}, {0x0141,0x00},
        {0x0142,DWPHY_VERSION}, 
                       {0x0143,0x00}, {0x0144,0x00}, {0x0145,0x00}, {0x0146,0x0C}, {0x0147,0x00}, {0x0148,0x00}, {0x0149,0x46},
        {0x014A,0x44}, {0x014B,0x00}, {0x014C,0x71}, {0x014D,0x08}, {0x014E,0x16}, {0x014F,0x16}, {0x0150,0x02}, {0x0151,0x1F},
        {0x0152,0x1F}, {0x0153,0x0F}, {0x0154,0xFD}, {0x0155,0x02}, {0x0156,0x40}, {0x0157,0x7F}, {0x0158,0x00}, {0x0159,0x00},
        {0x015A,0x00}, {0x015B,0x0C}, {0x015C,0x00}, {0x015D,0x00}, {0x015E,0x08}, {0x015F,0x00}, {0x0160,0x90}, {0x0161,0x00},
        {0x0162,0x00}, {0x0163,0x00}, {0x0164,0x00}, {0x0165,0x00}, {0x0166,0x00}, {0x0167,0x03}, {0x0168,0x24}, {0x0169,0x12},
        {0x016A,0xA0}, {0x016B,0x20}, {0x016C,0x73}, {0x016D,0x73}, {0x016E,0x04}, {0x016F,0x01}, {0x0170,0x27}, {0x0171,0x1C},
        {0x0172,0x0F}, {0x0173,0xC0}, {0x0174,0x00}, {0x0175,0x80}, {0x0176,0x30}, {0x0177,0x01}, {0x0178,0x78}, {0x0179,0x3C},
        {0x017A,0x14}, {0x017B,0x64}, {0x017C,0x3C}, {0x017D,0x3F}, {0x017E,0x7F}, {0x017F,0x90}, {0x8000,0x00}, {0x8001,0xFA},
        {0x8002,0x00}, {0x8003,0x3F}, {0x8004,0x27}, {0x8005,0x27}, {0x8006,0x00}, {0x8007,0x00}, {0x8008,0x00}, {0x8009,0x00},
        {0x800A,0x10}, {0x800B,0x13}, {0x800C,0x0F}, {0x800D,0x0E}, {0x800E,0x00}, {0x800F,0x28}, {0x8010,0x28}, {0x8011,0x14},
        {0x8012,0x28}, {0x8013,0x3B}, {0x8014,0x67}, {0x8015,0x00}, {0x8016,0x06}, {0x8017,0x28}, {0x8018,0x0A}, {0x8019,0x00},
        {0x801A,0x82}, {0x801B,0x12}, {0x801C,0x8E}, {0x801D,0xA6}, {0x801E,0x09}, {0x801F,0x93}, {0x8020,0x61}, {0x8021,0x10},
        {0x8022,0xC8}, {0x8023,0xC8}, {0x8024,0x50}, {0x8025,0xC8}, {0x8026,0x32}, {0x8027,0x32}, {0x8028,0x32}, {0x8029,0x32},
        {0x802A,0x16}, {0x802B,0x00}, {0x802C,0x00}, {0x802D,0x00}, {0x802E,0x22}, {0x802F,0x80}, {0x8030,0x80}, {0x8031,0x66},
        {0x8032,0x33}, {0x8033,0x36}, {0x8034,0x82}, {0x8035,0x30}, {0x8036,0x00}, {0x8037,0x08}, {0x8038,0x00}, {0x8039,0xFF},
        {0x803A,0x4B}, {0x803B,0x00}, {0x803C,0x00}, {0x803D,0x00}, {0x803E,0x12}, {0x803F,0x21}, {0x8040,0x73}, {0x8041,0x0B}, 
        {0x8042,0x00}, {0x8043,0x00}, {0x8044,0x16}, {0x8045,0x1C}, {0x8046,0x28}, {0x8047,0x2D}, {0x8048,0x2F}, {0x8049,0x00},
        {0x804A,0x01}, {0x804B,0xA2}, {0x804C,0x10}, {0x804D,0x18}, {0x804E,0x2F}, {0x804F,0x29}, {0x8050,0x47}, {0x8051,0x87},
        {0x8052,0xCD}, {0x8053,0x30}, {0x8054,0x62}, {0x8055,0x5F}, {0x8056,0x9E}, {0x8057,0xE6}, {0x8058,0xFF}, {0x8059,0x04},
        {0x805A,0x00}, {0x805B,0x27}, {0x805C,0xD8}, {0x805D,0x00}, {0x805E,0x82}, {0x805F,0x14}, {0x8060,0x03}, {0x8061,0x07},
        {0x8062,0xEC}, {0x8063,0x2A}, {0x8064,0x00}, {0x8065,0x00}, {0x8066,0x00}, {0x8067,0x00}, {0x8068,0x00}, {0x8069,0x00},
        {0x806A,0x01}, {0x806B,0xCB}, {0x806C,0xC2}, {0x806D,0x00}, {0x806E,0x00}, {0x806F,0x00}, {0x8070,0x28}, {0x8071,0xA4},
        {0x8072,0x23}, {0x8073,0x3F}, {0x8074,0x0B}, {0x8075,0x40}, {0x8076,0x0F}, {0x8077,0x40}, {0x8078,0x40}, {0x8079,0x04},
        {0x807A,0x00}, {0x807B,0x1E}, {0x807C,0xC2}, {0x807D,0xBC}, {0x807E,0x90}, {0x807F,0x90}

    }; // Updated 1-Mar-2012 18:32

    // Registers for Nadine:
    //   - Set (0x043) = 0x7F (AbsPwrH = 0x7F...prevent AGC from attempting to adjust radio gain)
    //   - Set (0x067) = 0xE0 (disable LgSigDet...not sure about its state without a radio)
    static dwPhyRegPair_t DefaultReg_Nevada_Nadine[] = 
    {
        {0x003,0x01}, {0x004,0x07}, {0x005,0x00}, {0x006,0x03}, {0x007,0x00}, {0x008,0x12}, {0x00A,0x00}, {0x00C,0x00}, 
        {0x00D,0x00}, {0x00E,0x7F}, {0x018,0xFF}, {0x019,0x0D}, {0x01A,0xFF}, {0x01B,0xFF}, {0x01C,0x26}, {0x01D,0xF8}, 
        {0x01E,0x43}, {0x01F,0x00}, {0x020,0x0C}, {0x021,0x17}, {0x024,0x00}, {0x025,0x00}, {0x026,0x00}, {0x027,0x00}, 
        {0x028,0x00}, {0x029,0x00}, {0x02A,0x00}, {0x02B,0x00}, {0x02C,0x00}, {0x02D,0x00}, {0x02E,0x00}, {0x030,0x06}, 
        {0x031,0x79}, {0x032,0x04}, {0x033,0xB4}, {0x034,0x50}, {0x035,0x18}, {0x036,0x00}, {0x037,0x00}, {0x03B,0x1C}, 
        {0x03C,0xEA}, {0x03D,0x28}, {0x03E,0x1E}, {0x03F,0x0F}, {0x040,0x3C}, {0x041,0x24}, {0x042,0x00}, {0x043,0x7F}, 
        {0x044,0x48}, {0x045,0x42}, {0x046,0x14}, {0x047,0x0C}, {0x048,0x08}, {0x049,0x12}, {0x04A,0x0C}, {0x04B,0x3F}, 
        {0x04C,0x00}, {0x04D,0x09}, {0x04E,0x0A}, {0x050,0x72}, {0x051,0x2C}, {0x052,0x68}, {0x053,0x1E}, {0x054,0x12}, 
        {0x055,0x17}, {0x057,0x3D}, {0x058,0x04}, {0x059,0x06}, {0x05A,0x2A}, {0x05B,0xC3}, {0x05C,0x80}, {0x05D,0x19}, 
        {0x060,0x10}, {0x061,0x0F}, {0x062,0x90}, {0x063,0x04}, {0x064,0x14}, {0x065,0x1C}, {0x066,0x3C}, {0x067,0xE0}, 
        {0x068,0x14}, {0x069,0x1C}, {0x06A,0xAC}, {0x06B,0x00}, {0x06C,0x25}, {0x070,0x04}, {0x071,0x00}, {0x072,0x24}, 
        {0x073,0x82}, {0x074,0x80}, {0x078,0x84}, {0x079,0x5C}, {0x07A,0x10}, {0x080,0x04}, {0x082,0xA3}, {0x084,0x15}, 
        {0x085,0x1F}, {0x086,0x15}, {0x087,0x1F}, {0x088,0x02}, {0x08C,0x00}, {0x08D,0x00}, {0x08E,0x00}, {0x08F,0x00}, 
        {0x090,0x82}, {0x091,0x00}, {0x092,0x00}, {0x093,0x00}, {0x094,0x00}, {0x095,0x00}, {0x096,0x00}, {0x097,0x00}, 
        {0x098,0x00}, {0x0A0,0x8F}, {0x0A1,0x23}, {0x0A2,0x1E}, {0x0A3,0x1A}, {0x0A4,0x16}, {0x0A5,0x32}, {0x0A6,0x20}, 
        {0x0A7,0x25}, {0x0A8,0x28}, {0x0A9,0x0A}, {0x0AA,0x1C}, {0x0AB,0x0C}, {0x0AC,0x3F}, {0x0AD,0x00}, {0x0AE,0x08}, 
        {0x0AF,0x0C}, {0x0B0,0x07}, {0x0B1,0x1F}, {0x0B2,0x5A}, {0x0B3,0x2D}, {0x0B5,0x20}, {0x0B6,0x66}, {0x0B7,0x21}, 
        {0x0B8,0x10}, {0x0B9,0x35}, {0x0BA,0x11}, {0x0BB,0x05}, {0x0BC,0x90}, {0x0C5,0x1C}, {0x0C6,0xF0}, {0x0C7,0xFF}, 
        {0x0C8,0xFF}, {0x0C9,0xFF}, {0x0CA,0xFF}, {0x0CB,0xFF}, {0x0CC,0xFF}, {0x0CD,0x1E}, {0x0CE,0xCB}, {0x0CF,0x30}, 
        {0x0D0,0x00}, {0x0D1,0xFF}, {0x0D2,0x1C}, {0x0D3,0x0D}, {0x0D4,0x0D}, {0x0D5,0x0C}, {0x0D6,0x08}, {0x0D7,0x07}, 
        {0x0D8,0xBC}, {0x0D9,0x80}, {0x0DA,0xB3}, {0x0DB,0x64}, {0x0DC,0x0F}, {0x0DD,0x18}, {0x0DE,0xF1}, {0x0E0,0x1E}, 
        {0x0E1,0x0B}, {0x0E2,0x07}, {0x0E3,0x07}, {0x0E4,0xA5}, {0x0E5,0x3C}, {0x0E6,0x00}, {0x0E7,0x03}, {0x0E8,0x96}, 
        {0x0E9,0x84}, {0x0EA,0x02}, {0x0EB,0x80}, {0x0EC,0x80}, {0x0ED,0xC5}, {0x0EE,0x50}, {0x0EF,0x00}, {0x0F0,0x7F}, 
        {0x0F1,0x0F}, {0x0F2,0x30}, {0x0F3,0x28}, {0x0F4,0x20}, {0x0F5,0x18}, {0x0F6,0xC5}, {0x0F7,0xC5}, {0x0F8,0xA5}, 
    };

#endif // DWPHY_SUPPORT_NEVADA


// ================================================================================================
// Define CHIPSET
// Forms a single unsigned integer from individual baseband and radio part IDs
//
#define CHIPSET( BasebandID, RadioID ) ((BasebandID) | ((RadioID) << 8))

// ================================================================================================
// FUNCTION  : DwPhy_Enable()
// ------------------------------------------------------------------------------------------------
// Purpose   : Set the state of DW_PHYEnB via an external function
// Parameters: pDevInfo     -- pointer to device information structure
//             Enable       -- {0 = disable the PHY, 1 = enable the PHY}
// ================================================================================================
dwPhyStatus_t DwPhy_Enable(dwDevInfo_t *pDevInfo, uint32_t Enable)
{
    DwPhy_t *pDwPhy = (DwPhy_t *)(pDevInfo->pDwPhy);
    
    if( pDwPhy->DwPhyEnableFn != 0 )
    {
        uint32_t status = pDwPhy->DwPhyEnableFn( pDevInfo, Enable );
        return ( (status == 1) ? DWPHY_ERROR_DWPHYENABLE : DWPHY_SUCCESS );
    }
    return DWPHY_ERROR;
}
// end of DwPhy_Enable()

// ================================================================================================
// FUNCTION  : DwPhy_SetDwPhyEnableFn()
// ------------------------------------------------------------------------------------------------
// Purpose   : Provide a pointer to a function that controls DW_PHYEnB
// Parameters: pDevInfo       -- pointer to device information structure
//             pDwPhyEnableFn -- pointer to the function
// ================================================================================================
void DwPhy_SetDwPhyEnableFn (dwDevInfo_t *pDevInfo, DwPhyEnableFn_t pDwPhyEnableFn)
{
    DwPhy_t *pDwPhy = (DwPhy_t *)(pDevInfo->pDwPhy);
    pDwPhy->DwPhyEnableFn = pDwPhyEnableFn;
}
// end of DwPhy_SetDwPhyEnableFn()

// ================================================================================================
// FUNCTION  : DwPhy_RecordDefaultReg
// ------------------------------------------------------------------------------------------------
// Purpose   : Record the current state of register settings so these are available as defaults
//             in the device private information structure
// Parameters: pDevInfo     -- pointer to device information structure
// ================================================================================================
static void DwPhy_RecordDefaultReg (dwDevInfo_t *pDevInfo)
{
    DwPhy_t *pDwPhy = (DwPhy_t *)(pDevInfo->pDwPhy);

    switch ( DwPhy_BasebandID(pDevInfo) )
    {
        case DWPHY_BASEBAND_DAKOTA:
        case DWPHY_BASEBAND_DAKOTA2:
        case DWPHY_BASEBAND_DAKOTA2G:
        case DWPHY_BASEBAND_DAKOTA4:
            pDwPhy->RecordedDefaultReg.InitAGain    = DwPhy_ReadReg( 65) & 0x1F;
            pDwPhy->RecordedDefaultReg.ThSwitchLNA  = DwPhy_ReadReg( 71);
            pDwPhy->RecordedDefaultReg.Pwr100dBm    = DwPhy_ReadReg( 75);
            pDwPhy->RecordedDefaultReg.SyncTh       = DwPhy_ReadReg(121);
            pDwPhy->RecordedDefaultReg.DataIsValid  = 1;
            break;

        case DWPHY_BASEBAND_MOJAVE:
        case DWPHY_BASEBAND_MOJAVE1B:
        case DWPHY_BASEBAND_NEVADA_FPGA:
        case DWPHY_BASEBAND_NEVADA:
        case DWPHY_BASEBAND_NEVADA1B:
        default:
            pDwPhy->RecordedDefaultReg.InitAGain    = DwPhy_ReadReg( 65);
            pDwPhy->RecordedDefaultReg.ThSwitchLNA  = DwPhy_ReadReg( 73);
            pDwPhy->RecordedDefaultReg.ThSwitchLNA2 = DwPhy_ReadReg( 75);
            pDwPhy->RecordedDefaultReg.Pwr100dBm    = DwPhy_ReadReg( 77);
            pDwPhy->RecordedDefaultReg.ThCCA1       = DwPhy_ReadReg( 78);
            pDwPhy->RecordedDefaultReg.ThCCA2       = DwPhy_ReadReg( 79);
            pDwPhy->RecordedDefaultReg.ThCCA_SigDet = DwPhy_ReadReg(241);
            pDwPhy->RecordedDefaultReg.ThCCA_RSSI1  = DwPhy_ReadReg(242);
            pDwPhy->RecordedDefaultReg.ThCCA_RSSI2  = DwPhy_ReadReg(243);
            pDwPhy->RecordedDefaultReg.ThCCA_GF1    = DwPhy_ReadReg(244);
            pDwPhy->RecordedDefaultReg.ThCCA_GF2    = DwPhy_ReadReg(245);
            pDwPhy->RecordedDefaultReg.SyncTh       = DwPhy_ReadReg(121);
            pDwPhy->RecordedDefaultReg.DataIsValid  = 1;
    }
}
// end of DwPhy_RecordDefaultReg()

// ================================================================================================
// FUNCTION  : DwPhy_SetParameterData()
// ------------------------------------------------------------------------------------------------
// Purpose   : Program device-specific operating parameters
//             If an error occurs while setting the chipset alias, the previous value is retained;
//             for other parameters, any existing data is cleared.
// Parameters: pDevInfo   -- pointer to device information structure
//             pUserData  -- pointer to buffer containing parameter data record
// ================================================================================================
dwPhyStatus_t DwPhy_SetParameterData (dwDevInfo_t *pDevInfo, dwPhyParam_t Parameter, 
                                        uint32_t DataSize, uint8_t *pUserData)
{
    uint8_t *pData = NULL; // local copy of UserData
    DwPhy_t *pDwPhy = (DwPhy_t *)(pDevInfo->pDwPhy);
    dwPhyStatus_t status = DWPHY_SUCCESS;
    uint16_t i,j,k;

    if ((DataSize > 0) && (pUserData == NULL)) // check for non-zero length with NULL pointer
        return DWPHY_ERROR_PARAMETER4;

    switch (Parameter)
    {

        // Chipset Alias ----------------------------------------------------------------
        // ------------------------------------------------------------------------------
        case DWPHY_PARAM_CHIPSET_ALIAS:
        {
            uint8_t Data[4];
            
            switch (DataSize)
            {
                case 0: 
                    pDwPhy->ChipsetAlias = 0;
                    break;

                case 4:
                    // copy data from user space
                    if (OsCopyFromUser(Data, pUserData, DataSize) != 0)
                        status = DWPHY_ERROR_OSCOPYFROMUSER;
                    else
                    {
                        pDwPhy->ChipsetAlias = (Data[0]<< 0) | (Data[1]<< 8) 
                                             | (Data[2]<<16) | (Data[3]<<24);
                        pDwPhy->Chipset  =  pDwPhy->ChipsetAlias;
                        pDwPhy->Baseband =  pDwPhy->ChipsetAlias & 0xFF;
                        pDwPhy->Radio    = (pDwPhy->ChipsetAlias >> 8) & 0xFFFF;
                    }
                    break;

                default: status = DWPHY_ERROR_PARAMETER4;
            }
            break;
        }
            
        // Default Registers ------------------------------------------------------------
        // ------------------------------------------------------------------------------
        case DWPHY_PARAM_DEFAULTREGISTERS:
        {
            if (DataSize % 3) return DWPHY_ERROR_PARAMETER3; // size must be multiple of 3

            // free any existing parameter data
            if (pDwPhy->pDefaultReg != NULL)
            {
                OS_MemFree( pDwPhy->pDefaultReg, 
                            pDwPhy->DefaultRegLength * sizeof(dwPhyRegPair_t) );
                pDwPhy->pDefaultReg = NULL;
            }
            // size of new array                
            pDwPhy->DefaultRegLength = DataSize / 3;

            if (pDwPhy->DefaultRegLength > 0)
            {
                // allocate memory
                uint32_t MemorySize = pDwPhy->DefaultRegLength * sizeof(dwPhyRegPair_t);
                pDwPhy->pDefaultReg = (dwPhyRegPair_t *)OS_MemAlloc(MemorySize, 0);
                pData = OS_MemAlloc(DataSize, 0);

                if ((pDwPhy->pDefaultReg == NULL) || (pData == NULL))
                    status = DWPHY_ERROR_MEMORY_ALLOCATION;
                else
                {
                    if (OsCopyFromUser(pData, pUserData, DataSize) != 0)
                        status = DWPHY_ERROR_OSCOPYFROMUSER;
                    else
                    {
                        // parse the data record
                        for (i=0; i<pDwPhy->DefaultRegLength; i++)
                        {
                            k = 3*i;
                            pDwPhy->pDefaultReg[i].addr = pData[k+0] + 256*pData[k+1];
                            pDwPhy->pDefaultReg[i].data = pData[k+2];

                            if ( (pDwPhy->pDefaultReg[i].addr > 0x03FF && pDwPhy->pDefaultReg[i].addr < 0x8000)
                               ||(pDwPhy->pDefaultReg[i].addr > 0x80FF) ) 
                                status = DWPHY_ERROR_REGISTER_ADDR_RANGE;
                        }
                    }
                }
                // clear the temporary buffer (if allocated)
                if (pData) OS_MemFree( pData, DataSize );

                // error handling...assume the parameter data is invalid and remove
                if (status != DWPHY_SUCCESS)
                {
                    if (pDwPhy->pDefaultReg)
                        OS_MemFree( pDwPhy->pDefaultReg, 
                                    pDwPhy->DefaultRegLength * sizeof(dwPhyRegPair_t) );
                    pDwPhy->pDefaultReg = NULL;
                    pDwPhy->DefaultRegLength = 0;
                }
            }
            break;
        }
        
        // Registers By Band ------------------------------------------------------------
        // ------------------------------------------------------------------------------
        case DWPHY_PARAM_REGISTERSBYBAND:
        {
            if (DataSize % 12) return DWPHY_ERROR_PARAMETER3; // size must be multiple of 12
                
            // free any existing parameter data
            if (pDwPhy->pRegByBand != NULL)
            {
                OS_MemFree( pDwPhy->pRegByBand, 
                            pDwPhy->RegByBandLength * sizeof(dwPhyRegByBand_t) );
                pDwPhy->pRegByBand = NULL;
            }
            // size of the new array
            pDwPhy->RegByBandLength = DataSize / 12;

            if (pDwPhy->RegByBandLength > 0)
            {
                // allocate memory
                uint32_t MemorySize = pDwPhy->RegByBandLength * sizeof(dwPhyRegByBand_t);
                pDwPhy->pRegByBand = (dwPhyRegByBand_t *)OS_MemAlloc(MemorySize, 0);
                pData = OS_MemAlloc(DataSize, 0);

                if ((pDwPhy->pRegByBand == NULL) || (pData == NULL))
                    status = DWPHY_ERROR_MEMORY_ALLOCATION;
                else
                {
                    // copy data from user space
                    if (OsCopyFromUser(pData, pUserData, DataSize) != 0)
                        status = DWPHY_ERROR_OSCOPYFROMUSER;
                    else
                    {
                        // parse the data record
                        for (i=0; i<pDwPhy->RegByBandLength; i++)
                        {
                            k = 12*i;
                            pDwPhy->pRegByBand[i].Addr = pData[k+0] + 256*pData[k+1];
                            pDwPhy->pRegByBand[i].Mask = pData[k+2];
                            for (j=0; j<=8; j++)
                                pDwPhy->pRegByBand[i].Data[j] = pData[k+3+j];

                            if ( (pDwPhy->pRegByBand[i].Addr > 0x03FF && pDwPhy->pRegByBand[i].Addr < 0x8000)
                               ||(pDwPhy->pRegByBand[i].Addr > 0x80FF) ) 
                                status = DWPHY_ERROR_REGISTER_ADDR_RANGE;
                        }
                    }
                }

                // clear the temporary buffer (if allocated)
                if (pData) OS_MemFree( pData, DataSize );

                // error handling...assume the parameter data is invalid and remove
                if (status != DWPHY_SUCCESS)
                {
                    if (pDwPhy->pRegByBand)
                        OS_MemFree( pDwPhy->pRegByBand, 
                                    pDwPhy->RegByBandLength * sizeof(dwPhyRegByBand_t) );
                    pDwPhy->pRegByBand = NULL;
                    pDwPhy->RegByBandLength = 0;
                }
            }
            break;
        }

        // Registers By Channel ---------------------------------------------------------
        // ------------------------------------------------------------------------------
        case DWPHY_PARAM_REGISTERSBYCHANL:
        {
            if (DataSize % 259) return DWPHY_ERROR_PARAMETER3; // size must be multiple of 258
                
            // free any existing parameter data
            if (pDwPhy->pRegByChanl != NULL)
            {
                OS_MemFree( pDwPhy->pRegByChanl, 
                            pDwPhy->RegByChanlLength * sizeof(dwPhyRegByChanl_t) );
                pDwPhy->pRegByChanl = NULL;
            }
            // size of the new array
            pDwPhy->RegByChanlLength = DataSize / 259;

            if (pDwPhy->RegByChanlLength > 0)
            {
                // allocate memory
                uint32_t MemorySize = pDwPhy->RegByChanlLength * sizeof(dwPhyRegByChanl_t);
                pDwPhy->pRegByChanl = (dwPhyRegByChanl_t *)OS_MemAlloc(MemorySize, 0);
                pData = OS_MemAlloc(DataSize, 0);

                if ((pDwPhy->pRegByChanl == NULL) || (pData == NULL))
                    status = DWPHY_ERROR_MEMORY_ALLOCATION;
                else
                {
                    // copy data from user space
                    if (OsCopyFromUser(pData, pUserData, DataSize) != 0)
                        status = DWPHY_ERROR_OSCOPYFROMUSER;
                    else
                    {
                        // parse the data record
                        for (i=0; i<pDwPhy->RegByChanlLength; i++)
                        {
                            k = 259*i;
                            pDwPhy->pRegByChanl[i].Addr = pData[k+0] + 256*pData[k+1];
                            pDwPhy->pRegByChanl[i].Mask = pData[k+2];
                            for (j=0; j<256; j++)
                                pDwPhy->pRegByChanl[i].Data[j] = pData[k+3+j];

                            if ( (pDwPhy->pRegByChanl[i].Addr > 0x03FF && pDwPhy->pRegByChanl[i].Addr < 0x8000)
                               ||(pDwPhy->pRegByChanl[i].Addr > 0x80FF) ) 
                                status = DWPHY_ERROR_REGISTER_ADDR_RANGE;
                        }
                    }
                }
                // clear the temporary buffer (if allocated)
                if (pData) OS_MemFree( pData, DataSize );

                // error handling...assume the parameter data is invalid and remove
                if (status != DWPHY_SUCCESS)
                {
                    if (pDwPhy->pRegByChanl)
                        OS_MemFree( pDwPhy->pRegByChanl, 
                                    pDwPhy->RegByChanlLength * sizeof(dwPhyRegByChanl_t) );
                    pDwPhy->pRegByChanl = NULL;
                    pDwPhy->RegByChanlLength = 0;
                }
            }
            break;
        }
            
        // Registers By Channel, 2.4 GHz Band -------------------------------------------
        // ------------------------------------------------------------------------------
        case DWPHY_PARAM_REGISTERSBYCHANL24:
        {
            if (DataSize % 17) return DWPHY_ERROR_PARAMETER3; // size must be multiple of 17
                
            // free any existing parameter data
            if (pDwPhy->pRegByChanl24 != NULL)
            {
                OS_MemFree( pDwPhy->pRegByChanl24, 
                            pDwPhy->RegByChanl24Length * sizeof(dwPhyRegByChanl24_t) );
                pDwPhy->pRegByChanl24 = NULL;
            }
            // size of the new array
            pDwPhy->RegByChanl24Length = DataSize / 17;

            if (pDwPhy->RegByChanl24Length > 0)
            {
                // allocate memory
                uint32_t MemorySize = pDwPhy->RegByChanl24Length * sizeof(dwPhyRegByChanl24_t);
                pDwPhy->pRegByChanl24 = (dwPhyRegByChanl24_t *)OS_MemAlloc(MemorySize, 0);
                pData = OS_MemAlloc(DataSize, 0);

                if ((pDwPhy->pRegByChanl24 == NULL) || (pData == NULL))
                    status = DWPHY_ERROR_MEMORY_ALLOCATION;
                else
                {
                    // copy data from user space
                    if (OsCopyFromUser(pData, pUserData, DataSize) != 0)
                        status = DWPHY_ERROR_OSCOPYFROMUSER;
                    else
                    {
                        // parse the data record
                        for (i=0; i<pDwPhy->RegByChanl24Length; i++)
                        {
                            k = 17*i;
                            pDwPhy->pRegByChanl24[i].Addr = pData[k+0] + 256*pData[k+1];
                            pDwPhy->pRegByChanl24[i].Mask = pData[k+2];
                            for (j=0; j<14; j++)
                                pDwPhy->pRegByChanl24[i].Data[j] = pData[k+3+j];

                            if ( (pDwPhy->pRegByChanl24[i].Addr > 0x03FF && pDwPhy->pRegByChanl24[i].Addr < 0x8000)
                               ||(pDwPhy->pRegByChanl24[i].Addr > 0x80FF) ) 
                                status = DWPHY_ERROR_REGISTER_ADDR_RANGE;
                        }
                    }
                }
                // clear the temporary buffer (if allocated)
                if (pData) OS_MemFree( pData, DataSize );

                // error handling...assume the parameter data is invalid and remove
                if (status != DWPHY_SUCCESS)
                {
                    if (pDwPhy->pRegByChanl24)
                        OS_MemFree( pDwPhy->pRegByChanl24, 
                                    pDwPhy->RegByChanl24Length * sizeof(dwPhyRegByChanl24_t) );
                    pDwPhy->pRegByChanl24 = NULL;
                    pDwPhy->RegByChanl24Length = 0;
                }
            }
            break;
        }

        // Default: Unrecognized Parameter Value ----------------------------------------
        // ------------------------------------------------------------------------------
        default: status = DWPHY_ERROR_UNDEFINED_CASE;
    }

    return status;
}
// end of DwPhy_SetParameterData()

// ================================================================================================
// FUNCTION  : DwPhy_ReadReg()
// ------------------------------------------------------------------------------------------------
// Purpose   : Read the specified PHY register
// Parameters: Addr -- Register address. To access an indirect radio register, set Addr as follows
//                     Addr = (0x8000 | Index of indirect register)
// ================================================================================================
uint8_t DwPhy_ReadReg(uint32_t Addr)
{
    if (Addr & 0x8000)  // 0x8000 - 0x80FF are indirect radio registers
    {
        OS_RegWriteBB(256+126, Addr & 0xFF);
        return OS_RegReadBB(256+127);     
    }
    else
        return OS_RegReadBB(Addr);
}
// end of DwPhy_ReadReg()

// ================================================================================================
// FUNCTION  : DwPhy_WriteReg()
// ------------------------------------------------------------------------------------------------
// Purpose   : Write the specified PHY register
// Parameters: Addr -- Register address. To access an indirect radio register, set Addr as follows
//                     Addr = (0x8000 | Index of indirect register)
//             Data -- Value to be written 
// ================================================================================================
void DwPhy_WriteReg(uint32_t Addr, uint8_t Data)
{
    if (Addr & 0x8000) // 0x8000 - 0x80FF are indirect radio registers
    {
        OS_RegWriteBB(256+126, Addr & 0xFF);
        OS_RegWriteBB(256+127, Data);     
    }
    else
        OS_RegWriteBB(Addr, Data);
}
// end of DwPhy_WriteReg()

// ================================================================================================
// FUNCTION  : DwPhy_WriteRegBit()
// ------------------------------------------------------------------------------------------------
// Purpose   : Modify a single bit in an 8-bit wide register field (i.e., read-modify-write)
// Parameters: Addr     -- Register address
//             Bit      -- Bit position {7=MSB, 0=LSB}
//             BitValue -- {0, 1}
// ================================================================================================
void DwPhy_WriteRegBit(uint32_t Addr, uint8_t Bit, uint8_t BitValue)
{
    uint8_t data = DwPhy_ReadReg( Addr );
    uint8_t mask = 1<<Bit;

    data = BitValue ? (data | mask) : (data & (0xFF^mask));
    DwPhy_WriteReg(Addr, data);
}
// end of DwPhy_WriteRegBit()

// ================================================================================================
// FUNCTION  : DwPhy_WriteRegByField()
// ------------------------------------------------------------------------------------------------
// Purpose   : Write a register field by value
// Parameters: Addr      -- Register address
//             FieldMask -- Field to write
//             FieldData -- Data to write (or'ed with read data, so already shifted)
// ================================================================================================
void DwPhy_WriteRegField(uint32_t Addr, uint8_t FieldMask, uint8_t FieldData)
{
    uint8_t Data = DwPhy_ReadReg( Addr );

    Data = (Data & (0xFF ^ FieldMask)) | FieldData;
    DwPhy_WriteReg(Addr, Data);
}
// end of DwPhy_WriteRegField()

// ================================================================================================
// FUNCTION  : DwPhy_ChipSet()
// ------------------------------------------------------------------------------------------------
// Purpose   : Returns the chipset code and records the device IDs in the DevInfo structure
// Parameters: pDevInfo -- pointer to device information structure
// Returns   : chipset with the baseband ID in the lower byte and the radio ID next
// ================================================================================================
uint32_t DwPhy_ChipSet(dwDevInfo_t *pDevInfo)
{
    DwPhy_t *pDwPhy = (DwPhy_t *)(pDevInfo->pDwPhy);

    if (pDwPhy->ChipsetAlias == 0)
    {
        pDwPhy->Baseband = (int32_t)DwPhy_ReadReg(    1);
        pDwPhy->Radio    = (int32_t)DwPhy_ReadReg(256+1);
        pDwPhy->Chipset  = (pDwPhy->Radio << 8) | pDwPhy->Baseband;
    }
    return pDwPhy->Chipset;
}
// end of DwPhy_ChipSet()

// ================================================================================================
// FUNCTION  : DwPhy_BasebandID()
// ------------------------------------------------------------------------------------------------
// Purpose   : Returns the baseband ID
// Parameters: pDevInfo -- pointer to device information structure
// Returns   : enumeration of baseband ID (matched physical register ID value)
// ================================================================================================
dwPhyBaseband_t DwPhy_BasebandID(dwDevInfo_t *pDevInfo)
{
    DwPhy_t *pDwPhy = (DwPhy_t *)(pDevInfo->pDwPhy);

    if (!pDwPhy->Chipset) DwPhy_ChipSet(pDevInfo);
    return (dwPhyBaseband_t)(pDwPhy->Baseband);
}
// end of DwPhy_BasebandID()

// ================================================================================================
// FUNCTION  : DwPhy_RadioID()
// ------------------------------------------------------------------------------------------------
// Purpose   : Returns the radio ID
// Parameters: pDevInfo -- pointer to device information structure
// Returns   : enumeration of radio ID (matched physical register ID value)
// ================================================================================================
dwPhyRadio_t DwPhy_RadioID(dwDevInfo_t *pDevInfo)
{
    DwPhy_t *pDwPhy = (DwPhy_t *)(pDevInfo->pDwPhy);

    if (!pDwPhy->Chipset) DwPhy_ChipSet(pDevInfo);
    return (dwPhyRadio_t)(pDwPhy->Radio);
}
// end of DwPhy_RadioID()

// ================================================================================================
// FUNCTION  : DwPhy_PLLAsyncReset()
// ------------------------------------------------------------------------------------------------
// Purpose   : Reset the radio PLL (Basie: required after power up or channel change)
// Parameters: pDevInfo -- pointer to device information structure
// ================================================================================================
void DwPhy_PLLAsyncReset(dwDevInfo_t *pDevInfo)
{
    #ifdef DWPHY_SUPPORT_BERMAI

        DwPhy_t *pDwPhy = (DwPhy_t *)(pDevInfo->pDwPhy);
    
        if((pDwPhy->Radio >= DWPHY_RADIO_BASIE_A1) 
        && (pDwPhy->Radio <= DWPHY_RADIO_BASIE_D3))
        {
            uint8_t u;
            u=DwPhy_ReadReg(256+17);
            DwPhy_WriteReg (256+17, u|0x80); // toggle DIVNTST (msb of Basie register 17)
            DwPhy_WriteReg (256+17, u&0x7F);
        }
    #endif
}
// end of DwPhy_PLLAsyncReset()

// ================================================================================================
// FUNCTION  : DwPhy_RF52B21_ToggleSTARTO
// ------------------------------------------------------------------------------------------------
// Purpose   : Work-around to TX ALC bug in RF52B21
// Parameters: pDevInfo -- pointer to device information structure
// ================================================================================================
dwPhyStatus_t DwPhy_RF52B21_ToggleSTARTO(dwDevInfo_t *pDevInfo)
{
    DwPhy_t *pDwPhy = (DwPhy_t *)(pDevInfo->pDwPhy);

    if (pDwPhy->Radio == DWPHY_RADIO_RF52B21)
    {    
        uint8_t X = DwPhy_ReadReg(256+68);
    
        DwPhy_WriteReg(256+68, X | 0x08);
        DwPhy_WriteReg(256+68, X & 0xF7);
    }
    return DWPHY_SUCCESS;
}
// end of DwPhy_RF52B21_ToggleSTARTO()

// ================================================================================================
// FUNCTION  : DwPhy_GetHistogramRPI()
// ------------------------------------------------------------------------------------------------
// Purpose   : Compute the RPI Histogram
// Parameters: pDevInfo   -- pointer to device information structure
//             NumSamples -- number of samples (slightly more than 1 TU (microsecond) per point)
//             Density    -- RPI histogram per 802.11h Section 7.3.2.22.3 (output)
// ================================================================================================
dwPhyStatus_t DwPhy_GetHistogramRPI(dwDevInfo_t *pDevInfo, uint16_t NumSamples, uint8_t Density[8])
{
    DwPhy_t *pDwPhy = (DwPhy_t *)(pDevInfo->pDwPhy);

    if (pDwPhy->Baseband >= DWPHY_BASEBAND_MOJAVE  )
    {
        uint16_t i, k;
        uint8_t Reg80, Reg103, p, p0, p1, RxPath;
        uint32_t Divider, CountRPI[8] = {0,0,0,0,0,0,0,0};

        if(!(DwPhy_ReadReg(4) & 1)) return DWPHY_ERROR; // currently only works for 802.11a/g mode

        RxPath = DwPhy_ReadReg(  3); // get RxPath value

        Reg80  = DwPhy_ReadReg( 80); // save registers 80, 103 because they need to be modified for
        Reg103 = DwPhy_ReadReg(103); // ...this test

        DwPhy_WriteReg( 80, 0x0E);          // shut down signal detect, digital amp, frame sync
        DwPhy_WriteReg(103, 0xC0 | Reg103); // switch to fixed gain

        DwPhy_Delay(100);  // Delay to allow gain to settle. There is nothing to guarantee we were not
                           // receving a packet. Future devices should include a read-back for the DFE
                           // state. Alternately, we could force a PacketRestart event.
        
        // ---------------------------------
        // Collect Power Measurement Samples
        // ---------------------------------
        for(i=0; i<NumSamples; i++)
        {
            DwPhy_Delay(1);        // wait 1 microsecond between measurements

            p0 = (uint8_t)( (RxPath & 1) ? DwPhy_ReadReg(22) : 0 ); // power for antenna 0
            p1 = (uint8_t)( (RxPath & 2) ? DwPhy_ReadReg(23) : 0 ); // power for antenna 1
            p  = (uint8_t)( (p0 > p1) ? p0:p1 );  // select strongest signal, p = (Pr[dBm]+100)*4/3

                 if(p < 17) k = 0; //           Pr < -87 dBm
            else if(p < 24) k = 1; // -87 dBm < Pr < -82 dBm
            else if(p < 31) k = 2; // -82 dBm < Pr < -77 dBm
            else if(p < 37) k = 3; // -77 dBm < Pr < -72 dBm
            else if(p < 44) k = 4; // -72 dBm < Pr < -67 dBm
            else if(p < 51) k = 5; // -67 dBm < Pr < -62 dBm
            else if(p < 57) k = 6; // -62 dBm < Pr < -57 dBm
            else            k = 7; // -57 dBm < Pr
            
            CountRPI[k]++;
        }
        // -------------------------
        // Compute Histogram/Density
        // -------------------------
        Divider = (uint32_t)NumSamples << 10; // 1024 * NumSamples
        for(k=0; k<8; k++)
        {
            Density[k] = (uint8_t)((255 * CountRPI[k] + Divider - 1) / Divider); // ceil(255 * CountRPI/Divider)
        }         
        // -------------------------
        // Restore Register Settings
        // -------------------------
        DwPhy_WriteReg(103, Reg103);
        DwPhy_WriteReg( 80, Reg80);

        return DWPHY_SUCCESS;
    }
    return DWPHY_ERROR_UNSUPPORTED_CHIPSET;
}
// end of DwPhy_GetHistogramRPI()

// ================================================================================================
// FUNCTION  : DwPhy_RadarDetect()
// ------------------------------------------------------------------------------------------------
// Purpose   : Enabled/disable DFS radar detection
// Parameters: pDevInfo -- pointer to device information structure
//             Enable   -- (0=disable; otherwise enabled)
// ================================================================================================
dwPhyStatus_t DwPhy_RadarDetect(dwDevInfo_t *pDevInfo, uint8_t Enable)
{
    DwPhy_t *pDwPhy = (DwPhy_t *)(pDevInfo->pDwPhy);

    if (pDwPhy->Baseband >= DWPHY_BASEBAND_MOJAVE)
    {
        if(Enable) DwPhy_WriteRegBit(87, 7, 1); // set   DFSOn bit
        else       DwPhy_WriteRegBit(87, 7, 0); // clear DFSOn bit
    }
    else return DWPHY_ERROR_UNSUPPORTED_BASEBAND;

    return DWPHY_SUCCESS;
}
// end of DwPhy_RadarDetect()

// ================================================================================================
// FUNCTION  : DwPhy_AddressFilter()
// ------------------------------------------------------------------------------------------------
// Purpose   : Enabled/disable buisance packet addressfiltering
// Parameters: pDevInfo -- pointer to device information structure
//             Enable   -- (0=disable; otherwise enabled)
// Notes     : The station address must be programmed (once) before the filter is enabled
// ================================================================================================
dwPhyStatus_t DwPhy_AddressFilter(dwDevInfo_t *pDevInfo, uint8_t Enable)
{
    DwPhy_t *pDwPhy = (DwPhy_t *)(pDevInfo->pDwPhy);

    if(pDwPhy->Baseband >= DWPHY_BASEBAND_MOJAVE)
    {
        if(Enable) DwPhy_WriteRegBit(198, 0, 1); // set AddrFilter bit
        else       DwPhy_WriteRegBit(198, 0, 0); // clear AddrFilter bit
    }
    else return DWPHY_ERROR_UNSUPPORTED_BASEBAND;

    return DWPHY_SUCCESS;
}
// end of DwPhy_AddressFilter()

// ================================================================================================
// FUNCTION  : DwPhy_SetDiversityMode()
// ------------------------------------------------------------------------------------------------
// Purpose   : Select the RX diversity mode
// Parameters: pDevInfo      -- pointer to device information structure
//             DiversityMode -- mode selection
// ================================================================================================
dwPhyStatus_t DwPhy_SetDiversityMode(dwDevInfo_t *pDevInfo, dwPhyDiversityMode_t DiversityMode)
{
    switch( DwPhy_ChipSet(pDevInfo) )
    {
        // DakotaX + BasieX -----------------------------------------
        //
        case CHIPSET( DWPHY_BASEBAND_DAKOTA2,  DWPHY_RADIO_BASIE_C1 ):
        case CHIPSET( DWPHY_BASEBAND_DAKOTA2,  DWPHY_RADIO_BASIE_C2 ):
        case CHIPSET( DWPHY_BASEBAND_DAKOTA2,  DWPHY_RADIO_BASIE_C3 ):
        case CHIPSET( DWPHY_BASEBAND_DAKOTA2G, DWPHY_RADIO_BASIE_C1 ):
        case CHIPSET( DWPHY_BASEBAND_DAKOTA2G, DWPHY_RADIO_BASIE_C2 ):
        case CHIPSET( DWPHY_BASEBAND_DAKOTA2G, DWPHY_RADIO_BASIE_C3 ):
        case CHIPSET( DWPHY_BASEBAND_DAKOTA4,  DWPHY_RADIO_BASIE_C1 ):
        case CHIPSET( DWPHY_BASEBAND_DAKOTA4,  DWPHY_RADIO_BASIE_C2 ):
        case CHIPSET( DWPHY_BASEBAND_DAKOTA4,  DWPHY_RADIO_BASIE_C3 ):
        {
            switch( DiversityMode )
            {
                case DWPHY_DIVERSITY_PATH_A:
                {
                    DwPhy_WriteReg(    3, 1); // Baseband RXA->Path 0
                    DwPhy_WriteReg(256+5, 1); // Radio RXA
                    break;
                }
                case DWPHY_DIVERSITY_PATH_B:
                {
                    DwPhy_WriteReg(    3, 5); // Baseband RXB->Path 0
                    DwPhy_WriteReg(256+5, 2); // Radio RXB
                    break;
                }
                case DWPHY_DIVERSITY_DEFAULT:
                case DWPHY_DIVERSITY_MRC:
                {
                    DwPhy_WriteReg(    3, 3); // Baseband Both Paths
                    DwPhy_WriteReg(256+5, 3); // Radio Both Paths
                    break;
                }
                default: return DWPHY_ERROR_UNDEFINED_CASE;
            }
            break;
        }

        // Mojave/Nevada + RF52xxx ----------------------------------
        //
        case CHIPSET( DWPHY_BASEBAND_MOJAVE,     DWPHY_RADIO_NONE     ):
        case CHIPSET( DWPHY_BASEBAND_MOJAVE,     DWPHY_RADIO_RF52A120 ):
        case CHIPSET( DWPHY_BASEBAND_MOJAVE,     DWPHY_RADIO_RF52A321 ):
        case CHIPSET( DWPHY_BASEBAND_MOJAVE,     DWPHY_RADIO_RF52A421 ):
        case CHIPSET( DWPHY_BASEBAND_MOJAVE,     DWPHY_RADIO_RF52A521 ):
        case CHIPSET( DWPHY_BASEBAND_MOJAVE,     DWPHY_RADIO_RF52B21  ):
        case CHIPSET( DWPHY_BASEBAND_MOJAVE,     DWPHY_RADIO_RF52B31  ):
        case CHIPSET( DWPHY_BASEBAND_MOJAVE1B,   DWPHY_RADIO_NONE     ):
        case CHIPSET( DWPHY_BASEBAND_MOJAVE1B,   DWPHY_RADIO_RF52A120 ):
        case CHIPSET( DWPHY_BASEBAND_MOJAVE1B,   DWPHY_RADIO_RF52A321 ):
        case CHIPSET( DWPHY_BASEBAND_MOJAVE1B,   DWPHY_RADIO_RF52A421 ):
        case CHIPSET( DWPHY_BASEBAND_MOJAVE1B,   DWPHY_RADIO_RF52A521 ):
        case CHIPSET( DWPHY_BASEBAND_MOJAVE1B,   DWPHY_RADIO_RF52B21  ):
        case CHIPSET( DWPHY_BASEBAND_MOJAVE1B,   DWPHY_RADIO_RF52B31  ):
        case CHIPSET( DWPHY_BASEBAND_NEVADA_FPGA,DWPHY_RADIO_NONE     ):
        case CHIPSET( DWPHY_BASEBAND_NEVADA_FPGA,DWPHY_RADIO_RF52B31  ):
        case CHIPSET( DWPHY_BASEBAND_NEVADA,     DWPHY_RADIO_NONE     ):
        case CHIPSET( DWPHY_BASEBAND_NEVADA,     DWPHY_RADIO_RF52B31  ):
        case CHIPSET( DWPHY_BASEBAND_NEVADA1B,   DWPHY_RADIO_NONE     ):
        case CHIPSET( DWPHY_BASEBAND_NEVADA1B,   DWPHY_RADIO_RF52B31  ):
        {
            switch( DiversityMode )
            {
                case DWPHY_DIVERSITY_PATH_A:
                {
                    DwPhy_WriteReg(    3, 1); // Baseband RXA
                    DwPhy_WriteReg(256+2, 1); // Radio RXA
                    break;   
                }
                case DWPHY_DIVERSITY_PATH_B:
                {
                    DwPhy_WriteReg(    3, 2); // Baseband RXB
                    DwPhy_WriteReg(256+2, 2); // Radio RXB
                    break;   
                }
                case DWPHY_DIVERSITY_DEFAULT:
                case DWPHY_DIVERSITY_MRC:
                {
                    DwPhy_WriteReg(    3, 3); // Baseband Both Paths
                    DwPhy_WriteReg(256+2, 3); // Radio Both Paths
                    break;   
                }
                default: return DWPHY_ERROR_UNDEFINED_CASE;
            }
            break;
        }

        // Mojave + RF22xxx ----------------------------------
        //        
        case CHIPSET( DWPHY_BASEBAND_MOJAVE1B,    DWPHY_RADIO_RF22A01 ):
        case CHIPSET( DWPHY_BASEBAND_MOJAVE1B,    DWPHY_RADIO_RF22A02 ):
        case CHIPSET( DWPHY_BASEBAND_MOJAVE1B,    DWPHY_RADIO_RF22A11 ):
        case CHIPSET( DWPHY_BASEBAND_MOJAVE1B,    DWPHY_RADIO_RF22A12 ):            
        {
            switch( DiversityMode )
            {
                case DWPHY_DIVERSITY_PATH_A:
                case DWPHY_DIVERSITY_DEFAULT:
                case DWPHY_DIVERSITY_MRC:
                {
                    DwPhy_WriteReg(  3,   2); // only baseband path 1 is valid
                    DwPhy_WriteReg(228,  15);
                    break;   
                }
                case DWPHY_DIVERSITY_PATH_B:
                {
                    DwPhy_WriteReg(  3,   2); // only baseband path 1 is valid
                    DwPhy_WriteReg(228, 240);
                    break;   
                }
                default: return DWPHY_ERROR_UNDEFINED_CASE;
            }
            break;
        }
        
        // Nevada + RF22xxx ----------------------------------
        //
        case CHIPSET( DWPHY_BASEBAND_NEVADA_FPGA, DWPHY_RADIO_RF22A11 ):            
        case CHIPSET( DWPHY_BASEBAND_NEVADA_FPGA, DWPHY_RADIO_RF22A12 ):
        case CHIPSET( DWPHY_BASEBAND_NEVADA     , DWPHY_RADIO_RF22A11 ):            
        case CHIPSET( DWPHY_BASEBAND_NEVADA     , DWPHY_RADIO_RF22A12 ):
        case CHIPSET( DWPHY_BASEBAND_NEVADA     , DWPHY_RADIO_RF22B02 ):            
        case CHIPSET( DWPHY_BASEBAND_NEVADA1B   , DWPHY_RADIO_RF22A11 ):            
        case CHIPSET( DWPHY_BASEBAND_NEVADA1B   , DWPHY_RADIO_RF22A12 ):
        case CHIPSET( DWPHY_BASEBAND_NEVADA1B   , DWPHY_RADIO_RF22B02 ):            
        default:
        {
            switch( DiversityMode )
            {
                case DWPHY_DIVERSITY_PATH_A:
                case DWPHY_DIVERSITY_DEFAULT:
                case DWPHY_DIVERSITY_MRC:
                {
                    DwPhy_WriteReg(  3,   2); // only baseband path 1 is valid
                    DwPhy_WriteReg(228, 195);
                    DwPhy_WriteRegBit(107, 7, 0); // disable antenna selection
                    break;   
                }
                case DWPHY_DIVERSITY_PATH_B:
                {
                    DwPhy_WriteReg(  3,   2); // only baseband path 1 is valid
                    DwPhy_WriteReg(228,  60);
                    DwPhy_WriteRegBit(107, 7, 0); // disable antenna selection
                    break;   
                }
                case DWPHY_DIVERSITY_ANTSEL:
                {
                    DwPhy_WriteReg(  3,   2); // only baseband path 1 is valid
                    DwPhy_WriteReg(228,  195);		    	
	                DwPhy_WriteRegBit(107, 7, 1); // enable antenna selection
	                break;
                }
                default: return DWPHY_ERROR_UNDEFINED_CASE;
            }
            break;
        }
    }
    return DWPHY_SUCCESS;
}
// end of DwPhy_SetDiversityMode()

// ================================================================================================
// FUNCTION  : DwPhy_ConvertHeaderRSSI()
// ------------------------------------------------------------------------------------------------
// Purpose   : Convert raw RSSI values reported in the header to the form RSSI = Pr[dBm] + 100
// Parameters: pDevInfo -- pointer to device information structure
//             pRSSI0   -- value for antenna path 0 (input & output)
//             pRSSI1   -- value for antenna path 1 (input & output)
// ================================================================================================
dwPhyStatus_t DwPhy_ConvertHeaderRSSI(dwDevInfo_t *pDevInfo, uint8_t *pRSSI0, uint8_t *pRSSI1)
{
    DwPhy_t *pDwPhy = (DwPhy_t *)(pDevInfo->pDwPhy);

    if (pDwPhy->RxSensitivity.DataIsValid && pDwPhy->RxSensitivity.MsrPwrOfs)
    {
        *pRSSI0 = *pRSSI0 + pDwPhy->RxSensitivity.MsrPwrOfs;
        *pRSSI1 = *pRSSI1 + pDwPhy->RxSensitivity.MsrPwrOfs;
    }
    return DWPHY_SUCCESS;
}
// end of DwPhy_ConvertHeaderRSSI()

// ================================================================================================
// FUNCTION  : DwPhy_SetStationAddress()
// ------------------------------------------------------------------------------------------------
// Purpose   : Program the station address for nuisance packet filtering
// Parameters: pDevInfo -- pointer to device information structure
//             Addr     -- MAC (station) address
// ================================================================================================
dwPhyStatus_t DwPhy_SetStationAddress(dwDevInfo_t *pDevInfo, uint8_t Addr[6])
{
    DwPhy_t *pDwPhy = (DwPhy_t *)(pDevInfo->pDwPhy);

    if(pDwPhy->Baseband >= DWPHY_BASEBAND_MOJAVE)
    {
        DwPhy_WriteReg(199, Addr[0]); // Need to verify byte order
        DwPhy_WriteReg(200, Addr[1]);
        DwPhy_WriteReg(201, Addr[2]);
        DwPhy_WriteReg(202, Addr[3]);
        DwPhy_WriteReg(203, Addr[4]);
        DwPhy_WriteReg(204, Addr[5]);
    }
    else return DWPHY_ERROR_UNSUPPORTED_BASEBAND;

    return DWPHY_SUCCESS;
}
// end of DwPhy_SetStationAddress()

// ================================================================================================
// FUNCTION  : DwPhy_CalibrateVCO()
// ------------------------------------------------------------------------------------------------
// Purpose   : VCO Calibration (Basie only; does not work with Armstrong)
// Parameters: pDevInfo -- pointer to device information structure
// ================================================================================================
void DwPhy_CalibrateVCO(dwDevInfo_t *pDevInfo)
{
    #ifdef DWPHY_SUPPORT_BERMAI

        DwPhy_t *pDwPhy = (DwPhy_t *)(pDevInfo->pDwPhy);

        if(pDwPhy->Radio >= DWPHY_RADIO_BASIE_A1  // only applies to Basie A1-C3
        && pDwPhy->Radio <= DWPHY_RADIO_BASIE_C3) 
        {
            uint8_t u;
            u=DwPhy_ReadReg(256+102);
            DwPhy_WriteReg( 256+102, u|0x02); // set b1 to trigger VCO calibration
            DwPhy_WriteReg( 256+102, u&0xFD); // clear b1
        }

    #endif
}
// end of DwPhy_CalibrateVCO()

// ================================================================================================
// FUNCTION  : DwPhy_SetChannel_Basie()
// ------------------------------------------------------------------------------------------------
// Purpose   : Set channel for BER5000 (Basie)...Called from DwPhy_SetChannelFreq()
// ================================================================================================
static dwPhyStatus_t DwPhy_SetChannel_Basie(dwDevInfo_t *pDevInfo, uint8_t ChanNum)
{
    #ifdef DWPHY_SUPPORT_BERMAI

        // Restrict to decodable channel number
        //
        if(ChanNum<32 || ChanNum>201) 
            return DWPHY_ERROR_UNSUPPORTED_CHANNEL;

        // Implement channel change
        //
        DwPhy_WriteReg(256+2, ChanNum);  // write the channel #
        DwPhy_PLLAsyncReset(pDevInfo);   // reset the RF PLL
        DwPhy_CalibrateVCO(pDevInfo);    // start VCO calibration
        DwPhy_Delay(40);                 // wait 40us to allow the PLL to settle

    #endif
    return DWPHY_SUCCESS;
}
// end of DwPhy_SetChannel_Basie()

// ================================================================================================
// FUNCTION  : DwPhy_CalibrateDataConv
// ------------------------------------------------------------------------------------------------
// Purpose   : Calibrate the DW52MB ADCs. This may be needed if the receiver is active for a long
//             time without either a power save or transmit event. Initiating calibration while
//             a packet is being received may cause it to be corrupted.
// Parameters: pDevInfo -- pointer to device information structure
// ================================================================================================
void DwPhy_CalibrateDataConv(dwDevInfo_t *pDevInfo)
{
    switch ( DwPhy_BasebandID(pDevInfo) )
    {
        case DWPHY_BASEBAND_MOJAVE:
        case DWPHY_BASEBAND_MOJAVE1B:
        case DWPHY_BASEBAND_NEVADA:
        case DWPHY_BASEBAND_NEVADA1B:

            DwPhy_WriteRegBit(233, 0, 1); // pulse FCAL high
            DwPhy_WriteRegBit(233, 0, 0); // initiate calibration on FCAL falling edge
            break;

        default:
            ; // nothing to do
    }
}
// end of DwPhy_CalibrateDataConv()

// ================================================================================================
// FUNCTION  : DwPhy_ClearCounters()
// ------------------------------------------------------------------------------------------------
// Purpose   : Clear Mojave performance counters
// Parameters: pDevInfo  -- pointer to device information structure
// ================================================================================================
dwPhyStatus_t DwPhy_ClearCounters(dwDevInfo_t *pDevInfo)
{
    switch ( DwPhy_BasebandID(pDevInfo) )
    {
        case DWPHY_BASEBAND_MOJAVE:
        case DWPHY_BASEBAND_MOJAVE1B:
        case DWPHY_BASEBAND_NEVADA_FPGA:
        case DWPHY_BASEBAND_NEVADA:
        case DWPHY_BASEBAND_NEVADA1B:
        default:

            DwPhy_WriteRegBit(197, 0, 1);
            DwPhy_WriteRegBit(197, 0, 0);
            break;
    }
    return DWPHY_SUCCESS;            
}
// end of DwPhy_ClearCounters()

// ================================================================================================
// FUNCTION  : DwPhy_GetRxCounters()
// ------------------------------------------------------------------------------------------------
// Purpose   : Retrieve Mojave RX performance counters. These count 0-255 and hold once they reach
//             255. The counters are reset by calling DwPhy_ClearCounters(). If not all counters
//             are needed, pass NULL for the unneeded value pointers.
// Parameters: pDevInfo       -- pointer to device information structure
//             pRxFaultCount  -- returns number of RxFault events (OFDM preamble, invalid PLCP hdr)
//             pRestartCount  -- returns number of RX abort/restart events
//             pNuisanceCount -- returns number of nuisance packets filtered
// ================================================================================================
dwPhyStatus_t DwPhy_GetRxCounters( dwDevInfo_t *pDevInfo,  uint8_t *pRxFaultCount, 
                                   uint8_t *pRestartCount, uint8_t *pNuisanceCount )
{
    switch ( DwPhy_BasebandID(pDevInfo) )
    {
        case DWPHY_BASEBAND_MOJAVE:
        case DWPHY_BASEBAND_MOJAVE1B:
        case DWPHY_BASEBAND_NEVADA:
        case DWPHY_BASEBAND_NEVADA1B:

            if (pRxFaultCount) *pRxFaultCount  = DwPhy_ReadReg(194);
            if (pRestartCount) *pRestartCount  = DwPhy_ReadReg(195);
            if (pNuisanceCount)*pNuisanceCount = DwPhy_ReadReg(196);
            break;

        default:

            if (pRxFaultCount)  *pRxFaultCount  = 0;
            if (pRestartCount)  *pRestartCount  = 0;
            if (pNuisanceCount) *pNuisanceCount = 0;
            return DWPHY_ERROR_UNSUPPORTED_CHIPSET;
            break;
    }
    return DWPHY_SUCCESS;
}
// end of DwPhy_GetRxCounters()

// ================================================================================================
// FUNCTION  : DwPhy_SetMaxLength()
// ------------------------------------------------------------------------------------------------
// Purpose   : Define the maximum OFDM PSDU length (bytes). The actual value may be rounded up.
// Parameters: pDevInfo  -- pointer to device information structure
//             MaxLength -- maximum PSDU length (includes 4 byte FCS)
// ================================================================================================
dwPhyStatus_t DwPhy_SetMaxLength(dwDevInfo_t *pDevInfo, uint32_t MaxLength)
{
    if (MaxLength > 4095) return DWPHY_ERROR_PARAMETER2; // out of range
    DwPhy_WriteReg( 24, (MaxLength + 15)/16 );

    return DWPHY_SUCCESS;
}
// end of DwPhy_SetMaxLength()

// ================================================================================================
// FUNCTION  : DwPhy_RadioPllIsLocked()
// ------------------------------------------------------------------------------------------------
// Purpose   : Indicates whether the radio PLL is locked (diagnostic)
// Parameters: pDevInfo -- pointer to device information structure
// Returns   : 1 -- Pll is locked (or unsupported chipset)
//             0 -- Pll is not locked
// ================================================================================================
int32_t DwPhy_RadioPllIsLocked(dwDevInfo_t *pDevInfo)
{
    DwPhy_t *pDwPhy = (DwPhy_t *)(pDevInfo->pDwPhy);

    if (pDwPhy->Radio >= DWPHY_RADIO_BASIE_C1 && pDwPhy->Radio <= DWPHY_RADIO_BASIE_C3)
    {
        return ( (DwPhy_ReadReg(256+49) & 0x01) ? 1 : 0 );
    }
    if (pDwPhy->Radio >= DWPHY_RADIO_RF52A01)
    {
        return ( (DwPhy_ReadReg(256+41) & 0x80) ? 1 : 0 );
    }
    return 1; // default...no error condition
}
// end of DwPhy_RadioPllIsLocked()

// ================================================================================================
// FUNCTION  : DwPhy_WakeupTime()
// ------------------------------------------------------------------------------------------------
// Purpose   : Returns the time from DW_PHYEnB assertion to PHY active
// Parameters: pDevInfo -- pointer to device information structure
// Returns   : WakeupTime (units: microseconds)
// ================================================================================================
uint16_t DwPhy_WakeupTime(dwDevInfo_t *pDevInfo)
{
    uint16_t WakeupTime = 0;
 
    switch( DwPhy_BasebandID(pDevInfo) )
    {
        case DWPHY_BASEBAND_DAKOTA:
        case DWPHY_BASEBAND_DAKOTA2:
        case DWPHY_BASEBAND_DAKOTA2G:
        case DWPHY_BASEBAND_DAKOTA4:
            WakeupTime = 0; break;

        case DWPHY_BASEBAND_MOJAVE:
        case DWPHY_BASEBAND_MOJAVE1B:
        case DWPHY_BASEBAND_NEVADA:            
        case DWPHY_BASEBAND_NEVADA1B:
        case DWPHY_BASEBAND_NEVADA_FPGA:
        default:
            WakeupTime = ( ( DwPhy_ReadReg( 208 ) << 8) | DwPhy_ReadReg( 209 ) );
            break;
    }
    return( WakeupTime );
}
// end of DwPhy_WakeupTime()

// ================================================================================================
// FUNCTION  : DwPhy_EnablePowerAmpByBand()
// ------------------------------------------------------------------------------------------------
// Purpose   : Program the baseband power amplifier enable signals based on the frequency band
// Parameters: pDevInfo   -- pointer to device information structure
//             Band       -- band number (0-8)
// ================================================================================================
static void DwPhy_EnablePowerAmpByBand( dwDevInfo_t *pDevInfo, uint8_t Band )
{
    switch ( DwPhy_BasebandID(pDevInfo) )
    {
        case DWPHY_BASEBAND_DAKOTA:
        case DWPHY_BASEBAND_DAKOTA2:
        case DWPHY_BASEBAND_DAKOTA2G:
        case DWPHY_BASEBAND_DAKOTA4:
            break;

        case DWPHY_BASEBAND_MOJAVE:
        case DWPHY_BASEBAND_MOJAVE1B:

            if (Band < 8) DwPhy_WriteRegField( 0x0E6, 0x0F, 0x03 ); // enable PA50 control, active high
            else          DwPhy_WriteRegField( 0x0E6, 0x0F, 0x0C ); // enable PA24 control, active high
            break;

        case DWPHY_BASEBAND_NEVADA_FPGA:
        case DWPHY_BASEBAND_NEVADA:
        case DWPHY_BASEBAND_NEVADA1B:
        default:

            DwPhy_WriteReg( 0x0E7, Band < 8 ? 0x30 : 0x03 );
            break;
    }
}
// end of DwPhy_EnablePowerAmpByBand()

// ================================================================================================
// FUNCTION  : DwPhy_WriteRegByBand()
// ------------------------------------------------------------------------------------------------
// Purpose   : Set register defaults per frequency band. This function is called from 
//             DwPhy_SetChannel_???.
// Parameters: pDevInfo   -- pointer to device information structure
//             Band       -- band number (0-8)
//             NumReg     -- number of registers in RegByBand array
//             pRegByBand -- pointer to RegByBand array
// ================================================================================================
static void DwPhy_WriteRegByBand( dwDevInfo_t *pDevInfo, uint8_t Band, uint32_t NumReg, 
                                  dwPhyRegByBand_t* pRegByBand)
{
    DwPhy_t *pDwPhy = (DwPhy_t *)(pDevInfo->pDwPhy);
    uint32_t i;

    // write default values provided as arguments to the function
    //
    if (pRegByBand != NULL)
    {
        for (i=0; i<NumReg; i++)
        {
            DwPhy_WriteRegField( pRegByBand[i].Addr, 
                                 pRegByBand[i].Mask, 
                                 pRegByBand[i].Data[Band] );
        }
    }

    // write programmed values from the device strucutre (can override the above)
    //
    if (pDwPhy->pRegByBand != NULL)
    {
        for (i=0; i<pDwPhy->RegByBandLength; i++)
        {
            DwPhy_WriteRegField( pDwPhy->pRegByBand[i].Addr, 
                                 pDwPhy->pRegByBand[i].Mask,
                                 pDwPhy->pRegByBand[i].Data[Band] );
        }
    }
}
// end of DwPhy_WriteRegByBand()

// ================================================================================================
// FUNCTION  : DwPhy_WriteRegByChanl()
// ------------------------------------------------------------------------------------------------
// Purpose   : Set register defaults per channel. This function is called from DwPhy_SetChannel_???
// Parameters: pDevInfo   -- pointer to device information structure
//             Chanl      -- band number (0-8)
//             NumReg     -- number of registers in RegByBand array
//             pRegByBand -- pointer to RegByBand array
// ================================================================================================
static void DwPhy_WriteRegByChanl( dwDevInfo_t *pDevInfo, uint8_t Chanl, uint32_t NumReg, 
                                    dwPhyRegByChanl_t* pRegByChanl )
{
    DwPhy_t *pDwPhy = (DwPhy_t *)(pDevInfo->pDwPhy);
    uint32_t i;

    // write default values provided as arguments to the function
    //
    if (pRegByChanl != NULL)
    {
        for (i=0; i<NumReg; i++)
        {
            DwPhy_WriteRegField( pRegByChanl[i].Addr, 
                                 pRegByChanl[i].Mask, 
                                 pRegByChanl[i].Data[Chanl] );
        }
    }
    // write programmed values from the device structure (can override the above)
    //
    if ((pDwPhy->pRegByChanl24 != NULL) && (Chanl >= 241) && (Chanl <= 254))
    {
        int n = Chanl - 241; // channel index in the 2.4 GHz band
        for (i=0; i<pDwPhy->RegByChanl24Length; i++)
        {
            DwPhy_WriteRegField( pDwPhy->pRegByChanl24[i].Addr, 
                                 pDwPhy->pRegByChanl24[i].Mask,
                                 pDwPhy->pRegByChanl24[i].Data[n] );
        }
    }
    if (pDwPhy->pRegByChanl != NULL)
    {
        for (i=0; i<pDwPhy->RegByChanlLength; i++)
        {
            DwPhy_WriteRegField( pDwPhy->pRegByChanl[i].Addr, 
                                 pDwPhy->pRegByChanl[i].Mask,
                                 pDwPhy->pRegByChanl[i].Data[Chanl] );
        }
    }
}
// end of DwPhy_WriteRegByChanl()

// ================================================================================================
// FUNCTION  : DwPhy_WriteRegByChanl24()
// ------------------------------------------------------------------------------------------------
// Purpose   : Set register defaults per channel. This function is called from DwPhy_SetChannel_???
// Parameters: pDevInfo    -- pointer to device information structure
//             Chanl       -- channel number 
//             NumReg      -- number of registers in RegByChanl array
//             pRegByChanl -- pointer to RegByChanl array
// ================================================================================================
static void DwPhy_WriteRegByChanl24( dwDevInfo_t *pDevInfo, uint8_t Chanl, uint32_t NumReg, 
                                     dwPhyRegByChanl24_t* pRegByChanl )
{
    DwPhy_t *pDwPhy = (DwPhy_t *)(pDevInfo->pDwPhy);
    uint32_t i;

    // write default values provided as arguments to the function
    //
    if (pRegByChanl != NULL)
    {
        int n = Chanl - 241; // channel index in the 2.4 GHz band        
        for (i=0; i<NumReg; i++)
        {
            DwPhy_WriteRegField( pRegByChanl[i].Addr, 
                                 pRegByChanl[i].Mask, 
                                 pRegByChanl[i].Data[n] );
        }
    }
    // write programmed values from the device structure (can override the above)
    //
    if ((pDwPhy->pRegByChanl24 != NULL) && (Chanl >= 241) && (Chanl <= 254))
    {
        int n = Chanl - 241; // channel index in the 2.4 GHz band
        for (i=0; i<pDwPhy->RegByChanl24Length; i++)
        {
            DwPhy_WriteRegField( pDwPhy->pRegByChanl24[i].Addr, 
                                 pDwPhy->pRegByChanl24[i].Mask,
                                 pDwPhy->pRegByChanl24[i].Data[n] );
        }
    }
}
// end of DwPhy_WriteRegByChanl24()

// ================================================================================================
// FUNCTION  : DwPhy_ChannelMap()
// ------------------------------------------------------------------------------------------------
// Purpose   : Converts a channel specified by frequency to a channel number and band encoding
// Parameters: FcMHz    -- channel frequency (MHz)
//             pChanNum -- channel number (output)
//             pBand    -- frequency band (output)
// ================================================================================================
static dwPhyStatus_t DwPhy_ChannelMap(dwDevInfo_t *pDevInfo, uint32_t FcMHz, uint8_t *pChanNum, uint8_t *pBand)
{
    uint8_t m, n;
    dwPhyStatus_t status = DWPHY_SUCCESS;

    //////////////////////////////////////////////////////////////////////////////////////////
    //
    //  Mapping from FcMHz to RF52 Channel Number and Frequency Band
    //  (Basie uses a subset of the channel mapping)
    //
    switch ( FcMHz )
    {
        case 2412: n = 241; m = 8; break;
        case 2417: n = 242; m = 8; break;
        case 2422: n = 243; m = 8; break;
        case 2427: n = 244; m = 8; break;
        case 2432: n = 245; m = 8; break;
        case 2437: n = 246; m = 8; break;
        case 2442: n = 247; m = 8; break;
        case 2447: n = 248; m = 8; break;
        case 2452: n = 249; m = 8; break;
        case 2457: n = 250; m = 8; break;
        case 2462: n = 251; m = 8; break;
        case 2467: n = 252; m = 8; break;
        case 2472: n = 253; m = 8; break;
        case 2484: n = 254; m = 8; break;

        case 4915: n = 183; m = 0; break;
        case 4920: n = 184; m = 0; break;
        case 4925: n = 185; m = 0; break;
        case 4935: n = 187; m = 0; break;
        case 4940: n = 188; m = 0; break;
        case 4945: n = 189; m = 0; break;
        case 4960: n = 192; m = 0; break;
        case 4980: n = 196; m = 0; break;

        case 5035: n =   7; m = 1; break;
        case 5040: n =   8; m = 1; break;
        case 5055: n =  11; m = 1; break;
        case 5060: n =  12; m = 1; break;
        case 5080: n =  16; m = 1; break;

        case 5170: n =  34; m = 2; break;
        case 5180: n =  36; m = 2; break;
        case 5190: n =  38; m = 2; break;
        case 5200: n =  40; m = 2; break;
        case 5210: n =  42; m = 2; break;
        case 5220: n =  44; m = 2; break;
        case 5230: n =  46; m = 2; break;
        case 5240: n =  48; m = 2; break;

        case 5260: n =  52; m = 3; break;
        case 5280: n =  56; m = 3; break;
        case 5300: n =  60; m = 3; break;
        case 5320: n =  64; m = 3; break;

        case 5500: n = 100; m = 4; break;

        case 5520: n = 104; m = 5; break;
        case 5540: n = 108; m = 5; break;
        case 5560: n = 112; m = 5; break;
        case 5580: n = 116; m = 5; break;
        case 5600: n = 120; m = 5; break;
        case 5620: n = 124; m = 5; break;

        case 5640: n = 128; m = 6; break;
        case 5660: n = 132; m = 6; break;
        case 5680: n = 136; m = 6; break;
        case 5700: n = 140; m = 6; break;
        case 5745: n = 149; m = 6; break;

        case 5765: n = 153; m = 7; break;
        case 5785: n = 157; m = 7; break;
        case 5805: n = 161; m = 7; break;

        default: 
            n = 0; m = 0;
            status = DWPHY_ERROR_UNSUPPORTED_CHANNEL;
            break;
    }
    if (pChanNum) *pChanNum = n;
    if (pBand   ) *pBand    = m;

    return status;
}
// end of DwPhy_ChannelMap()

// ================================================================================================
// FUNCTION  : DwPhy_SetChannel_RF52A()
// ------------------------------------------------------------------------------------------------
// Purpose   : Set channel for RF52A...Called from DwPhy_SetChannel()
// Parameters: pDevInfo -- pointer to device information structure
//             ChanNum  -- RF52 channel encoding
//             Band     -- Frequency band (0-8)
// ================================================================================================
static dwPhyStatus_t DwPhy_SetChannel_RF52A(dwDevInfo_t *pDevInfo, uint8_t ChanNum, uint8_t Band)
{
    dwPhyRegByBand_t RegByBand_RF52A120[] =
    {
        {0x13A, 0xFF, {0xB1, 0xD3, 0xF5, 0xF7, 0xF9, 0xFB, 0xFD, 0xFF, 0x55} },
        {0x141, 0xFF, {0xB0, 0xD0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0x50} },
        {0x15C, 0xFF, {0x18, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x1F, 0x12} },
        {0x15D, 0xFF, {0x0B, 0x1B, 0x1B, 0x1B, 0x1B, 0x1B, 0x1B, 0x1B, 0xB1} },
        {0x15E, 0xFF, {0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x84} },
        {0x160, 0xFF, {0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1D, 0x1E, 0x1F, 0x12} },
        {0x161, 0xFF, {0x30, 0x40, 0x40, 0x40, 0x40, 0x50, 0x50, 0x50, 0x40} },
        {0x119, 0x1F, {0x19, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x17, 0x19} }, // DACHI
        {0x11A, 0x1F, {0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x07} }, // DACLO
    };

    dwPhyRegByBand_t RegByBand_RF52A321[] =
    {
        {0x041, 0xFF, {0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x1D} }, // InitAGain
        {0x13A, 0xFF, {0x51, 0x73, 0x95, 0xB7, 0xD9, 0xD9, 0xFB, 0xFD, 0x55} },
        {0x15C, 0xFF, {0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x1F, 0x12} },
        {0x15D, 0xFF, {0x0B, 0x1B, 0x1B, 0x1B, 0x1B, 0x1B, 0x1B, 0x1B, 0xB1} },
        {0x15E, 0xFF, {0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x84} },
        {0x160, 0xFF, {0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x12} },
        {0x161, 0xFF, {0x50, 0x50, 0x50, 0x50, 0x50, 0x50, 0x50, 0x50, 0x40} },
        {0x119, 0x1F, {0x19, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x17, 0x19} }, // DACHI
        {0x11A, 0x1F, {0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x07} }, // DACLO
    };

    uint8_t i;

    //////////////////////////////////////////////////////////////////////////////////////////
    //
    //  Put the PHY into sleep mode
    //  The subsequent code will wake the radio to perform manual VCO calibration, but the 
    //  baseband remains in sleep mode.
    //
    {
        dwPhyStatus_t status = DwPhy_Sleep(pDevInfo);
        if (status != DWPHY_SUCCESS) return status;
    }

    //////////////////////////////////////////////////////////////////////////////////////////
    //
    //  Delta-Sigma Mode
    //
    //  Channel-specific delta-sigma mode. Based on discussions with RF52 densigners, this is
    //  probably not necessary with the current programming sequence. However, the cost is low
    //  so it is retained to avoid unnecessary changes.
    //
    switch (ChanNum)
    {
        case   8: case  38: case  44: case  56: case 104: 
        case 116: case 128: case 140: case 184: case 196: 
                  DwPhy_WriteRegField(256+16, 0x3, 0);
        default : DwPhy_WriteRegField(256+16, 0x3, 3);
    }

    //////////////////////////////////////////////////////////////////////////////////////////
    //
    //  Program the Channel
    //
    DwPhy_WriteReg(256+12, ChanNum);

    //////////////////////////////////////////////////////////////////////////////////////////
    //
    //  Frequency-Selective Configuration
    //
    //  Programming specific to frequency bands is implemented here. This includes configuring
    //  the correct 2.4 or 5 GHz band external components and tuning radio parameters that
    //  vary over frequency.
    //
    DwPhy_EnablePowerAmpByBand(pDevInfo, Band);

    switch (DwPhy_RadioID(pDevInfo) )
    {
        case DWPHY_RADIO_RF52A120: 
            DwPhy_WriteRegByBand(pDevInfo, Band, sizeof(RegByBand_RF52A120)/12, RegByBand_RF52A120);
            break;

        case DWPHY_RADIO_RF52A321:
        case DWPHY_RADIO_RF52A421: 
        case DWPHY_RADIO_RF52A521: 
            DwPhy_WriteRegByBand(pDevInfo, Band, sizeof(RegByBand_RF52A321)/12, RegByBand_RF52A321);
            break;

        default: break;
    }
    DwPhy_WriteRegByChanl(pDevInfo, ChanNum, 0, NULL);

    //////////////////////////////////////////////////////////////////////////////////////////
    //
    //  WAKE THE RADIO
    //
    //  Use the baseband RadioMC to manually wake the radio. Register 224, bits [7:6] are
    //  active when the PHY is asleep (DW_PHYEnB = 1).
    //
    DwPhy_WriteReg(224, 0x5E); // Standby: MC[1:0] = 01
    DwPhy_Delay( 300 );        // wait for sleep-to-standby (conservative)
    DwPhy_WriteReg(224, 0xDE); // RX/Active: MC[1:0] = 11
    DwPhy_Delay(  30 );        // wait for standby-to-RX (conservative)

    //////////////////////////////////////////////////////////////////////////////////////////
    //
    //  PLL Open Loop Calibration
    //
    //  RF52A requires manual open-loop calibration. The radio must be active, but this the
    //  channel setting is not important. Note that this procedure requies 500 microseconds
    //  before subsequent programming or use of the PLL.
    //
    DwPhy_WriteRegBit(256+35, 5, 0); // disable CAPSEL bypass
    DwPhy_WriteRegBit(256+26, 7, 1); // SPISTRTSEL = 1

    DwPhy_WriteRegBit(256+36, 0, 0); // toggle CALRSTSPI
    DwPhy_WriteRegBit(256+36, 0, 1); // ...resets both open and closed loop calibrations on
    DwPhy_WriteRegBit(256+36, 0, 0); //    a low-to-high transition

    DwPhy_WriteRegBit(256+26, 5, 0); // toggle SPIOLSTRT
    DwPhy_WriteRegBit(256+26, 5, 1); // ...start open-loop calibration on low-to-high transition
    DwPhy_WriteRegBit(256+26, 5, 0);
    DwPhy_Delay( 10 );               // a 5 usec delay was needed to allow certain A321 parts
                                     // ...to lock - double to 10 usec for margin
    DwPhy_WriteRegBit(256+26, 7, 0); // SPISTRTSEL = 0
    DwPhy_Delay( 500 );

    //////////////////////////////////////////////////////////////////////////////////////////
    //
    //  Copy Calibration Value to Override
    //
    //  Automatic calibration on power-up is not functional in RF52Axxx. As a work-around,
    //  the value obtained from the calibration above is read back and loaded into a bypass
    //  register. The bypass value is then used on wake-up.
    //
    {
        uint8_t CAPSEL = DwPhy_ReadReg(256+42) & 0x1F; // bottom 5 bits
        uint8_t Reg35  =(DwPhy_ReadReg(256+35) & 0xE0) | CAPSEL; // put CAPSEL --> CAPSELBYP

        DwPhy_WriteReg(256+35, Reg35);
        DwPhy_WriteRegBit(256+35, 5, 1); // enable CAPSEL bypass
    }

    //////////////////////////////////////////////////////////////////////////////////////////
    //
    //  PLL Closed Loop Calibration (3x)
    //
    //  Closed loop calibration is required here for two reasons. First, automatic calibration
    //  does not work in A321. Second, in previous versions, open-loop calibration did not
    //  reach the correct value so multiple closed-loop cycles were required to make up the
    //  difference. At the current time, the second case is believed fixed, but the cost for
    //  retaining the extra cycles is low.
    //
    DwPhy_WriteRegBit(256+35, 7, 1);     // CLCALEN = 1...redundant: should be the default
    DwPhy_WriteRegBit(256+26, 7, 1);     // SPISTRTSEL = 1 (enable trigger from SPICLSTRT)

    for (i=0; i<3; i++)
    {
        DwPhy_WriteRegBit(256+26, 6, 0); // toggle SPICLSTRT
        DwPhy_WriteRegBit(256+26, 6, 1); // ...trigger closed-loop calibration
        DwPhy_WriteRegBit(256+26, 6, 0); //    on a low-to-high transition
        DwPhy_Delay(30);
    }
    DwPhy_WriteRegBit(256+26, 7, 0);     // SPISTRTSEL = 0

    //////////////////////////////////////////////////////////////////////////////////////////
    //
    //  Sleep the Radio
    //
    //  Manually put the radio back to sleep mode and restore the RadioMC setting. This is
    //  the reverse of the wakeup sequence but mode transitions require ~100ns which should
    //  be covered by register access + CPU time
    //
    DwPhy_WriteReg(224, 0x5E); // Standby: MC[1:0] = 01
    DwPhy_WriteReg(224, 0x1E); // Sleep  : MC[1:0] = 00

    return DWPHY_SUCCESS;
}
// end of DwPhy_SetChannel_RF52A()

// ================================================================================================
// FUNCTION  : DwPhy_SetChannel_RF52B()
// ------------------------------------------------------------------------------------------------
// Purpose   : Set channel for RF52B...Called from DwPhy_SetChannel()
// Parameters: pDevInfo -- pointer to device information structure
//             ChanNum  -- RF52 channel encoding
//             Band     -- Frequency band (0-8)
// ================================================================================================
static dwPhyStatus_t DwPhy_SetChannel_RF52B(dwDevInfo_t *pDevInfo, uint8_t ChanNum, uint8_t Band)
{
    dwPhyRegByBand_t RegByBand_RF52B21[] =
    {
        {0x115, 0xFF, {0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xE8} },
        {0x118, 0xFF, {0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x1A, 0x14} },
        {0x119, 0xFF, {0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x15, 0x15, 0x18} },
        {0x11A, 0xFF, {0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x05, 0x05} },
        {0x11C, 0xFF, {0x6B, 0x6B, 0x6B, 0x6B, 0x6B, 0x6B, 0x6B, 0x6B, 0x69} },
        {0x11D, 0xFF, {0x5F, 0x5F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x5F} },
        {0x11F, 0xFF, {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00} },
        {0x124, 0xFF, {0x74, 0x74, 0x74, 0x74, 0x74, 0x74, 0x74, 0x74, 0xF4} },
        {0x125, 0xFF, {0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xE3} },
        {0x134, 0xFF, {0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x3E} },
        {0x15D, 0xFF, {0x08, 0x08, 0x08, 0x06, 0x06, 0x06, 0x06, 0x06, 0x0A} },
        {0x164, 0xFF, {0xB0, 0xB0, 0xB0, 0xB0, 0xB0, 0xB0, 0xB0, 0xB0, 0xD0} },
        {0x16C, 0xFF, {0xB0, 0xB0, 0xB0, 0xB0, 0xB0, 0xB0, 0xB0, 0xB0, 0xAC} },
        {0x16D, 0xFF, {0xB4, 0xB4, 0xB4, 0xB4, 0xB4, 0xB4, 0xB4, 0xB4, 0xB0} },
        {0x170, 0xFF, {0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xE8} }
    }; // synthesized 09-Nov-2008 08:16:04

    dwPhyRegByBand_t RegByBand_RF52B31[] =
    {
        {0x119, 0xFF, {0x18, 0x18, 0x18, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A} },
        {0x11A, 0xFF, {0x09, 0x09, 0x09, 0x08, 0x08, 0x08, 0x08, 0x08, 0x09} },
        {0x11C, 0xFF, {0x5A, 0x5A, 0x5A, 0x5A, 0x5A, 0x6A, 0x6A, 0x6A, 0x5A} },
        {0x11E, 0xFF, {0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x50} },
        {0x15D, 0xFF, {0x08, 0x08, 0x08, 0x06, 0x06, 0x06, 0x06, 0x06, 0x0A} },
        {0x164, 0xFF, {0xB0, 0xB0, 0xB0, 0xB0, 0xB0, 0xB0, 0xB0, 0xB0, 0xD0} },
        {0x16D, 0xFF, {0xB4, 0xB4, 0xB4, 0xB4, 0xB4, 0xB4, 0xB4, 0xB4, 0xB0} },
        {0x170, 0xFF, {0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xE8} }
    }; // synthesized 08-Apr-2009 10:59:56

    //////////////////////////////////////////////////////////////////////////////////////////
    //
    //  Put the PHY into sleep mode
    //  The driver must wake the PHY after setting the channel. The sleep-to-wake sequence
    //  is required for the radio to complete channel selection.
    //
    {
        dwPhyStatus_t status = DwPhy_Sleep(pDevInfo);
        if (status != DWPHY_SUCCESS) return status;
    }
    //////////////////////////////////////////////////////////////////////////////////////////
    //
    //  Reset TX ALC
    //
    DwPhy_WriteRegBit(256+76, 7, 1);
    DwPhy_WriteRegBit(256+76, 7, 0);

    //////////////////////////////////////////////////////////////////////////////////////////
    //
    //  Program the Channel
    //
    DwPhy_WriteReg(256+12, ChanNum);          // program the channel decoder

    //////////////////////////////////////////////////////////////////////////////////////////
    //
    //  Frequency-Selective Configuration
    //
    //  Programming specific to frequency bands is implemented here. This includes configuring
    //  the correct 2.4 or 5 GHz band external components and tuning radio parameters that
    //  vary over frequency.
    //
    DwPhy_EnablePowerAmpByBand(pDevInfo, Band);

    switch (DwPhy_RadioID(pDevInfo) )
    {
        case DWPHY_RADIO_RF52B21: 
        {
            DwPhy_WriteRegByBand(pDevInfo, Band, sizeof(RegByBand_RF52B21)/12, RegByBand_RF52B21);
            break;
        }
        case DWPHY_RADIO_RF52B31: 
        {
            DwPhy_WriteRegByBand(pDevInfo, Band, sizeof(RegByBand_RF52B31)/12, RegByBand_RF52B31);
            break;
        }
        default:
            DwPhy_WriteRegByBand(pDevInfo, Band, 0, NULL);
            break;
    }
    DwPhy_WriteRegByChanl(pDevInfo, ChanNum, 0, NULL);

    return DWPHY_SUCCESS;
}
// end of DwPhy_SetChannel_RF52B()

// ================================================================================================
// FUNCTION  : DwPhy_SetChannel_RF22A()
// ------------------------------------------------------------------------------------------------
// Purpose   : Set channel for RF22A...Called from DwPhy_SetChannel()
// Parameters: pDevInfo -- pointer to device information structure
//             ChanNum  -- RF52 channel encoding
//             Band     -- Frequency band (0-8)
// ================================================================================================
static dwPhyStatus_t DwPhy_SetChannel_RF22A(dwDevInfo_t *pDevInfo, uint8_t ChanNum, uint8_t Band)
{    
    dwPhyRegByChanl24_t RegByChanl_RF22A[] =
    {
        {0x11F, 0xFF, {0x89, 0x8D, 0x91, 0x95, 0x99, 0x9D, 0xA1, 0xA5, 0xA9, 0xAD, 0xB1, 0xB5, 0xB9, 0xC3} }, // field 'NUM_FVCO_LO'
        {0x120, 0x0F, {0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07} }  // field 'NUM_FVCO_HI'        
    };
    
    //////////////////////////////////////////////////////////////////////////////////////////
    //
    //  Put the PHY into sleep mode
    //  The driver must wake the PHY after setting the channel. The sleep-to-wake sequence
    //  is required for the radio to complete channel selection.
    //
    {
        dwPhyStatus_t status = DwPhy_Sleep(pDevInfo);
        if (status != DWPHY_SUCCESS) return status;
    }

    //////////////////////////////////////////////////////////////////////////////////////////
    //
    //  Program the Channel
    //
    DwPhy_WriteReg(256+12, ChanNum); // program the channel decoder; only 4 LSBs are relevant 

    //////////////////////////////////////////////////////////////////////////////////////////
    //
    //  Frequency-Selective Configuration
    //
    //  Programming specific to frequency bands is implemented here. This includes configuring
    //  the correct 2.4 or 5 GHz band external components and tuning radio parameters that
    //  vary over frequency.
    //
    DwPhy_EnablePowerAmpByBand(pDevInfo, Band);

    switch (DwPhy_RadioID(pDevInfo))
    {
        case DWPHY_RADIO_RF22A01:         
        case DWPHY_RADIO_RF22A02: 
        case DWPHY_RADIO_RF22A11:         
        case DWPHY_RADIO_RF22A12: 
        case DWPHY_RADIO_RF22B01:
        case DWPHY_RADIO_RF22B02:
        case DWPHY_RADIO_RF22B03:
        case DWPHY_RADIO_RF22B04:
        default:
            DwPhy_WriteRegByBand(pDevInfo, Band, 0, NULL);
            break;
    }
    DwPhy_WriteRegByChanl24(pDevInfo, ChanNum, sizeof(RegByChanl_RF22A)/17, RegByChanl_RF22A);

    switch (DwPhy_RadioID(pDevInfo))
    {
        case DWPHY_RADIO_RF22A01:         
        case DWPHY_RADIO_RF22A02:
        {
            //////////////////////////////////////////////////////////////////////////////////////////
            //
            // Work-around for open-loop VCO Calibration
            //
            DwPhy_WriteRegField(256+105, 0x03, 0x02); // enable VCAL for Sleep->Standby   
            DwPhy_WriteRegField(    224, 0xC0, 0x40); // bring radio to Standby
            DwPhy_Delay(400);                         // conservative
            DwPhy_WriteRegField(    224, 0xC0, 0x00); // bring radio back to Sleep
    
            if (!(DwPhy_ReadReg(256+106) >> 7))
            {
                DwPhy_WriteRegField(224, 0xC0, 0x40);
                DwPhy_Delay(400);
                DwPhy_WriteRegField(224, 0xC0, 0x00);
            }
    
            DwPhy_WriteRegField(256+105, 0x03, 0x00); // disable VCAL  
            break;
        }
        default: break;
    }
    
    return DWPHY_SUCCESS;
}
// end of DwPhy_SetChannel_RF22A()

// ================================================================================================
// FUNCTION  : DwPhy_ForceTXDCOCValue()
// ------------------------------------------------------------------------------------------------
// Purpose   : Force RF22 internal DAC values for TXDCOC calibration workaround. 
// ================================================================================================
void DwPhy_ForceTXDCOCValue(void)
{
    uint8_t value;
    int8_t  DAC_I, DAC_Q;   

    value = DwPhy_ReadReg( 0x8000 | (241-128) ) & 0x1F;        // read TX-DCOC result (TX_DCOC_DAC_I)
    DAC_I = (value & 0x10) ? -(value & 0x0F) : (value & 0x0F);

    value = DwPhy_ReadReg( 0x8000 | (242-128) ) & 0x1F;        // read TX-DCOC result (TX_DCOC_DAC_Q)
    DAC_Q = (value & 0x10) ? -(value & 0x0F) : (value & 0x0F);

    DAC_I += -4;
    DAC_Q += -3;

    DAC_I = (DAC_I < -15) ? -15 : DAC_I;
    DAC_I = (DAC_I >  15) ?  15 : DAC_I;

    DAC_Q = (DAC_Q < -15) ? -15 : DAC_Q;                 
    DAC_Q = (DAC_Q >  15) ?  15 : DAC_Q;                 

    value = (DAC_I < 0) ? 16 - DAC_I : DAC_I;
    DwPhy_WriteRegField( 0x8000 | (238-128), 0x3F, (0x20 | value)); // set FORCE_TX_DACI + new TX_DACI_OVR

    value = (DAC_Q < 0) ? 16 - DAC_Q : DAC_Q;
    DwPhy_WriteRegField( 0x8000 | (239-128), 0x3F, (0x20 | value)); // set FORCE_TX_DACQ + new TX_DACQ_OVR 
}
// end of DwPhy_DwPhy_ForceTXDCOCValue()

// ================================================================================================
// FUNCTION  : DwPhy_CalibrateTXDCOC_RF22()
// ------------------------------------------------------------------------------------------------
// Purpose   : Perform RF22 TXDCOC calibration.             
// Parameters: pDevInfo -- pointer to device information structure
// ================================================================================================
dwPhyStatus_t DwPhy_CalibrateTXDCOC_RF22(dwDevInfo_t *pDevInfo)
{
    
    //////////////////////////////////////////////////////////////////////////////////////////
    //
    //  Put the PHY into sleep mode
    //  The driver must wake the PHY after calibration.
    //
    {
        dwPhyStatus_t status = DwPhy_Sleep(pDevInfo);
        if (status != DWPHY_SUCCESS) return status;
    }

    switch (DwPhy_RadioID(pDevInfo))
    {
        case DWPHY_RADIO_RF22A02: 
        case DWPHY_RADIO_RF22A12: 
		{
			return ( DwPhy_CalibrateTXDCOC_RF22A(pDevInfo) );
		}
        case DWPHY_RADIO_RF22B01:
        case DWPHY_RADIO_RF22B02:
        case DWPHY_RADIO_RF22B03:
        case DWPHY_RADIO_RF22B04:
		{
			return ( DwPhy_CalibrateTXDCOC_RF22B(pDevInfo) );
        }
        default:
            return DWPHY_ERROR_TXDCOC_CAL_FAILED;
    }
    
}
// end of DwPhy_CalibrateTXDCOC_RF22()


// ================================================================================================
// FUNCTION  : DwPhy_CalibrateTXDCOC_RF22A()
// ------------------------------------------------------------------------------------------------
// Purpose   : Perform RF22A TXDCOC calibration.             
// Parameters: pDevInfo -- pointer to device information structure
// ================================================================================================
dwPhyStatus_t DwPhy_CalibrateTXDCOC_RF22A(dwDevInfo_t *pDevInfo)
{
    uint8_t CalModeWait, RingPllCtrl;
    uint8_t WaitLimit = 150;
    uint8_t DefaultReg7, DefaultReg224, DefaultReg225;
    
	RingPllCtrl = DwPhy_ReadReg(256+27);
	DwPhy_WriteRegField(256+27, 0x80, 0x00);

	DwPhy_WriteRegField( 0x8000 | (237-128), 0x03, 0x03); // FORCE_TX_DACEN = TX_DACEN_OVR = 1
	DwPhy_WriteRegField( 0x8000 | (238-128), 0x20, 0x00); // FORCE_TX_DACI = 0
	DwPhy_WriteRegField( 0x8000 | (239-128), 0x20, 0x00); // FORCE_TX_DACQ = 0    
    
	DefaultReg7   = DwPhy_ReadReg(7);
    DefaultReg224 = DwPhy_ReadReg(224);
	DefaultReg225 = DwPhy_ReadReg(225);

            
    
    CalModeWait = DwPhy_ReadReg(256+125);
    

    switch (DwPhy_BasebandID(pDevInfo))
    {
			case DWPHY_BASEBAND_MOJAVE:
            case DWPHY_BASEBAND_MOJAVE1B:
				DwPhy_WriteReg(7, 0x0F); // force PrdSrC to zero
                break;

			case DWPHY_BASEBAND_NEVADA_FPGA:
            case DWPHY_BASEBAND_NEVADA:
            case DWPHY_BASEBAND_NEVADA1B:
            default:
				DwPhy_WriteReg(7, 0xF0); // select TxWordXX (zero by default)
                break;
    }
    DwPhy_WriteReg     (225, 0xFF);                       // enable DACs
    DwPhy_WriteRegField(224, 0xC0, 0x40);                 // bring radio to Standby
    DwPhy_WriteRegField( 0x8000 | (128-128), 0x0F, 0x03); // enable TXDCOC calibration   
    
    DwPhy_Delay(50 * 32 * CalModeWait / (uint32_t)1000 + 5 + 5);
     
    while ((DwPhy_ReadReg(0x8000 | (241-128)) & 0x80) == 0 && WaitLimit != 0)
    {   
        DwPhy_Delay(20);
        WaitLimit--;
    }
    DwPhy_WriteRegField( 0x8000 | (128-128), 0x0F, 0x00); // disable TXDCOC calibration    
            
    DwPhy_WriteReg     (224, DefaultReg224);              // restore MC[1:0] signals
    DwPhy_WriteReg     (225, DefaultReg225);              // restore DAC settings
    DwPhy_WriteReg     (  7, DefaultReg7  );              // restore the PrD settings
                
    if (WaitLimit)
    {
		DwPhy_WriteRegField( 0x8000 | (237-128), 0x03, 0x00); // FORCE_TX_DACEN = TX_DACEN_OVR = 0    

		DwPhy_WriteReg(256+27, RingPllCtrl);
		DwPhy_ForceTXDCOCValue();
	
		return DWPHY_SUCCESS;
    }
    else
        return DWPHY_ERROR_TXDCOC_CAL_FAILED;
}
// end of DwPhy_CalibrateTXDCOC_RF22A()

// ================================================================================================
// FUNCTION  : DwPhy_CalibrateTXDCOC_RF22B()
// ------------------------------------------------------------------------------------------------
// Purpose   : Perform RF22B TXDCOC calibration.             
// Parameters: pDevInfo -- pointer to device information structure
// ================================================================================================
dwPhyStatus_t DwPhy_CalibrateTXDCOC_RF22B(dwDevInfo_t *pDevInfo)
{
    uint8_t CalModeWait;
    uint8_t WaitLimit = 150;
    uint8_t DefaultReg7, DefaultReg224, DefaultReg225;
    

	DefaultReg7   = DwPhy_ReadReg(7);
    DefaultReg224 = DwPhy_ReadReg(224);
    DefaultReg225 = DwPhy_ReadReg(225);

            
    
    CalModeWait = DwPhy_ReadReg(256+125);
    

    switch (DwPhy_BasebandID(pDevInfo))
    {
		case DWPHY_BASEBAND_MOJAVE:
        case DWPHY_BASEBAND_MOJAVE1B:
			DwPhy_WriteReg(7, 0x0F); // force PrdSrC to zero
            break;

        case DWPHY_BASEBAND_NEVADA_FPGA:
        case DWPHY_BASEBAND_NEVADA:
        case DWPHY_BASEBAND_NEVADA1B:
        default:
			DwPhy_WriteReg(7, 0xF0); // select TxWordXX (zero by default)
            break;
    }
    DwPhy_WriteReg     (225, 0xFF);                       // enable DACs
    DwPhy_WriteReg(224, 0x55);                            // bring radio  to Standby    
    DwPhy_WriteRegField( 0x8000 | (128-128), 0x0F, 0x03); // enable TXDCOC calibration   
    
    DwPhy_Delay(50 * 32 * CalModeWait / (uint32_t)1000 + 5 + 5);
    while ((DwPhy_ReadReg(0x8000 | (241-128)) & 0x80) == 0 && WaitLimit != 0)
    {   
		DwPhy_Delay(20);
        WaitLimit--;
    }
    DwPhy_WriteRegField( 0x8000 | (128-128), 0x0F, 0x00); // disable TXDCOC calibration    
            
    DwPhy_WriteReg     (224, DefaultReg224);              // restore MC[1:0] signals
    DwPhy_WriteReg     (225, DefaultReg225);              // restore DAC settings
    DwPhy_WriteReg     (  7, DefaultReg7  );              // restore the PrD settings
            
    
    if (WaitLimit)
    {
        return DWPHY_SUCCESS;
    }
    else
        return DWPHY_ERROR_TXDCOC_CAL_FAILED;
}
// end of DwPhy_CalibrateTXDCOC_RF22B()

// ================================================================================================
// FUNCTION  : DwPhy_CalibrateLOFT_RF22()
// ------------------------------------------------------------------------------------------------
// Purpose   : Perform RF22 LOFT calibration.             
// Parameters: pDevInfo -- pointer to device information structure
// ================================================================================================
dwPhyStatus_t DwPhy_CalibrateLOFT_RF22(dwDevInfo_t *pDevInfo)
{

    //////////////////////////////////////////////////////////////////////////////////////////
    //
    //  Put the PHY into sleep mode
    //  The driver must wake the PHY after calibration.
    //
    {
        dwPhyStatus_t status = DwPhy_Sleep(pDevInfo);    
        if (status != DWPHY_SUCCESS) return status;
    }

    switch (DwPhy_RadioID(pDevInfo))
    {
        case DWPHY_RADIO_RF22A02: 
        case DWPHY_RADIO_RF22A12:  
		{
			return (DwPhy_CalibrateLOFT_RF22A(pDevInfo));
		}
        case DWPHY_RADIO_RF22B01:
        case DWPHY_RADIO_RF22B02:
        case DWPHY_RADIO_RF22B03:
        case DWPHY_RADIO_RF22B04:
		{
            return (DwPhy_CalibrateLOFT_RF22B(pDevInfo));
        }
        default:
            break;
    }
    
	return DWPHY_ERROR_LOFT_CAL_FAILED;
}
// end of DwPhy_CalibrateLOFT_RF22()

// ================================================================================================
// FUNCTION  : DwPhy_CalibrateLOFT_RF22A()
// ------------------------------------------------------------------------------------------------
// Purpose   : Perform RF22A LOFT calibration.             
// Parameters: pDevInfo -- pointer to device information structure
// ================================================================================================
dwPhyStatus_t DwPhy_CalibrateLOFT_RF22A(dwDevInfo_t *pDevInfo)
{
    uint8_t WaitLimit = 150, CalModeWait, RingPllCtrl;
    uint8_t DAC_I, DAC_Q;


	{
        RingPllCtrl = DwPhy_ReadReg(256+27);
        DwPhy_WriteRegField(256+27, 0x80, 0x00);

        CalModeWait = DwPhy_ReadReg(256+125);
        DAC_I = DwPhy_ReadReg( 0x8000 | (241-128) ) & 0x1F;    // record TX_DACI_OVR 
        DAC_Q = DwPhy_ReadReg( 0x8000 | (242-128) ) & 0x1F;    // record TX_DACQ_OVR 
    
        DwPhy_WriteRegField(224, 0xC0, 0x40); // bring radio to Standby
    
        // Work-around for DC problem of internal DAC        
        DwPhy_WriteRegField( 0x8000 | (243-128), 0x01, 0x00);  // LOFT_REQ = 0        
        DwPhy_WriteRegField( 0x8000 | (238-128), 0x20, 0x00);  // FORCE_TX_DACI = 0
        DwPhy_WriteRegField( 0x8000 | (239-128), 0x20, 0x00);  // FORCE_TX_DACQ = 0    

        DwPhy_WriteRegField( 0x8000 | (128-128), 0x0F, 0x01);  // enable LOFT calibration   
        DwPhy_Delay(50 * 32 * CalModeWait / (uint32_t)1000 + 5 + 5); 
        while ((DwPhy_ReadReg(0x8000 | (241-128)) & 0x80) == 0 && WaitLimit != 0)
        {   
            DwPhy_Delay(20);
            WaitLimit--;
        }    
        DwPhy_ForceTXDCOCValue();
        DwPhy_WriteRegField( 0x8000 | (128-128), 0x0F, 0x00);  // disable LOFT calibration           

        // run 'true' LOFT
        WaitLimit = 150;
        DwPhy_WriteRegField( 0x8000 | (243-128), 0x01, 0x01);  // LOFT_REQ = 1        
        DwPhy_WriteRegField( 0x8000 | (128-128), 0x0F, 0x01);  // enable LOFT calibration
    
        DwPhy_Delay(50 * 32 * CalModeWait / (uint32_t)1000 + 5);
        while ((DwPhy_ReadReg(0x8000 | (252-128)) & 0x80) == 0 && WaitLimit != 0)
        {   
            DwPhy_Delay(20);
            WaitLimit--;
		}
    
        DwPhy_WriteRegField( 0x8000 | (128-128), 0x0F, 0x00);  // disable LOFT calibration
        DwPhy_WriteRegField(                224, 0xC0, 0x00);  // bring radio back to Sleep

        DwPhy_WriteRegField( 0x8000 | (238-128), 0x1F, DAC_I); // restore TX_DACI_OVR 
        DwPhy_WriteRegField( 0x8000 | (239-128), 0x1F, DAC_Q); // restore TX_DACQ_OVR 

        DwPhy_WriteReg(256+27, RingPllCtrl);
	}
     
    if (WaitLimit) return DWPHY_SUCCESS;
    else           return DWPHY_ERROR_LOFT_CAL_FAILED;
}
// end of DwPhy_CalibrateLOFT_RF22A()

// ================================================================================================
// FUNCTION  : DwPhy_CalibrateLOFT_RF22B()
// ------------------------------------------------------------------------------------------------
// Purpose   : Perform RF22B LOFT calibration.             
// Parameters: pDevInfo -- pointer to device information structure
// ================================================================================================
dwPhyStatus_t DwPhy_CalibrateLOFT_RF22B(dwDevInfo_t *pDevInfo)
{
    uint8_t WaitLimit = 150;
    uint8_t DefaultReg224;


    DefaultReg224 = DwPhy_ReadReg(224);                                 // get& save DefaultReg224              BB
    DwPhy_WriteReg(224, 0x55);                                          // bring radio  to Standby           

	WaitLimit = 150;
            
    DwPhy_WriteRegField( 0x8000 | (128-128), 0x0F, 0x01);  // enable LOFT calibration
    
    while ((DwPhy_ReadReg(0x8000 | (252-128)) & 0x80) == 0 && WaitLimit != 0)
    {   
		DwPhy_Delay(20);
        WaitLimit--;
    }
    
    DwPhy_WriteRegField( 0x8000 | (128-128), 0x0F, 0x00);  // disable LOFT calibration
    DwPhy_WriteReg(224,DefaultReg224);                     // restore DefaultReg224            BB   

	if (WaitLimit) return DWPHY_SUCCESS;
    else           return DWPHY_ERROR_LOFT_CAL_FAILED;
}
// end of DwPhy_CalibrateLOFT_RF22()



// ================================================================================================
// FUNCTION  : DwPhy_CalibrateIQ()
// ------------------------------------------------------------------------------------------------
// Purpose   : Perform I/Q calibration based on baseband/radio part IDs
// Parameters: pDevInfo -- pointer to device information structure
// ================================================================================================
dwPhyStatus_t DwPhy_CalibrateIQ(dwDevInfo_t *pDevInfo)
{
    dwPhyRadio_t RadioID = DwPhy_RadioID(pDevInfo);

    if (RadioID <= DWPHY_RADIO_RF52B32) return DWPHY_SUCCESS; // nothing to do

    switch (RadioID)
    {
        case DWPHY_RADIO_RF22A12:
        {
            switch (DwPhy_BasebandID(pDevInfo))
            {
                case DWPHY_BASEBAND_MOJAVE:
                case DWPHY_BASEBAND_MOJAVE1B:
                    return DwPhy_CalibrateIQ_RF22(pDevInfo);
                    break;

                case DWPHY_BASEBAND_NEVADA_FPGA:
                case DWPHY_BASEBAND_NEVADA:
                case DWPHY_BASEBAND_NEVADA1B:
                default:
                    return DwPhy_CalibrateIQ_DMW96(pDevInfo);
                    break;
            }
            break;
        }
        case DWPHY_RADIO_RF22B02:
        default:
        {
            switch (DwPhy_BasebandID(pDevInfo))
            {
                case DWPHY_BASEBAND_MOJAVE:
                case DWPHY_BASEBAND_MOJAVE1B:
                    return DwPhy_CalibrateIQ_RF22(pDevInfo);
                    break;

                case DWPHY_BASEBAND_NEVADA_FPGA:
                case DWPHY_BASEBAND_NEVADA:
                case DWPHY_BASEBAND_NEVADA1B:
                default:
//                    return DwPhy_CalibrateIQ_DMW96(pDevInfo);
                    return DwPhy_CalibrateIQ_RF22(pDevInfo); // due to instability on RF22B0 envelope det out to BB
                    break;
            }
            break;
        }
    }
    return DWPHY_SUCCESS;
}
// end of DwPhy_CalibrateIQ()

// ================================================================================================
// FUNCTION  : DwPhy_CalibrateIQ_RF22()
// ------------------------------------------------------------------------------------------------
// Purpose   : Perform RF22 I/Q calibration.             
// Parameters: pDevInfo -- pointer to device information structure
// ================================================================================================
dwPhyStatus_t DwPhy_CalibrateIQ_RF22(dwDevInfo_t *pDevInfo)
{
    uint8_t WaitLimit = 150, CalModeWait, RingPllCtrl;
    uint8_t DefaultReg224;
    //////////////////////////////////////////////////////////////////////////////////////////
    //
    //  Put the PHY into sleep mode
    //  The driver must wake the PHY after calibration.
    //
    {
        dwPhyStatus_t status = DwPhy_Sleep(pDevInfo);    
        if (status != DWPHY_SUCCESS) return status;
    }
    
    RingPllCtrl = DwPhy_ReadReg(256+27);
    DwPhy_WriteRegField(256+27, 0x80, 0x00);
    
    CalModeWait = DwPhy_ReadReg(256+125);
    DefaultReg224 = DwPhy_ReadReg(224);                                 // get& save DefaultReg224              BB    
    DwPhy_WriteReg(224, 0x55);                                          // bring radio  to Standby   
    DwPhy_WriteRegField( 0x8000 | (128-128), 0x0F, 0x02); // enable IQ calibration

    DwPhy_Delay(50 * 32 * CalModeWait / (uint32_t)1000 + 5);
    while ((DwPhy_ReadReg(0x8000 | (131-128)) & 0x20) == 0 && WaitLimit != 0)
    {   
        DwPhy_Delay(20);
        WaitLimit--;
    }
    DwPhy_WriteRegField( 0x8000 | (128-128), 0x0F, 0x00); // disable IQ calibration
    DwPhy_WriteReg(224,DefaultReg224);                    // restore DefaultReg224            BB   

    DwPhy_WriteReg(256+27, RingPllCtrl);
    
    if (WaitLimit) return DWPHY_SUCCESS;
    else           return DWPHY_ERROR_IQ_CAL_FAILED;
}
// end of DwPhy_CalibrateIQ_RF22()

// ================================================================================================
// FUNCTION  : DwPhy_CalibrateIQ_DMW96()
// ------------------------------------------------------------------------------------------------
// Purpose   : Perform I/Q calibration for DMW96.             
// Parameters: pDevInfo -- pointer to device information structure
// ================================================================================================
dwPhyStatus_t DwPhy_CalibrateIQ_DMW96(dwDevInfo_t *pDevInfo)
{
    dwPhyStatus_t status = DWPHY_SUCCESS;
    
    switch (DwPhy_RadioID(pDevInfo))
    {
        case DWPHY_RADIO_RF22A12:
        case DWPHY_RADIO_RF22B01:
        case DWPHY_RADIO_RF22B02:
        case DWPHY_RADIO_RF22B03:
        case DWPHY_RADIO_RF22B04:
        {
            uint8_t WaitLimitTx = 50, WaitLimitRx = 10, CalModeWait;
            uint8_t BBReg4, BBReg7, BBReg65, BBReg80, BBReg103, BBReg144, BBReg224, BBReg225;
            uint8_t RFReg85, RFReg129;
            
            //////////////////////////////////////////////////////////////////////////////////////////
            //
            //  Put the PHY into sleep mode
            //  The driver must wake the PHY after calibration.
            //
            {
                dwPhyStatus_t status = DwPhy_Sleep(pDevInfo);    
                if (status != DWPHY_SUCCESS) return status;
            }

            // Record register settings for restoration
            //
            BBReg4   = DwPhy_ReadReg(  4);
            BBReg7   = DwPhy_ReadReg(  7);
            BBReg65  = DwPhy_ReadReg( 65);            
            BBReg80  = DwPhy_ReadReg( 80);
            BBReg103 = DwPhy_ReadReg(103);
            BBReg144 = DwPhy_ReadReg(144);
            BBReg224 = DwPhy_ReadReg(224);
            BBReg225 = DwPhy_ReadReg(225);
            
            RFReg85  = DwPhy_ReadReg(256+85);
            RFReg129 = DwPhy_ReadReg(0x8000 | (129-128));

            //////////////////////////////////////////////////////////////////////////////////////////
            //
            //  Perform Tx IQ Calibration
            //
            DwPhy_WriteReg(224,  85);                // set RF to Standby            
            DwPhy_WriteReg(  4,   1);                // RXMode    = 1
            DwPhy_WriteReg( 36,   0);                // sTxIQ     = 0
            DwPhy_WriteReg( 40,   0);                // sRxIQ     = 0
            DwPhy_WriteReg(136,   2);                // TxToneDiv = 2
            DwPhy_WriteReg(225, 255);                // enable Tx DACs
            DwPhy_WriteReg( 62,  30);                // init CalGain
            DwPhy_WriteReg( 63,  15);                // init CalPhase            
            DwPhy_WriteRegBit  (103,    2,     1);   // IdleSDEnB = 1
            DwPhy_WriteRegField(144, 0x07,  0x03);   // DCXShift  = 3
            DwPhy_WriteReg(  7, 0xA0);             // set TxIQSrc to tone generator, bypass DPD

            // set up TX AGC in RF22
            DwPhy_WriteReg(0x8000 | (129-128), 160); // IQ_TX = TX_AGC_PRE = 1 
            DwPhy_WriteRegField(256+85, 0x03, 0x01); // ENVDETTH = 1

            DwPhy_Wake(pDevInfo);
            DwPhy_Delay(DwPhy_WakeupTime(pDevInfo));

			switch (DwPhy_RadioID(pDevInfo))
			{
				case DWPHY_RADIO_RF22A12:
					DwPhy_WriteRegField(0x8000 | (128-128), 0x0F, 0x0A); // enable RF22 to I/Q-DMW mode
					break;
				case DWPHY_RADIO_RF22B01:
				case DWPHY_RADIO_RF22B02:
				case DWPHY_RADIO_RF22B03:
				case DWPHY_RADIO_RF22B04:
					DwPhy_WriteRegField(0x8000 | (128-128), 0x1F, 0x12); // enable RF22 to I/Q-DMW mode
					break;
                default: 
                    return DWPHY_ERROR_UNDEFINED_CASE; 
                    break;
			}
            DwPhy_Delay(100);
            
            DwPhy_WriteReg(48,   6);
            DwPhy_WriteReg(49, 121);
            DwPhy_WriteReg(50,   4);
            DwPhy_WriteReg(51, 180);
            DwPhy_WriteReg(52,  80);
            DwPhy_WriteReg(53,  53);
            DwPhy_WriteReg(54,  17);
            DwPhy_WriteReg(55,   3);
            DwPhy_WriteReg(60,  26);
            DwPhy_WriteReg(61,  40);

            // Make sure RF22 TX AGC is complete
            //                        
            CalModeWait = DwPhy_ReadReg(256+125);    
            DwPhy_Delay(50 * 32 * CalModeWait / (uint32_t)1000 + 5);
            while ((DwPhy_ReadReg(0x8000 | (131-128)) & 0x01) == 0 && WaitLimitTx != 0)
             {   
                DwPhy_Delay(20);
                WaitLimitTx--;
            }
			
            // Start calibration
            //
            DwPhy_WriteReg(36,   1);                             // sTxIQ = 1
            DwPhy_WriteReg(59, 212);                             // enable DMW96 TxIQ calibration            
            WaitLimitTx = 150;
            while ((DwPhy_ReadReg(58) & 0x80) == 0 && WaitLimitTx != 0)
            {   
                DwPhy_Delay(20);
                WaitLimitTx--;
            }
			
            DwPhy_WriteRegBit(59, 7, 0);                         // disable DMW96 IQ calibration
            DwPhy_WriteRegField(0x8000 | (128-128), 0x1F, 0x00); // clear RF22 CALMODE register

            /////////////////////////////////////////////////////////////////////////////////////////
            //
            //  Perform Rx IQ Calibration
            //
            DwPhy_WriteReg(62,  30);              // init CalGain
            DwPhy_WriteReg(63,  15);              // init CalPhase            
            DwPhy_WriteReg(65,  21);              // InitAGain  [BB: a fixed number is suspicious...this should be relative to the default]
            DwPhy_WriteRegField(80, 0xC0,  0xC0); // fixed gain

            DwPhy_WriteReg(0x8000 | (129-128), 8);               // IQ_RX = 1 
            switch (DwPhy_RadioID(pDevInfo))
			{
				case DWPHY_RADIO_RF22A12:
					DwPhy_WriteRegField(0x8000 | (128-128), 0x0F, 0x0A); // enable RF22 to I/Q-DMW mode
					break;
				case DWPHY_RADIO_RF22B01:
				case DWPHY_RADIO_RF22B02:
				case DWPHY_RADIO_RF22B03:
				case DWPHY_RADIO_RF22B04:
					DwPhy_WriteRegField(0x8000 | (128-128), 0x1F, 0x12); // enable RF22 to I/Q-DMW mode
					break;
                default: 
                    return DWPHY_ERROR_UNDEFINED_CASE; 
                    break;
			}
            DwPhy_Delay(100);
            
            DwPhy_WriteReg(40,   2);              // sRxIQ = 2; RXB only
            DwPhy_WriteReg(48,   7);
            DwPhy_WriteReg(49, 156);
            DwPhy_WriteReg(50,  13);
            DwPhy_WriteReg(51, 135);            
            DwPhy_WriteReg(53,  50);

            // Make sure RF22 RX loopback path is complete
            //            
            DwPhy_Delay(50 * 32 * CalModeWait / (uint32_t)1000 + 5);
            while ((DwPhy_ReadReg(0x8000 | (131-128)) & 0x10) == 0 && WaitLimitRx != 0)
            {   
                DwPhy_Delay(20);
                WaitLimitRx--;
            }

            // Start calibration
            //            
            DwPhy_WriteReg(59, 244);                             // enable DMW96 RxIQ calibration            
            WaitLimitRx = 150;
            while ((DwPhy_ReadReg(58) & 0x80) == 0 && WaitLimitRx != 0)
            {   
                DwPhy_Delay(20);
                WaitLimitRx--;
            }
            DwPhy_WriteRegBit(59, 7, 0);                         // disable DMW96 IQ calibration
            DwPhy_WriteRegField(0x8000 | (128-128), 0x1F, 0x00); // clear RF22 CALMODE register

            // Return to Sleep
            //
            DwPhy_Sleep(pDevInfo);

            // Restore register settings
            //
            DwPhy_WriteReg(256+85, RFReg85 );
            DwPhy_WriteReg(0x8000 | (129-128), RFReg129);

            DwPhy_WriteReg(136, 0);
            DwPhy_WriteReg(  4, BBReg4  );
            DwPhy_WriteReg(  7, BBReg7  );
            DwPhy_WriteReg( 65, BBReg65 );            
            DwPhy_WriteReg( 80, BBReg80 );
            DwPhy_WriteReg(225, BBReg225);            
            DwPhy_WriteReg(103, BBReg103);
            DwPhy_WriteReg(144, BBReg144);
            DwPhy_WriteReg(224, BBReg224);

            if (WaitLimitTx == 0 || WaitLimitRx == 0) 
                status = DWPHY_ERROR_IQ_CAL_FAILED;
            break;
        }
        default: break;
    }

    return status;    
}
// end of DwPhy_CalibrateIQ_DMW96()

// ================================================================================================
// FUNCTION  : DwPhy_PllClosedLoopCalibration()
// ------------------------------------------------------------------------------------------------
// Purpose   : Perform closed-loop VCO calibration on the RF52. This function may be called on a 
//             sleep-to-wake transition to work around hardware problem on RF52A32x and RF52A42x
// Parameters: pDevInfo -- pointer to device information structure
// ================================================================================================
void DwPhy_PllClosedLoopCalibration(dwDevInfo_t *pDevInfo)
{
    switch (DwPhy_RadioID(pDevInfo))
    {
        case DWPHY_RADIO_RF52A120:
        case DWPHY_RADIO_RF52A321:
        case DWPHY_RADIO_RF52A421:
        case DWPHY_RADIO_RF52A521:
        case DWPHY_RADIO_RF52B21:
        case DWPHY_RADIO_RF52B31:
        {
            uint16_t Address = 256 + 26;
            uint8_t  X = DwPhy_ReadReg(Address);

            DwPhy_WriteReg(Address, (X & 0x3F) | 0x80);
            DwPhy_WriteReg(Address, (X & 0x3F) | 0xC0);
            DwPhy_WriteReg(Address, (X & 0x3F) | 0x80);
            DwPhy_WriteReg(Address, (X & 0x3F)       );
            DwPhy_Delay(20);
            break;
        }

        default:
            break;
    }
}
// end of DwPhy_PllClosedLoopCalibration()

// ================================================================================================
// FUNCTION  : DwPhy_SetChannelFreq()
// ------------------------------------------------------------------------------------------------
// Purpose   : Set the RF channel by frequency
// Parameters: pDevInfo -- pointer to device information structure
//             FcMHz    -- channel center frequency (MHz)
// ================================================================================================
dwPhyStatus_t DwPhy_SetChannelFreq(dwDevInfo_t *pDevInfo, uint32_t FcMHz)
{
    dwPhyStatus_t status = DWPHY_SUCCESS;
    DwPhy_t *pDwPhy = (DwPhy_t *)(pDevInfo->pDwPhy);
    uint8_t ChanNum, Band;
    int8_t  PrdBm;
    
    dwPhyRxMode_t LastRxMode = pDwPhy->RxMode;

    if (!pDwPhy->Baseband) DwPhy_ChipSet(pDevInfo); // get the chipset IDs

    // Map the channel frequency to a channel number and band
    //
    if (DwPhy_ChannelMap(pDevInfo, FcMHz, &ChanNum, &Band) != DWPHY_SUCCESS)
        return DWPHY_ERROR_UNSUPPORTED_CHANNEL;

    // Retrieve the current sensitivity limit and reset to default
    // Do this so band/channel specific register settings written below can be recorded before
    // restoring the RxSensitivity value read here.
    //
    DwPhy_GetRxSensitivity(pDevInfo, &PrdBm);
    DwPhy_SetRxSensitivity(pDevInfo, DWPHY_DEFAULT_RX_SENSITIVITY);
    DwPhy_SetRxMode(pDevInfo, DWPHY_RXMODE_DEFAULT);

    // Part-Specific Channel Selection
    //
    switch (pDwPhy->Radio)
    {
        case DWPHY_RADIO_NONE:
            break;

        case DWPHY_RADIO_BASIE_C1:
        case DWPHY_RADIO_BASIE_C2:
        case DWPHY_RADIO_BASIE_C3:
        {
            status = DwPhy_SetChannel_Basie(pDevInfo, ChanNum);
            break;
        }
        case DWPHY_RADIO_RF52A120:
        case DWPHY_RADIO_RF52A321:
        case DWPHY_RADIO_RF52A421:
        case DWPHY_RADIO_RF52A521:
        {
            status = DwPhy_SetChannel_RF52A(pDevInfo, ChanNum, Band);
            break;
        }
        case DWPHY_RADIO_RF52B21:
        case DWPHY_RADIO_RF52B31:
        {
            status = DwPhy_SetChannel_RF52B(pDevInfo, ChanNum, Band);
            break;
        }
        case DWPHY_RADIO_RF22A01:
        case DWPHY_RADIO_RF22A02:
        case DWPHY_RADIO_RF22A11:
        case DWPHY_RADIO_RF22A12:
        case DWPHY_RADIO_RF22B02:
        default:
        {
            status = DwPhy_SetChannel_RF22A(pDevInfo, ChanNum, Band);
            break;
        }
    }

    // Update register defaults and restore original sensitivity limit
    //
    DwPhy_RecordDefaultReg(pDevInfo);
    DwPhy_SetRxSensitivity(pDevInfo, PrdBm);
    DwPhy_SetRxMode(pDevInfo, LastRxMode);

    return status;
}
// end of DwPhy_SetChannelFreq()

// ================================================================================================
// FUNCTION  : DwPhy_Wake()
// ------------------------------------------------------------------------------------------------
// Purpose   : Initiate PHY Wakeup
// Parameters: pDevInfo -- pointer to device information structure
// ================================================================================================
dwPhyStatus_t DwPhy_Wake(dwDevInfo_t *pDevInfo)
{
    dwPhyStatus_t status;
    DwPhy_t *pDwPhy = (DwPhy_t *)(pDevInfo->pDwPhy);

    // Assert DW_PHYEnB for all cases. 
    // This is required by the DW52 MAC even if not needed for the PHY.
    //
    status = DwPhy_Enable(pDevInfo, 1); // assert DW_PHYEnB (for the MAC)
    if (status != DWPHY_SUCCESS) return status;

    // PHY-specific procedures
    //
    switch (pDwPhy->Baseband)
    {

        #if defined(DWPHY_SUPPORT_BERMAI)

            case DWPHY_BASEBAND_DAKOTA:
            case DWPHY_BASEBAND_DAKOTA2:
            case DWPHY_BASEBAND_DAKOTA2G:
            case DWPHY_BASEBAND_DAKOTA4:
            {
                uint8_t u;

                // start to wake slow components in Basie
                //
                DwPhy_WriteReg(2,5); // Set PWRSLOW = 0 (Standby)
                DwPhy_Delay(800);    // 800us delay for PWRSLOW components

                // toggle DIVNTST (with Basie to avoid PLL problem)
                //
                u=DwPhy_ReadReg(256+17);
                DwPhy_WriteReg (256+17, (u|0x80));
                DwPhy_WriteReg (256+17, (u&0x7F));

                DwPhy_CalibrateVCO(pDevInfo);

                // complete wakeup procedure
                //
                DwPhy_WriteReg(2,0); // Set all PHY components to wake state
                DwPhy_Delay(10);     // ...PHY will be ready for RX in 10us
                break;
            }

        #endif

        default: break;
    }
    return DWPHY_SUCCESS;
}
// end of DwPhy_Wake()

// ================================================================================================
// FUNCTION  : DwPhy_Sleep()
// ------------------------------------------------------------------------------------------------
// Purpose   : Sleep the PHY
// Parameters: pDevInfo -- pointer to device information structure
// ================================================================================================
dwPhyStatus_t DwPhy_Sleep(dwDevInfo_t *pDevInfo)
{
    DwPhy_t *pDwPhy = (DwPhy_t *)(pDevInfo->pDwPhy);
    dwPhyStatus_t status;

    // Turn-off DW_PHYEnB for all cases. This is required by the DW52 MAC even if not needed
    // for the PHY.
    //
    status = DwPhy_Enable(pDevInfo, 0); // de-assert DW_PHYEnB (for the MAC)
    if (status != DWPHY_SUCCESS) return status;

    // PHY-specific procedures
    //
    switch (pDwPhy->Baseband)
    {
        #if defined(DWPHY_SUPPORT_BERMAI)

            case DWPHY_BASEBAND_DAKOTA:
            case DWPHY_BASEBAND_DAKOTA2:
            case DWPHY_BASEBAND_DAKOTA2G:
            {
                DwPhy_WriteReg(2,6); // sleep the radio
                DwPhy_Delay(3000);   // 3ms delay to allow any RX to complete (work-around for baseband bug)
                DwPhy_WriteReg(2,7); // sleep the baseband also
                break;
            }

            case DWPHY_BASEBAND_DAKOTA4:
            {
                DwPhy_WriteReg(2,7); // sleep the entire PHY
                break;
            }

        #endif

        default: break;
    }
    return DWPHY_SUCCESS;
}
// end of DwPhy_Sleep()

// ================================================================================================
// FUNCTION  : DwPhy_SetRxMode()
// ------------------------------------------------------------------------------------------------
// Purpose   : Select the receiver (compatibility) mode
// Parameters: pDevInfo -- pointer to device information structure
//             RxMode   -- receiver mode (definition is part specific)
// ================================================================================================
dwPhyStatus_t DwPhy_SetRxMode(dwDevInfo_t *pDevInfo, dwPhyRxMode_t RxMode)
{
    DwPhy_t *pDwPhy = (DwPhy_t *)(pDevInfo->pDwPhy);

    if (!pDwPhy->Baseband) DwPhy_ChipSet(pDevInfo); // get the chipset IDs

    switch (pDwPhy->Baseband)
    {
        case DWPHY_BASEBAND_DAKOTA:
        case DWPHY_BASEBAND_DAKOTA2:
        case DWPHY_BASEBAND_DAKOTA2G:
        case DWPHY_BASEBAND_DAKOTA4:

            switch( RxMode )
            {
                case DWPHY_RXMODE_DEFAULT:
                case DWPHY_RXMODE_802_11A:
                    break;

                default: return DWPHY_ERROR;
            }
            break;

        case DWPHY_BASEBAND_MOJAVE:
        case DWPHY_BASEBAND_MOJAVE1B:

            //////////////////////////////////////////////////////////////////////////////////
            //
            //  The Mojave baseband can be configured to receive packets in 802.11a, 802.11b,
            //  or 802.11g mode. This is independent of the channel frequency and simply
            //  indicates whether the receiver can process DSSS/CCK, OFDM, or both modulation
            //  formats. The transmitter will handle format requested by the MAC regardless
            //  of the receiver mode.
            //
            switch( RxMode )
            {
                case DWPHY_RXMODE_DEFAULT:
                    RxMode = DWPHY_RXMODE_802_11G;

                case DWPHY_RXMODE_802_11A:
                case DWPHY_RXMODE_802_11G:
                    DwPhy_WriteReg(4, RxMode);
                    DwPhy_WriteReg(121, pDwPhy->RecordedDefaultReg.SyncTh);
                    break;

                case DWPHY_RXMODE_802_11B:
                    DwPhy_WriteReg(  4, 3);
                    DwPhy_WriteReg(121, 0x40); // SyncTh > 1...never OFDM
                    break;

                default: return DWPHY_ERROR;
            }
            break;

        case DWPHY_BASEBAND_NEVADA_FPGA:
        case DWPHY_BASEBAND_NEVADA:
        case DWPHY_BASEBAND_NEVADA1B:
        default:

            switch( RxMode )
            {
                case DWPHY_RXMODE_DEFAULT:
                    RxMode = DWPHY_RXMODE_802_11N;

                case DWPHY_RXMODE_802_11A:
                case DWPHY_RXMODE_802_11G:
                case DWPHY_RXMODE_802_11N5:
                case DWPHY_RXMODE_802_11N:
                    DwPhy_WriteReg(4, RxMode);
                    DwPhy_WriteReg(121, pDwPhy->RecordedDefaultReg.SyncTh);
                    break;

                case DWPHY_RXMODE_802_11B:
                    DwPhy_WriteReg(  4, 3);
                    DwPhy_WriteReg(121, 0x40); // SyncTh > 1...never OFDM
                    break;

                default: return DWPHY_ERROR;
            }
            break;
    }
    pDwPhy->RxMode = RxMode;
    return DWPHY_SUCCESS;
}
// end of DwPhy_SetRxMode()

// ================================================================================================
// FUNCTION  : DwPhy_GetRxSensitivity()
// ------------------------------------------------------------------------------------------------
// Purpose   : Get the signal detect sensitivity (min sensitivity limited by hardware)
// Parameters: pDevInfo -- pointer to device information structure
//             pPrdBm   -- signal detect threshold (dBm)
// ================================================================================================
dwPhyStatus_t DwPhy_GetRxSensitivity(dwDevInfo_t *pDevInfo, int8_t *pPrdBm)
{
    DwPhy_t *pDwPhy = (DwPhy_t *)(pDevInfo->pDwPhy);

    if (pDwPhy->RxSensitivity.DataIsValid)
        *pPrdBm = pDwPhy->RxSensitivity.SetPrdBm;    
    else
        *pPrdBm = DWPHY_DEFAULT_RX_SENSITIVITY;

    return DWPHY_SUCCESS;
}
// end of DwPhy_GetRxSensitivity()

// ================================================================================================
// FUNCTION  : DwPhy_LimitRange()
// ------------------------------------------------------------------------------------------------
// Purpose   : Limit the range of an integer (used in DwPhy_SetRxSensitivity)
// ================================================================================================
int DwPhy_LimitRange( int Value, int MinValue, int MaxValue )
{
    if (Value < MinValue) Value = MinValue;
    if (Value > MaxValue) Value = MaxValue;
    return Value;
}
// end of DwPhy_LimitRange()

// ================================================================================================
// FUNCTION  : DwPhy_SetRxSensitivity()
// ------------------------------------------------------------------------------------------------
// Purpose   : Set the signal detect sensitivity (min sensitivity limited by hardware)
//             This routine modifies the InitAGain register. The actual gain update requires a 
//             restart of the RX subsystem, so this routine should be called with the PHY in
//             sleep mode.
// Parameters: pDevInfo -- pointer to device information structure
//             dBm      -- signal detect threshold (dBm)
// ================================================================================================
dwPhyStatus_t DwPhy_SetRxSensitivity(dwDevInfo_t *pDevInfo, int8_t dBm)
{
    DwPhy_t *pDwPhy = (DwPhy_t *)(pDevInfo->pDwPhy);
    if (!pDwPhy->RecordedDefaultReg.DataIsValid) return DWPHY_ERROR; // call DwPhy_Initialize first

    if(!pDwPhy->Baseband) DwPhy_ChipSet(pDevInfo); // get the chipset IDs

    // Handle default setting
    if (dBm == DWPHY_DEFAULT_RX_SENSITIVITY)
        dBm = -91;

    switch(pDwPhy->Baseband)
    {
        #if defined (DWPHY_SUPPORT_BERMAI)

            case DWPHY_BASEBAND_DAKOTA:
            case DWPHY_BASEBAND_DAKOTA2:
            case DWPHY_BASEBAND_DAKOTA2G:
            case DWPHY_BASEBAND_DAKOTA4:
            {
                uint8_t  SigDetTh1, SigDetFilter;
                uint32_t SigDetTh2;

                if (dBm == DWPHY_DEFAULT_RX_SENSITIVITY) dBm = -92;

                     if(dBm <= -92) { dBm = -92; SigDetTh2 =    16; SigDetTh1 =  4; } // lookup table with 3 dB resolution
                else if(dBm <= -89) { dBm = -89; SigDetTh2 =    32; SigDetTh1 =  4; } // based on Bermai PHY report 2004-05-14
                else if(dBm <= -86) { dBm = -86; SigDetTh2 =    64; SigDetTh1 =  6; }
                else if(dBm <= -83) { dBm = -83; SigDetTh2 =   128; SigDetTh1 =  8; }
                else if(dBm <= -80) { dBm = -80; SigDetTh2 =   256; SigDetTh1 = 12; }
                else if(dBm <= -77) { dBm = -77; SigDetTh2 =   512; SigDetTh1 = 16; }
                else if(dBm <= -74) { dBm = -74; SigDetTh2 =  1024; SigDetTh1 = 16; }
                else if(dBm <= -71) { dBm = -71; SigDetTh2 =  2048; SigDetTh1 = 16; }
                else if(dBm <= -68) { dBm = -68; SigDetTh2 =  4096; SigDetTh1 = 16; }
                else if(dBm <= -65) { dBm = -65; SigDetTh2 =  8192; SigDetTh1 = 31; }
                else                { dBm = -62; SigDetTh2 = 16384; SigDetTh1 = 31; }

                SigDetFilter = (uint8_t)(DwPhy_ReadReg(112) & 0x80); // msb of register 112
                
                DwPhy_WriteReg(112, SigDetFilter | SigDetTh1);
                DwPhy_WriteReg(113, (SigDetTh2 >> 0) & 0xFF);
                DwPhy_WriteReg(114, (SigDetTh2 >> 8) & 0xFF);
                DwPhy_WriteReg(115, (SigDetTh2 >>16) & 0xFF);

                pDwPhy->RxSensitivity.SetPrdBm     = dBm;
                pDwPhy->RxSensitivity.GainOfs      = 0;
                pDwPhy->RxSensitivity.Pwr100dBmOfs = 0;
                pDwPhy->RxSensitivity.MsrPwrOfs    = 0;
                pDwPhy->RxSensitivity.DataIsValid  = 1;
                break;
            }
        #endif

        #if defined (DWPHY_SUPPORT_MOJAVE) || defined (DWPHY_SUPPORT_MOJAVE1B) || defined (DWPHY_SUPPORT_NEVADA_FPGA) || defined(DWPHY_SUPPORT_NEVADA)

            case DWPHY_BASEBAND_MOJAVE:
            case DWPHY_BASEBAND_MOJAVE1B:
            case DWPHY_BASEBAND_NEVADA_FPGA:
            case DWPHY_BASEBAND_NEVADA:
            case DWPHY_BASEBAND_NEVADA1B:
            default:
            {
                uint8_t  SigDetTh1, CQthreshold;
                uint16_t SigDetTh2;
                int8_t   dAGain, ThCCA1, ThCCA2;

                // Map Sensitivity to Detector Thresholds and Gain Offset
                //
                     if (dBm <= -97) { dBm = -97; SigDetTh1= 4; SigDetTh2= 18; CQthreshold=26; dAGain=  2; }
                else if (dBm <= -94) { dBm = -94; SigDetTh1= 4; SigDetTh2= 18; CQthreshold=26; dAGain=  0; }
                else if (dBm <= -91) { dBm = -91; SigDetTh1= 4; SigDetTh2= 36; CQthreshold=30; dAGain=  0; }
                else if (dBm <= -88) { dBm = -88; SigDetTh1= 4; SigDetTh2= 72; CQthreshold=34; dAGain=  0; }
                else if (dBm <= -85) { dBm = -85; SigDetTh1= 6; SigDetTh2=144; CQthreshold=38; dAGain=  0; }
                else if (dBm <= -82) { dBm = -82; SigDetTh1=12; SigDetTh2=287; CQthreshold=42; dAGain=  0; }
                else if (dBm <= -79) { dBm = -79; SigDetTh1=25; SigDetTh2=572; CQthreshold=46; dAGain=  0; }
                else if (dBm <= -76) { dBm = -76; SigDetTh1=32; SigDetTh2=720; CQthreshold=46; dAGain= -2; }
                else if (dBm <= -73) { dBm = -73; SigDetTh1=32; SigDetTh2=720; CQthreshold=46; dAGain= -4; }
                else if (dBm <= -70) { dBm = -70; SigDetTh1=32; SigDetTh2=720; CQthreshold=46; dAGain= -6; }
                else if (dBm <= -67) { dBm = -67; SigDetTh1=32; SigDetTh2=720; CQthreshold=46; dAGain= -8; }
                else if (dBm <= -64) { dBm = -64; SigDetTh1=32; SigDetTh2=720; CQthreshold=46; dAGain=-10; }
                else if (dBm <= -61) { dBm = -61; SigDetTh1=32; SigDetTh2=720; CQthreshold=46; dAGain=-12; }
                else if (dBm <= -58) { dBm = -58; SigDetTh1=32; SigDetTh2=720; CQthreshold=46; dAGain=-14; }
                else                 { dBm = -55; SigDetTh1=32; SigDetTh2=720; CQthreshold=46; dAGain=-16; }

                // Adjust detector thresholds
                //
                DwPhy_WriteReg(112,  SigDetTh1);
                DwPhy_WriteReg(114, (SigDetTh2 >> 0) & 0xFF);
                DwPhy_WriteReg(113, (SigDetTh2 >> 8) & 0xFF);
                DwPhy_WriteReg(162,  CQthreshold);

                // Limit gain adjustment range
                // InitAGain cannot be > 40. Limit attenuation to 2*min(ThSwitchLNA, ThTswitchLNA2)
                // so the intial gain setting is not beyond the LNA switch point
                //
                if (pDwPhy->RecordedDefaultReg.InitAGain + dAGain > 40)
                    dAGain = 40 - pDwPhy->RecordedDefaultReg.InitAGain;

                while ( (pDwPhy->RecordedDefaultReg.ThSwitchLNA  + dAGain < 0)
                      ||(pDwPhy->RecordedDefaultReg.ThSwitchLNA2 + dAGain < 0) )
                {
                    dAGain += 2;
                    dBm    += 3;
                }
                // Adjust gain settings
                //
                DwPhy_WriteReg( 65,  pDwPhy->RecordedDefaultReg.InitAGain    + dAGain);
                DwPhy_WriteReg( 73,  pDwPhy->RecordedDefaultReg.ThSwitchLNA  + dAGain);
                DwPhy_WriteReg( 75,  pDwPhy->RecordedDefaultReg.ThSwitchLNA2 + dAGain);

                // Adjust CCA thresholds
                //
                switch (pDwPhy->Baseband)
                {
                    case DWPHY_BASEBAND_MOJAVE:
                    case DWPHY_BASEBAND_MOJAVE1B:

                        ThCCA1 = pDwPhy->RecordedDefaultReg.ThCCA1 + 2*dAGain;
                        ThCCA2 = pDwPhy->RecordedDefaultReg.ThCCA2 + 2*dAGain;
                        if (ThCCA1 <  0) ThCCA1 =  0; // cannot be negative
                        if (ThCCA2 < 12) ThCCA2 = 12; // keep >= 12 to avoid false CCA on RadioIF/ADC noise
                        DwPhy_WriteReg( 78,  ThCCA1);
                        DwPhy_WriteReg( 79,  ThCCA2);
                        break;

                    case DWPHY_BASEBAND_NEVADA_FPGA:
                    case DWPHY_BASEBAND_NEVADA:
                    case DWPHY_BASEBAND_NEVADA1B:
                    default:
                        
                        DwPhy_WriteReg( 241, (uint8_t)DwPhy_LimitRange( pDwPhy->RecordedDefaultReg.ThCCA_SigDet + 2*dAGain,  0, 255) );
                        DwPhy_WriteReg( 242, (uint8_t)DwPhy_LimitRange( pDwPhy->RecordedDefaultReg.ThCCA_RSSI1  + 2*dAGain, 12, 255) );
                        DwPhy_WriteReg( 243, (uint8_t)DwPhy_LimitRange( pDwPhy->RecordedDefaultReg.ThCCA_RSSI2  + 2*dAGain,  0, 255) );
                        DwPhy_WriteReg( 244, (uint8_t)DwPhy_LimitRange( pDwPhy->RecordedDefaultReg.ThCCA_GF1    + 2*dAGain,  0, 255) );
                        DwPhy_WriteReg( 245, (uint8_t)DwPhy_LimitRange( pDwPhy->RecordedDefaultReg.ThCCA_GF2    + 2*dAGain,  0, 255) );
                        break;
                }
                // Record settings
                //
                pDwPhy->RxSensitivity.SetPrdBm     = dBm;
                pDwPhy->RxSensitivity.GainOfs      = dAGain;
                pDwPhy->RxSensitivity.Pwr100dBmOfs = 0;
                pDwPhy->RxSensitivity.MsrPwrOfs    = -3*dAGain/2;
                pDwPhy->RxSensitivity.DataIsValid  = 1;
                break;
            }
        #else
            default: return DWPHY_ERROR_UNSUPPORTED_CHIPSET;
        #endif
    }
    return DWPHY_SUCCESS;
}
// end of DwPhy_SetRxSensitivity()

// ================================================================================================
// FUNCTION  : DwPhy_ConfigureSouthic()
// ------------------------------------------------------------------------------------------------
// Purpose   : Configure the Southic AFE module used on the DMW96 FPGA platform
// Parameters: none
// ================================================================================================
dwPhyStatus_t DwPhy_ConfigureSouthic(dwDevInfo_t *pDevInfo)
{
    ////////////////////////////////////////////////////////////////////////////////
    //
    //  Southic DAC programming on the Nevada FPGA platform (DMW96 WLAN)
    //
    //  Write the 10-bit word 0x120 onto the "I" path of the DAC. Use TxWordR to
    //  do this, noting that the offset-binary format at the DAC must be placed into
    //  two's complement at the TxIQSource multiplexer. Because the MSB is zero,
    //  no actual conversion is required. The word is latched on the rising edge of
    //  DAC signal CW\, which is mapped to SW2.
    //
    if (DwPhy_BasebandID(pDevInfo) == DWPHY_BASEBAND_NEVADA_FPGA)
    {
        uint8_t X007 = DwPhy_ReadReg( 0x007 );
        uint8_t X00A = DwPhy_ReadReg( 0x00A );
        uint8_t X08C = DwPhy_ReadReg( 0x08C );
        uint8_t X08D = DwPhy_ReadReg( 0x08D );

        DwPhy_WriteReg( 0x08C, 0x03 ); // TxWordR[9:8]
        DwPhy_WriteReg( 0x08D, 0x20 ); // TxWordR[7:0]
        DwPhy_WriteReg( 0x00A, 0x81 ); // Set TxIQSrcRun = 1
        DwPhy_WriteReg( 0x007, 0xF0 ); // Set TxIQSrc = TxWord
        DwPhy_WriteReg( 0x0E5, 0x00 ); // SW2B = 0, SW2 = 0
        DwPhy_WriteReg( 0x0E5, 0x0F ); // SW2B = 0, SW2 = 1

        DwPhy_WriteReg( 0x007, X007 );
        DwPhy_WriteReg( 0x00A, X00A );
        DwPhy_WriteReg( 0x08C, X08C );
        DwPhy_WriteReg( 0x08D, X08D );
    }
    return DWPHY_SUCCESS;
}
// end of DwPhy_ConfigureSouthic()

// ================================================================================================
// FUNCTION  : DwPhy_Reset()
// ------------------------------------------------------------------------------------------------
// Purpose   : Reset the PHY (baseband and radio)
// Parameters: pDevInfo -- pointer to device information structure
// ================================================================================================
dwPhyStatus_t DwPhy_Reset(dwDevInfo_t *pDevInfo)
{
    switch (DwPhy_BasebandID(pDevInfo))
    {
        case DWPHY_BASEBAND_DAKOTA:
        case DWPHY_BASEBAND_DAKOTA2:
        case DWPHY_BASEBAND_DAKOTA2G:
        case DWPHY_BASEBAND_DAKOTA4:
        {
            DwPhy_WriteReg(0,1); // The Dakota MAC asserts MAC_RESETB when it sees a write to baseband
            DwPhy_WriteReg(0,0); // ...register 0.
            break;
        }

        case DWPHY_BASEBAND_NEVADA_FPGA:
        {
            uint32_t DataBSWRSTR = OS_RegRead( 0x80000000 | CMU_BSWRSTR ); 

            OS_RegWrite( 0x80000000 | CMU_BSWRSTR, DataBSWRSTR | 0x0002 ); // enable  BB reset  (bit 1)
            OS_RegWrite( 0x80000000 | CMU_BSWRSTR, DataBSWRSTR & 0xFFFD ); // release BB reset  
            break;
        }
        
        case DWPHY_BASEBAND_MOJAVE:
        case DWPHY_BASEBAND_MOJAVE1B:
        {
            uint32_t DataCSR0    = OS_RegRead( CMU_CSR0    ); // read initial register values
            uint32_t DataBSWRSTR = OS_RegRead( CMU_BSWRSTR ); 

            OS_RegWrite( CMU_CSR0,    DataCSR0    & 0xFBFF ); // disable BB clocks (bit 10)
            OS_RegWrite( CMU_BSWRSTR, DataBSWRSTR | 0x0002 ); // enable  BB reset  (bit 1)
            OS_RegWrite( CMU_BSWRSTR, DataBSWRSTR & 0xFFFD ); // release BB reset  
            OS_RegWrite( CMU_CSR0,    DataCSR0    | 0x0400 ); // enable  BB clocks

            /////////////////////////////////////////////////////////////////////////////////
            //
            //  The code below is necessary to reset the RFIC with DW74 because the RESETB
            //  pad on the ASIC is configured as an input when the baseband clock is disabled.
            //
            DwPhy_WriteReg(237, 0x05); // RESETB = 0 (active low reset)
            DwPhy_Delay(1);            // wait 1 microsecond
            DwPhy_WriteReg(237, 0x85); // RESETB = 1
            break;
        }
        case DWPHY_BASEBAND_NEVADA:
        case DWPHY_BASEBAND_NEVADA1B:
        default:
        {
            /////////////////////////////////////////////////////////////////////////////////
            //
            //  Radio Reset Only
            //  On DMW96, resets are handled outside of DwPhy, but reset the radio anyway
            //  because we have seen issues with the RF52 serial port without a reset.
            //
            DwPhy_WriteReg(237, 0x05); // RESETB = 0 (active low reset)
            DwPhy_Delay(1);            // wait 1 microsecond
            DwPhy_WriteReg(237, 0x85); // RESETB = 1
            break;
        }
    }
    return DWPHY_SUCCESS;
}
// end of DwPhy_Reset()

// ================================================================================================
// FUNCTION  : DwPhy_DefaultRegisters()
// ------------------------------------------------------------------------------------------------
// Purpose   : Return a pointer to an array of default registers
// Parameters: Chippset    -- aggregate baseband and radio part IDs
//             pNumReg     -- number of registers in the DefaultReg structure (output)
//             pDefaultReg -- address/value pairs (output)
// ================================================================================================
dwPhyStatus_t DwPhy_DefaultRegisters(int32_t Chipset, uint32_t *pNumReg, dwPhyRegPair_t **pDefaultReg)
{
    switch (Chipset)
    {
        #if defined(DWPHY_SUPPORT_BERMAI)

            // Dakota 2/2g + Basie C
            //
            case CHIPSET( DWPHY_BASEBAND_DAKOTA2,  DWPHY_RADIO_NONE     ):
            case CHIPSET( DWPHY_BASEBAND_DAKOTA2G, DWPHY_RADIO_NONE     ):
            case CHIPSET( DWPHY_BASEBAND_DAKOTA2,  DWPHY_RADIO_BASIE_C1 ):
            case CHIPSET( DWPHY_BASEBAND_DAKOTA2G, DWPHY_RADIO_BASIE_C1 ):
            {
                *pNumReg = sizeof(DefaultReg_Dakota2_BasieC) / sizeof(dwPhyRegPair_t);
                *pDefaultReg = (dwPhyRegPair_t *)DefaultReg_Dakota2_BasieC;
                break;
            }

            // Dakota4 + Basie C
            // Bob 4.2 configuration used with Broadtile and pre-DW52 PHY MAC bringup.
            // 
            case CHIPSET( DWPHY_BASEBAND_DAKOTA4, DWPHY_RADIO_BASIE_C1 ):
            case CHIPSET( DWPHY_BASEBAND_DAKOTA4, DWPHY_RADIO_BASIE_C2 ):
            case CHIPSET( DWPHY_BASEBAND_DAKOTA4, DWPHY_RADIO_BASIE_C3 ):
            {
                *pNumReg = sizeof(DefaultReg_Dakota4_BasieC_Bob42) / sizeof(dwPhyRegPair_t);
                *pDefaultReg = (dwPhyRegPair_t *)DefaultReg_Dakota4_BasieC_Bob42;
                break;
            }

        #endif // defined(DWPHY_SUPPORT_BERMAI)

        // Mojave + RF52Axxx (or Nadine adapter)
        // This is the ExpediBlue (Mojave/DW52) with Debby-A (RF52A120) configuration
        //
        #if defined(DWPHY_SUPPORT_MOJAVE) || defined(DWPHY_SUPPORT_MOJAVE1B)

            case CHIPSET( DWPHY_BASEBAND_MOJAVE,   DWPHY_RADIO_NONE ):
            case CHIPSET( DWPHY_BASEBAND_MOJAVE1B, DWPHY_RADIO_NONE ):
            {
                *pNumReg = sizeof(DefaultReg_Mojave_Nadine) / sizeof(dwPhyRegPair_t);
                *pDefaultReg = (dwPhyRegPair_t *)DefaultReg_Mojave_Nadine;
                break;
            }
            case CHIPSET( DWPHY_BASEBAND_MOJAVE,   DWPHY_RADIO_RF52A120 ):
            case CHIPSET( DWPHY_BASEBAND_MOJAVE1B, DWPHY_RADIO_RF52A120 ):
            {
                *pNumReg = sizeof(DefaultReg_Mojave_RF52A120) / sizeof(dwPhyRegPair_t);
                *pDefaultReg = (dwPhyRegPair_t *)DefaultReg_Mojave_RF52A120;
                break;
            }
            case CHIPSET( DWPHY_BASEBAND_MOJAVE,   DWPHY_RADIO_RF52A321 ):
            case CHIPSET( DWPHY_BASEBAND_MOJAVE1B, DWPHY_RADIO_RF52A321 ):
            case CHIPSET( DWPHY_BASEBAND_MOJAVE,   DWPHY_RADIO_RF52A421 ):
            case CHIPSET( DWPHY_BASEBAND_MOJAVE1B, DWPHY_RADIO_RF52A421 ):
            case CHIPSET( DWPHY_BASEBAND_MOJAVE,   DWPHY_RADIO_RF52A521 ):
            case CHIPSET( DWPHY_BASEBAND_MOJAVE1B, DWPHY_RADIO_RF52A521 ):
            {
                *pNumReg = sizeof(DefaultReg_Mojave_RF52A321) / sizeof(dwPhyRegPair_t);
                *pDefaultReg = (dwPhyRegPair_t *)DefaultReg_Mojave_RF52A321;
                break;
            }
            case CHIPSET( DWPHY_BASEBAND_MOJAVE,   DWPHY_RADIO_RF52B21 ):
            case CHIPSET( DWPHY_BASEBAND_MOJAVE1B, DWPHY_RADIO_RF52B21 ):
            {
                *pNumReg = sizeof(DefaultReg_Mojave_RF52B21) / sizeof(dwPhyRegPair_t);
                *pDefaultReg = (dwPhyRegPair_t *)DefaultReg_Mojave_RF52B21;
                break;
            }
            case CHIPSET( DWPHY_BASEBAND_MOJAVE,   DWPHY_RADIO_RF52B31 ):
            case CHIPSET( DWPHY_BASEBAND_MOJAVE1B, DWPHY_RADIO_RF52B31 ):
            {
                *pNumReg = sizeof(DefaultReg_Mojave_RF52B31) / sizeof(dwPhyRegPair_t);
                *pDefaultReg = (dwPhyRegPair_t *)DefaultReg_Mojave_RF52B31;
                break;
            }
            case CHIPSET( DWPHY_BASEBAND_MOJAVE,   DWPHY_RADIO_RF22A01 ):
            case CHIPSET( DWPHY_BASEBAND_MOJAVE1B, DWPHY_RADIO_RF22A01 ):
            case CHIPSET( DWPHY_BASEBAND_MOJAVE,   DWPHY_RADIO_RF22A02 ):
            case CHIPSET( DWPHY_BASEBAND_MOJAVE1B, DWPHY_RADIO_RF22A02 ):
            {
                *pNumReg = sizeof(DefaultReg_Mojave_RF22A02) / sizeof(dwPhyRegPair_t);
                *pDefaultReg = (dwPhyRegPair_t *)DefaultReg_Mojave_RF22A02;
                break;
            }
            case CHIPSET( DWPHY_BASEBAND_MOJAVE,   DWPHY_RADIO_RF22A11 ):
            case CHIPSET( DWPHY_BASEBAND_MOJAVE1B, DWPHY_RADIO_RF22A11 ):
            case CHIPSET( DWPHY_BASEBAND_MOJAVE,   DWPHY_RADIO_RF22A12 ):
            case CHIPSET( DWPHY_BASEBAND_MOJAVE1B, DWPHY_RADIO_RF22A12 ):
            {
                *pNumReg = sizeof(DefaultReg_Mojave_RF22A12) / sizeof(dwPhyRegPair_t);
                *pDefaultReg = (dwPhyRegPair_t *)DefaultReg_Mojave_RF22A12;
                break;
            }
        #endif // defined(DWPHY_SUPPORT_MOJAVE) || defined(DWPHY_SUPPORT_MOJAVE1B)


        #if defined(DWPHY_SUPPORT_NEVADA_FPGA)

            case CHIPSET( DWPHY_BASEBAND_NEVADA_FPGA, DWPHY_RADIO_NONE    ):
            case CHIPSET( DWPHY_BASEBAND_NEVADA_FPGA, DWPHY_RADIO_RF52B31 ):
            {
                *pNumReg = sizeof(DefaultReg_NevadaFPGA_RF52B31) / sizeof(dwPhyRegPair_t);
                *pDefaultReg = (dwPhyRegPair_t *)DefaultReg_NevadaFPGA_RF52B31;
                break;
            }
            case CHIPSET( DWPHY_BASEBAND_NEVADA_FPGA, DWPHY_RADIO_RF22A11 ):            
            case CHIPSET( DWPHY_BASEBAND_NEVADA_FPGA, DWPHY_RADIO_RF22A12 ):
            {
                *pNumReg = sizeof(DefaultReg_NevadaFPGA_RF22A12) / sizeof(dwPhyRegPair_t);
                *pDefaultReg = (dwPhyRegPair_t *)DefaultReg_NevadaFPGA_RF22A12;
                break;
            }
        #endif

        // Nevada + RF52Axxx (or Nadine adapter)
        // This is the XpandR III (Nevada/DMW96) configuration
        //
        #if defined(DWPHY_SUPPORT_NEVADA)

            case CHIPSET( DWPHY_BASEBAND_NEVADA,      DWPHY_RADIO_NONE    ):
            case CHIPSET( DWPHY_BASEBAND_NEVADA1B,    DWPHY_RADIO_NONE    ):
            {
                *pNumReg = sizeof(DefaultReg_Nevada_Nadine) / sizeof(dwPhyRegPair_t);
                *pDefaultReg = (dwPhyRegPair_t *)DefaultReg_Nevada_Nadine;
                break;
            }
            case CHIPSET( DWPHY_BASEBAND_NEVADA,      DWPHY_RADIO_RF52B31 ):
            case CHIPSET( DWPHY_BASEBAND_NEVADA1B,    DWPHY_RADIO_RF52B31 ):
            {
                *pNumReg = sizeof(DefaultReg_Nevada_RF52B31) / sizeof(dwPhyRegPair_t);
                *pDefaultReg = (dwPhyRegPair_t *)DefaultReg_Nevada_RF52B31;
                break;
            }
            case CHIPSET( DWPHY_BASEBAND_NEVADA     , DWPHY_RADIO_RF22A11 ):            
            case CHIPSET( DWPHY_BASEBAND_NEVADA     , DWPHY_RADIO_RF22A12 ):
            case CHIPSET( DWPHY_BASEBAND_NEVADA1B   , DWPHY_RADIO_RF22A11 ):            
            case CHIPSET( DWPHY_BASEBAND_NEVADA1B   , DWPHY_RADIO_RF22A12 ):
			{
				*pNumReg = sizeof(DefaultReg_Nevada_RF22A12) / sizeof(dwPhyRegPair_t); 
                *pDefaultReg = (dwPhyRegPair_t *)DefaultReg_Nevada_RF22A12;
                break;
			}
            case CHIPSET( DWPHY_BASEBAND_NEVADA     , DWPHY_RADIO_RF22B02 ):
            case CHIPSET( DWPHY_BASEBAND_NEVADA1B   , DWPHY_RADIO_RF22B02 ):
            default:
            {
                *pNumReg = sizeof(DefaultReg_Nevada_RF22B0) / sizeof(dwPhyRegPair_t); 
                *pDefaultReg = (dwPhyRegPair_t *)DefaultReg_Nevada_RF22B0;
                break;
            }
        #endif
    }
    return DWPHY_SUCCESS;
}
// end of DwPhy_DefaultRegisters()

// ================================================================================================
// FUNCTION  : DwPhy_Initialize()
// ------------------------------------------------------------------------------------------------
// Purpose   : Initialize the PHY (baseband + radio)
// Parameters: pDevInfo -- pointer to device information structure
// Notes     : The PHY should be initialized with DW_PHYEnB = 1
// ================================================================================================
dwPhyStatus_t DwPhy_Initialize(dwDevInfo_t *pDevInfo, dwPhyPlatform_t PlatformID)
{
    dwPhyRegPair_t *DefaultReg;
    dwPhyStatus_t   status;
    uint32_t NumReg, i;

    DwPhy_t *pDwPhy = (DwPhy_t *)(pDevInfo->pDwPhy);

    switch (PlatformID)
    {
        case DWPHY_PLATFORM_DEFAULT:
        case DWPHY_PLATFORM_VERSATILE_FPGA:
        case DWPHY_PLATFORM_DMW96:
            pDwPhy->PlatformID = PlatformID;
            break;

        default: return DWPHY_ERROR_UNSUPPORTED_PLATFORM;
    }

    DwPhy_Reset  (pDevInfo); // reset in case SRFreq or SREdge is wrong
    DwPhy_ChipSet(pDevInfo); // read the part IDs

    // Reset the PHY
    //
    switch( pDwPhy->Baseband )
    {
        case DWPHY_BASEBAND_MOJAVE:
        case DWPHY_BASEBAND_MOJAVE1B:
        case DWPHY_BASEBAND_NEVADA:
        case DWPHY_BASEBAND_NEVADA1B:
        default:
            status = DwPhy_Enable( pDevInfo, 0 ); // make sure the PHY is not enabled
            if (status != DWPHY_SUCCESS) return DWPHY_ERROR;
            break;
    }
    DwPhy_Reset(pDevInfo);

    // ---------------------------------
    // Retrieve the default register set
    // ---------------------------------
    if ((status = DwPhy_DefaultRegisters(pDwPhy->Chipset, &NumReg, &DefaultReg)) != DWPHY_SUCCESS)
        return status;

    // --------------
    // Initialization
    // --------------
    for (i=0; i<NumReg; i++) 
    {
        DwPhy_WriteReg(DefaultReg[i].addr, DefaultReg[i].data);
    }
    // Load user supplied default values
    //
    if (pDwPhy->pDefaultReg)
    {
        for (i=0; i<pDwPhy->DefaultRegLength; i++) {
            DwPhy_WriteReg(pDwPhy->pDefaultReg[i].addr, pDwPhy->pDefaultReg[i].data);
        }
    }
    //  Southic DAC programming on the Nevada FPGA platform (DMW96 WLAN)
    //
    if (pDwPhy->Baseband == DWPHY_BASEBAND_NEVADA_FPGA)
        DwPhy_ConfigureSouthic(pDevInfo);

    // Record default gain settings and configure for default sensitivity
    //
    DwPhy_RecordDefaultReg(pDevInfo);
    DwPhy_SetRxSensitivity(pDevInfo, DWPHY_DEFAULT_RX_SENSITIVITY); 

    return DWPHY_SUCCESS;
}
// end of DwPhy_Initialize()

// ================================================================================================
// FUNCTION  : DwPhy_Startup()
// ------------------------------------------------------------------------------------------------
// Purpose   : Shartup DwPhy operation. This is an initialization routine for the 'C' module as
//             opposed to DwPhy_Initialize which is an initialization for the PHY hardware. The
//             complementary function is DwPhy_Shutdown.
// Parameters: pDevInfo -- pointer to device information structure
// ================================================================================================
dwPhyStatus_t DwPhy_Startup(dwDevInfo_t *pDevInfo)
{
    DwPhy_t *pDwPhy = OS_MemAlloc( sizeof(DwPhy_t), 0 );
    if (pDwPhy == NULL) return DWPHY_ERROR_MEMORY_ALLOCATION;

    pDevInfo->pDwPhy = pDwPhy;

    // Initialize the structure to all-zeros.
    // Additionally, intialize critical values. Typically these are set to 0 which is redundant
    // with the OS_MemSet call. However, the explicit assignment highlights critical parameters.
    //
    OS_MemSet(pDwPhy, 0, sizeof(DwPhy_t));

    pDwPhy->Chipset = 0;
    pDwPhy->ChipsetAlias = 0;
    
    pDwPhy->RxSensitivity.DataIsValid = 0;
    pDwPhy->RecordedDefaultReg.DataIsValid = 0;

    pDwPhy->pDefaultReg   = NULL;
    pDwPhy->pRegByBand    = NULL;
    pDwPhy->pRegByChanl   = NULL;
    pDwPhy->pRegByChanl24 = NULL;
    pDwPhy->DwPhyEnableFn = NULL;

    return DWPHY_SUCCESS;
}
// end of DwPhy_Startup()

// ================================================================================================
// FUNCTION  : DwPhy_Shutdown()
// ------------------------------------------------------------------------------------------------
// Purpose   : Shutdown the DwPhy module and free any allocated memory
// Parameters: pDevInfo -- pointer to device information structure
// ================================================================================================
dwPhyStatus_t DwPhy_Shutdown(dwDevInfo_t *pDevInfo)
{
    DwPhy_t *pDwPhy = (DwPhy_t *)(pDevInfo->pDwPhy);

    // Clear programmed data
    //
    pDwPhy->ChipsetAlias = 0;

    // Free any memory allocated in pDevInfo->DwPhy
    //
    if (pDwPhy->pDefaultReg != NULL)
    {
        OS_MemFree( pDwPhy->pDefaultReg, 
                    pDwPhy->DefaultRegLength * sizeof(dwPhyRegPair_t) );
        pDwPhy->pDefaultReg = NULL;
        pDwPhy->DefaultRegLength = 0;
    }

    if (pDwPhy->pRegByBand != NULL)
    {
        OS_MemFree( pDwPhy->pRegByBand, 
                    pDwPhy->RegByBandLength * sizeof(dwPhyRegByBand_t) );
        pDwPhy->pRegByBand = NULL;
        pDwPhy->RegByBandLength = 0;
    }

    if (pDwPhy->pRegByChanl != NULL)
    {
        OS_MemFree( pDwPhy->pRegByChanl, 
                    pDwPhy->RegByChanlLength * sizeof(dwPhyRegByChanl_t) );
        pDwPhy->pRegByChanl = NULL;
        pDwPhy->RegByChanlLength = 0;
    }
    if (pDwPhy->pRegByChanl24 != NULL)
    {
        OS_MemFree( pDwPhy->pRegByChanl24, 
                    pDwPhy->RegByChanl24Length * sizeof(dwPhyRegByChanl24_t) );
        pDwPhy->pRegByChanl24 = NULL;
        pDwPhy->RegByChanl24Length = 0;
    }
    // Lastly, free the DwPhy private data structure
    //
    OS_MemFree( pDevInfo->pDwPhy, sizeof(DwPhy_t) );
    pDevInfo->pDwPhy = NULL;

    return DWPHY_SUCCESS;
}
// end of DwPhy_Shutdown()

// ================================================================================================
// FUNCTION  : DwPhy_CalibrateXtal()
// ------------------------------------------------------------------------------------------------
// Purpose   : Perform RF22A  cristal  calibration (REFOSCTUNE).             
// Parameters: pDevInfo -- pointer to device information structure
// ================================================================================================
#define     CFO_THRESHOLD       3

dwPhyStatus_t DwPhy_CalibrateXtal(dwDevInfo_t *pDevInfo)
{
    int8_t  Delta_CFO;
    uint8_t Refrostune ;
    int16_t New_Refrostune; 

    Delta_CFO = DwPhy_ReadReg(193);                                     // read  CFO from BB    , 8 signed bits 
    if (!((Delta_CFO<CFO_THRESHOLD)&&(Delta_CFO >-CFO_THRESHOLD)))      // check if |Delta_CFO|< 3
    {
        Refrostune =  DwPhy_ReadReg(RF_ADDR_OFFSET+21);                 // read  REFOSCTUNE from RF , 8 unsigned  bits   
        New_Refrostune = Refrostune - 3* Delta_CFO;
        if ((New_Refrostune <= 0x7f)&&(New_Refrostune >= 0))            // check if New_Refrostune is valid
        {
#ifdef DWPHY_DEBUG
            mexPrintf(" DwPhy_CalibrateXtal:  Delta_CFO =  %d, Refrostune =  %d, New_Refrostune = %d \n",Delta_CFO,Refrostune,New_Refrostune);
#endif
            DwPhy_WriteReg(RF_ADDR_OFFSET+21,New_Refrostune); 
        }
        else
        {
#ifdef DWPHY_DEBUG
             mexPrintf(" DwPhy_CalibrateXtal:  Delta_CFO =  %d, Refrostune =  %d, New_Refrostune = %d out of range !!!  \n",Delta_CFO,Refrostune,New_Refrostune);
#endif
        }
        return DWPHY_ERROR_XTAL_CAL_FAILED;
    }
    else
#ifdef DWPHY_DEBUG
        mexPrintf(" DwPhy_CalibrateXtal:  Delta_CFO =  %d, |Delta_CFO|<CFO_THRESHOLD = %d,  No need calibration    \n",Delta_CFO,CFO_THRESHOLD);
#endif
return DWPHY_SUCCESS;
}
// ================================================================================================
// FUNCTION  : DwPhy_CalibrateRxLPF()
// ------------------------------------------------------------------------------------------------
// Purpose   : Perform Rx LPF alone  calibration 
// Parameters: 
// ================================================================================================
#define     MAX_RXFILTTRIMOUT   14
#define     MIN_RXFILTTRIMOUT   10
#define     LPFCAL_DONE         BIT(5)
#define     WAIT_STBY2RX_RX_LPF 50
#define     WAIT_LIMIT_RX_LPF   150
#define     WAIT_STEP_RX_LPF    20

#define     CALMODE_RX_LPF      5

dwPhyStatus_t DwPhy_CalibrateRxLPF(dwDevInfo_t *pDevInfo)
{
    uint8_t WaitLimit = WAIT_LIMIT_RX_LPF;
    uint8_t DefaultReg224;
#ifdef DWPHY_DEBUG
        mexPrintf(" DwPhy_CalibrateRxLPF before :  RX_Filter_trim =  %d\n", (DwPhy_ReadReg(RF_ADDR_OFFSET+109)& 0xF));
#endif
    DefaultReg224 = DwPhy_ReadReg(224);                                 // get& save DefaultReg224              BB
    DwPhy_WriteReg(224, 0x55);                                          // bring radio  to Standby           
    DwPhy_WriteRegField( 0x8000 | (128-128), 0x0F, CALMODE_RX_LPF);     // enable Rx LPF calibration
    
    while ((DwPhy_ReadReg(RF_ADDR_OFFSET+106)& BIT(5)) == 0 && WaitLimit != 0)    // check if LPFCAL_DONE
    {   
		DwPhy_Delay(WAIT_STEP_RX_LPF);
        WaitLimit--;
    }
    
    DwPhy_WriteRegField( 0x8000 | (128-128), 0x0F, 0x00);               // disable Rx LPF calibration
    DwPhy_WriteReg(224,DefaultReg224);                                  // restore DefaultReg224            BB   

#ifdef DWPHY_DEBUG
        mexPrintf(" DwPhy_CalibrateRxLPF after:  RX_Filter_trim =  %d, WaitLimit = %d\n", (DwPhy_ReadReg(RF_ADDR_OFFSET+109)& 0xF),WaitLimit);
#endif

	if (WaitLimit) return DWPHY_SUCCESS;
    else           return DWPHY_ERROR_RXLPF_CAL_FAILED;
}
/*
    uint8_t DefaultReg224;
    uint8_t RX_Filter_trim;                                     // RX Filter trim readback from filter calibration.
    uint8_t WaitLimit = WAIT_LIMIT_RX_LPF;

    RX_Filter_trim =  DwPhy_ReadReg(RF_ADDR_OFFSET+109)& 0xF;   // read    RX_Filter_trim    RF
#ifdef DWPHY_DEBUG
        mexPrintf(" DwPhy_CalibrateRxLPF:  RX_Filter_trim =  %d\n",RX_Filter_trim);
#endif

    if  ((RX_Filter_trim >= MAX_RXFILTTRIMOUT) || (RX_Filter_trim <= MIN_RXFILTTRIMOUT))
    {
        DefaultReg224 = DwPhy_ReadReg(224);                     // get& save DefaultReg224              BB
        DwPhy_WriteRegField(RF_ADDR_OFFSET+105,BIT(6),BIT(6));      // set FILTCALEN to  <1> : Rx->STDBY    RF
        DwPhy_WriteReg(224,0xFF );                              //  88  Set Rx  target  for all states        RX/Active: MC[1:0] = 11       BB
        DwPhy_Delay(WAIT_STBY2RX_RX_LPF);                       // wait for standby-to-RX (conservative) 
        DwPhy_WriteReg(224,0x55 );                              //  55  Set StandBy    target  for all states  StandBy/Active: MC[1:0] = 01 BB 

        while ((DwPhy_ReadReg(RF_ADDR_OFFSET+106)& BIT(5)) == 0 && WaitLimit != 0)    // check if LPFCAL_DONE
        {
            DwPhy_Delay(WAIT_STEP_RX_LPF);
            WaitLimit--; 
        }

        RX_Filter_trim =  DwPhy_ReadReg(RF_ADDR_OFFSET+109)& 0xF;   // read    RX_Filter_trim  again    RF
        DwPhy_WriteReg(224,DefaultReg224);                          // restore DefaultReg224            BB    
#ifdef DWPHY_DEBUG
        mexPrintf(" DwPhy_CalibrateXtal:  RX_Filter_trim last  =  %d, WaitLimit =  %d\n",RX_Filter_trim,WaitLimit);
#endif

        if   ((RX_Filter_trim >= MAX_RXFILTTRIMOUT) || (RX_Filter_trim <= MIN_RXFILTTRIMOUT))
            return DWPHY_ERROR_RXLPF_CAL_FAILED;
        else
            return DWPHY_SUCCESS;
    }
    else
        return DWPHY_SUCCESS;
*/
//-------------------------------------------------------------------------------------------------
//--- End of Source Code --------------------------------------------------------------------------

// Revised 2008-02-11
// - Updated thresholds for DwPhyLab_SetRxSensitivity
// - Added basic parameter tuning interface
// - Added support for RF52A521 to match A321/A421 but without manual close-loop VCO calibration
// - Removed DsMode from the channel map and localized to the RF52A channel selection
//
// Revised 2008-02-21
// - Incorporated corrections from Chuck (2/20/08)
// - Added reset before reading chipset in DwPhy_Initialize. If SRFreq or SREdge are set badly,
//   readback of the radio part ID may fail. Reset puts these at nominal values.
//
// Revised 2008-03-14
// - Changed baseband register 0x50 from 0x12 to 0x02 for all Mojave+??? configurations. The change
//   sets UpdateOnLNA=0 to avoid a problem where excess gain updates could occur near the LNA
//   switch power.
// - Changed baseband register 0xD9 from 0x33 to 0x30 for all Mojave configurations. This change
//   reduces DelayPA from 3 to 0 causing the PA to enable with the radio. The change provides a
//   small EVM improvement in at least one case.
//
// Revised 2008-03-17
// - Converted DwPhy private structure to a dynamically allocated element
// - Added function DwPhy_Startup to initialize this dynamic element
// - Added OsCopyFromUser calls to copy parameter data from user space to driver-safe memory
//
// Revised 2008-03-19
// - Added register defaults to enable TX ALC for A321 with a compiler defined (default = not used)
//
// Revised 2008-04-04
// - Changed RF52B0* labels to RF52B1* to reflect pre-fab metal spin
// - Added preliminary registers for RF52B11 on Debby-D with no external LNA
//
// Revised 2008-04-30
// - Improved error handling in DwPhy_SetParameterData per JYoung
//
// Revised 2008-05-20
// - DwPhy_SetChannel_RF52A: Added delay during open-loop calibration before resetting SPISTRTSEL
// - DwPhy_SetChannel_RF52A: Increase delay after setting channel from 20 to 207 usec
// - DwPhy_SetChannel_RF52A: Add one closed-loop calibration after setting RegByBand
// - Changed DelayFCAL2 from 3 to 4 and DelayModem from 1 to 2 for RF52A321 and later
// - Changed DACHI, DACLO settings by band for RF52A321/A521
// - Increase DelayStdby from 20 to 28 usec for CLC settling time on wake
// - Increase WakeupTime from 220 to 255 usec for additional margin
// - DwPhy_PllClosedLoopCalibration: change pDwPhy->Radio to DwPhy_RadioID(pDevInfo)
// - DwPhy_PllClosedLoopCalibration: operates for all RF52A and RF52B11 radios
// - Removed all code related to TX ALC for A321
//
// Revised 2008-05-22
// - Added non-tuned support for RF52B21 and B22 to enable PHY bringup
// - Changed DelayPA from 0 to 3 (Register 0x0D9[3:0]) [rollback to 080214a release]
//   Testing with a Cisco 1242 AP showed problems with DelayPA = 0
// - Changed TimeExtend from 33 to 15 (Register 0x0DC) to just cover OFDM SIFS The original
//   value gives slightly better power consumption but increases the potential for problems
//   when AddressFilter is enable.
//
// Revised 2008-05-26
// - Added range checking on register addresses supplied through DwPhy_SetParameterData
// - Modified Sleep-to-RX timing to be consistent with Mojave Architecture Spec. Fig. 8.7
//    + Changed SigDetDelay from 162 to 130 (Register 0x073)
//    + Changed DelayBGEnB  from   8 to  12 (Register 0x0D3)
//    + Changed DelayADC1   from   8 to  12 (Register 0x0D4)
//    + Changed DelayModem  from   4 to   7 (Register 0x0D6)...is 5 in the figure
//    + Changed DelayDFE    from   2 to   7 (Register 0x0D7)
//    + Changed DelayFCAL1  from   3 to   8 (Register 0x0D9[7:4])
// - Modified TX-to-RX timing to be consistent with Mojave Architecture Spec. Fig. 8.8
//    + Changed TxRxTime    from   8 to  12 (Register 0x0D8[3:0])
//    + Changed DelayRFSW   from   6 to  11 (Register 0x0D8[7:4])...TxRxTime - 1
//    + Changed DelayADC2   from   8 to  12 (Register 0x0D5)
//    + Changed DelayFCAL2  from   4 to   8 (Register 0x0DA[7:4])
// - Changed INITdelay from 66 to 143 (Register 0x0A0). This better aligns DSSS and OFDM SigDet
// - Changed DelayStdby from 24 to 28 (Register 0x0D8). Provides extra margin for standby-to-RX
//
// Revised 2008-06-06
// - Added infrastructure for dynamic selection of receive sensitivity
//   + Updated tuning in DwPhy_SetRxSensitivity
//   + Added function DwPhy_GetRxSensitivity
//   + Record default gain settings at the end of DwPhy_SetChannelFreq
//
// Revised 2008-06-10
// - DwPhy_ConvertHeaderRSSI: changed type on RSSI values from int8_t* to uint8_t*
// - Removed function DwPhy_GetRSSI
//
// Revised 2008-06-12
// - DwPhy_Wake: Removed redundant call to assert DW_PHYEnB for Dakota
// - DwPhy_Startup: Set the entire DwPhy private data structure to zero
// - DwPhy_SetChannel_RF52A
//   + Force PHY to sleep mode
//   + Program band/channel-specific registers before channel calibration
//   + Wake only the radio to perform manual calibrations, then return to sleep
//   + Restored code to bypass CAPSEL to allow operation with RF52A120
// - DwPhy_SetRxSensitivity
//   + Maximum sensitivity limit changed to -55 dBm
//   + Upper bound set by ThSwitchLNA, ThSwitchLNA2
//   + Adjust ThCCA1 and ThCCA2 as gain changes
//
// Revised 2008-06-16
// - DwPhy_RecordDefaultReg: Fixed typo where ThCCA2 was recorded into ThCCA1
// - DwPhy_SetRxSensitivity: Fixed direction of ThCCA? updated with dAGain
//
// Revised 2008-07-28
// - Check for errors when setting the state of DW_PHYEnB
//   + Added status code DWPHY_ERROR_DWPHYENABLE
//   + Added return status codes for DwPhy_Sleep and DwPhy_Wake
//   + Propagate errors code from DwPhy_Enable whenever called
//
// Revised 2008-07-31
// - Regrouped Mojave/Mojave1b chipsets for defaults as they are the same
// - Updated RF52B21 register values
//
// Revised 2008-08-06
// - Misc B21 register updates including increased VCO calibration window
// - Removed unused "Platform" parameter
//
// Revised 2008-08-29
// - RF52B21 configured for TX ALC using external power detector
// - Regenerated RF52B21 register values and verified the generated code matched cumulative
//   changes through 080827a.
//   + Increased PGAGAIN to maximum to improve CCK-ACR
//   + Modified TX timing to reduce pre-packet transmissions
// - Added RegByBand parameter type specific to 2.4 GHz channels
// - Added function DwPhy_RF52B21_ToggleSTARTO
//
// Revised 2008-09-09
// - Corrected calculation of MsrPwrOfs used by DwPhy_ConvertHeaderRSSI. The previous version
//   calculated the adjustment at 2/3 dB per AGAIN step rather than 3/2 dB.
//
// Revised 2008-11-13
// - Incorporate register changes for RF52B21 received from Jack on 11/7/08
// - Adjust output power
//   + DACOFFSET = 52 (was 42) to reduce maximum output power ~2.5 dB
//   + PCOUNTDEF = 115 (was 110) matches measured PCOUNT at cold temperature
// - Set Pwr100dBm = 10 (was 9) reduces reported RSSI by 0.75 dB
// - Improve DSSS/CCK operation with low CFO and/or OFDM AGC failure to attenuate
//   + ThSigSmall = 66 (was 68) allows proper AGC when CFO move all signal to one quadature component
//   + bMaxUpdateCount = 2 (was 7) prevents DSSS AGC from updating too long and missing SFD
//   + DAmpGainRange = 15 (was 12) provide more digital scaling in case OFDM AGC attenuation fails
// - Corrected bug in DwPhy_SetParameterData where pData was incremented and then freed
// - Removed support for RF52B11
//
// Revised 2009-03-05
// - Increased WakeupTime from 255 to 380
// - Increased DelayStdby from 28 to 80
// - Added dummy code for RF52B31
//
// Revised 2009-04-08
// - Added RF52B31 registers values from radio team
//
// Revised 2009-04-23
// - RF52B31 TX tuning
// - RF52B31 REFOSCTUNE
//
// Revised 2010-01-04
// - Toggle RESETB in DwPhy_Initialize to work around an apparent bug in the DW74
//
// Revised 2010-03-09
// - Add untested support for the Nevada FPGA
//
// Revised 2010-04-15
// - Allow reset via "CMU" on Nevada FPGA platform
// - Add cases for Nevada + No radio to SetDiversityMode
//
// Revised 2010-08-10
// - Enable step-up/down restart at all times
//
// Revised 2010-08-12
// - Add "dummy" code for RF22A0
//
// Revised 2010-10-08 (SMou)
// - Add RF22A02 register values from IL
// - Change DwPhy_ReadReg()/DwPhy_WriteReg() into local functions to handle indirect RF22 registers accessing
// - Add RF22 handling in DwPhy_SetDiversityMode()
//
// Revised 2010-11-03 (SMou)
// - Add TXDCOC/LOFT/IQ calibration routines for RF22
//
// Revised 2010-12-28 (SMou)
// - Update RF22 radio PartID format and add support for metal spin
// - Modify DwPhy_SetDiversityMode() for RF22 to support software-based antenna diversity;
//   default/MRC is the same as path B.
//
// Revised 2011-04-04
// - Removed case for NevadaFPGA + RF22A02
//
// Revised 2011-05-11
// - Added wrapper function DwPhy_CalibrateIQ
// - Fixed default registers for Nevada + RF52B31
// - Added default registers for Nevada + RF22A12
//
// Revised 2011-06-30
// - Changed Nevada DCX default from 800 kHz to 400 kHz
// - Modified TXDCOC routine to restore register 7 defaults
// - Modified DMW96 I/Q calibration to bypass DPD during calibration
//
// Revised 2011-07-22 (CKang)
// - Changed Nevada + R22A12 OFDMSwDThLow default from 37 to 32
// - Added antenna selection to diversity mode to Nevada + RF22
//
// Revised 2011-08-04
// - Fixed WakeupTime and DelayStdby for DMW96 (match times from DW52/74)
// - Corrected PathSel for Nevada+RF22 (relative to 110803a)
// - Added dummy code for DMW96 + RF22B0X (treat as RF22A12)
//
// Revised 2011-09-14
// - Added cases for RF22B04 (same as all RF22B0X)
//
// Revised 2011-10-24
// - Fixed DW mode in DMW96 IQ calibration for RF22B0*
// - Fixed TXDCOC to remove forcing on DCOC DAC for RF22B0*
//
// Revised 2011-11-17
// - Changed RF22B0 calibration to use RF22 instead of DMW96
// - Added pDevInfo to RF22 calibration routines where missing
// - Added Nevada1b (DMW96B) case; treat identical to Nevada (DMW96A)
// - Changed most part ID based defaults to select DWM96 + RF22B02
// Revised 2012-01-31
// - Add DwPhy_CalibrateXtal
// - Add DwPhy_CalibrateRxLPF