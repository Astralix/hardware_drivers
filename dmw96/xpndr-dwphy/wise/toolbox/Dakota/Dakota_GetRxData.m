function [data] = Dakota_GetRxData
%  [dataS] = Dakota_GetRxData
%
%  Outputs: Elements of "dataS"
%           Fault    -- error flag {0=no fault, 1=RATE/LENGTH error}
%           PHY_RX_D -- byte stream from PHY to MAC
%           h0, h1   -- estimated channel response for paths 0 and 1
%           u0, u1   -- phase corrector output arrays for paths 0 and 1
%           cSP,cCP  -- Ssampling/carrier phase correction (one per symbol)
%           AdvDly   -- AdvDly pointer output from PLL, aligned with u0,u1 at PLL input
%           RegMap   -- Dakota PHY register map
%           y0, y1   -- Equalized observations (EVM equalization)
%           EVMdB    -- Error vector magnitude (dB)
%           RATE     -- Decoded RATE field
%           LENGTH   -- Decoded LENGTH field
%           cEVMdB   -- Individual subcarrier EVMs (dB)
%           nEVMdB   -- Individual symbol EVMs (dB)
%
%  Usage  : Returns data generated by the Dakota RX2 module. Another function 
%           must cause RX2 to operate such as Dakota_RX2() or wiTest_TxRxPacket().

%   Developed by Barrett Brickner
%   Copyright 2002-2003 Bermai, Inc. All rights reserved.

if(nargin),	error('This function does not take input arguments.');  end

[PHY_RX_D,hR0,hI0,hR1,hI1,Fault,uReal0,uImag0,uReal1,uImag1,AdvDly,cSP,cCP,RegMap,EVM,y0,y1,RATE,LENGTH,N_SYM,cEVM0,cEVM1,nEVM0] = wiseMex('Dakota_GetRxData()');

PathSel = rem(RegMap(3),4);

data.Fault    = Fault;
data.PHY_RX_D = PHY_RX_D;
data.h0       = hR0 + j*hI0;
if(PathSel==3) 
    data.h1   = hR1 + j*hI1;
end
data.u0       = uReal0 + j*uImag0;
if(PathSel==3) 
    data.u1   = uReal1 + j*uImag1;
end
data.cSP      = cSP;
data.cCP      = cCP;
data.AdvDly = AdvDly;
data.RegMap   = RegMap;
data.y0 = y0;
if(PathSel==3)
    data.y1 = y1;
end
data.EVMdB0   = EVM(1);
if(PathSel==3) 
    data.EVMdB1 = EVM(2);
end
data.RATE = RATE;
data.LENGTH = LENGTH;
data.N_SYM = N_SYM;

cEVM = [cEVM0 cEVM1];
if(N_SYM>0)
    data.cEVMdB = 10*log10(cEVM/N_SYM+1e-12);
else
    data.cEVMdB = zeros(64,2);
end
if(N_SYM>0)
    data.nEVMdB = 10*log10(nEVM0(1:N_SYM)/64+1e-12);
else
    data.nEVMdB = 0;
end